{"data":{"wordpressPost":{"title":"Markov chain poem trainer+generator in 29 sloc of Haskell","content":"<p>Another step in my <a href=\"https://github.com/Swizec/Le-Thesis\" target=\"_blank\">Automagic Poetry Generation</a> project.</p>\n<blockquote><p>when i think we have tickets<br />\nwe&#8217;t my abortion i drank it&#8217;t my best friend melissa mahoney<br />\noh<br />\nwe tried to the building</p>\n<p>~The Markov Chain, based on Amanda Palmer&#8217;s Oasis</p></blockquote>\n<p>I&#8217;m making an evolutionary algorithm to generate poetry, but it needs a good base to start from. Random data is preferred, but being completely random means you waste the first couple of epochs just getting to something solid to work from &#8211; that&#8217;s a waste of time.</p>\n<p>To make everything a bit smoother, I&#8217;ve written a <a class=\"zem_slink\" title=\"Markov chain\" href=\"http://en.wikipedia.org/wiki/Markov_chain\" rel=\"wikipedia\" target=\"_blank\">markov chain</a> generator in <a class=\"zem_slink\" title=\"Haskell (programming language)\" href=\"http://haskell.org\" rel=\"homepage\" target=\"_blank\">Haskell</a> that generates the initial population. The principle is very simple:</p>\n<ol>\n<li>Read seed poem from file</li>\n<li>Tokenize</li>\n<li>Train markov chain</li>\n<li>A generator spits out an infinitely long list based on the markov chain</li>\n<li>Take X tokens</li>\n<li>Detokenize</li>\n<li>Done</li>\n</ol>\n<p>Simple.</p>\n<p>A quick brush up for people who don&#8217;t breathe &#8220;hardcore&#8221; <a class=\"zem_slink\" title=\"Computer science\" href=\"http://en.wikipedia.org/wiki/Computer_science\" rel=\"wikipedia\" target=\"_blank\">Comp Sci</a> stuff: A markov chain is essentially a probabilistic state automata, usually represented with a probability matrix. You take the current state and translate it into the next state by observing the proper probabilities.</p>\n<p>The output is a random string that looks a lot like some drunk tweets Â you might see on a friday night.</p>\n<h2>Le Code</h2>\n<p>Our main function is a simple convolution of a bunch of things:</p>\n<pre lang=\"haskell\">start_population::(RandomGen g) =&gt; g -&gt; String -&gt; IO String\r\nstart_population gen start = do\r\n  return . (foldr detokenize \"\") . (take Config.seed_length) . (produce gen start). chain . tokenize =&lt;&lt; readFile Config.seed_data</pre>\n<p>Reading it from right to left you can see that it first reads some data, tokenizes it, makes the chain, produces some output, cuts it to the proper length and then shoves it back into a normal string.</p>\n<p>Simple.</p>\n<p>Because I wanted to handle punctuation and new lines, which are important in poems, I had to write my own tokenization and detokenization functions. Otherwise the built in <em>words</em> function would be sufficient.</p>\n<pre lang=\"haskell\">tokenize::String -&gt; [String]\r\ntokenize s = Prelude.filter (\\x -&gt; x /= \" \" &amp;&amp; x /= \"\") $\r\n             Split.split (whenElt\r\n                          (\\x -&gt; isSeparator x || isPunctuation x || x == '\\n')) $\r\n             Prelude.map toLower s\r\n\r\ndetokenize::String -&gt; String -&gt; String\r\ndetokenize a b\r\n  | punctuation a || punctuation b = a++b\r\n  | otherwise = a++\" \"++b\r\n  where punctuation = (\\x -&gt; length x &gt; 0 &amp;&amp; isPunctuation (x!!0))</pre>\n<p>You can see that tokenize splits on pretty much everything and detokenize takes special care not to put spaces around punctuation.</p>\n<p>Another important step is building the chain itself.</p>\n<pre lang=\"haskell\">chain::[String] -&gt; Map String [String]\r\nchain [now, last] =\r\n  insert now [last] $ singleton last []\r\nchain (token:xs) =\r\n  insertWith (\\new old -&gt; new++old) token [xs!!0] $ chain xs</pre>\n<p>Simply put &#8211; this function builds a HashMap from a token to many tokens. The idea here is to make a note of every token that comes <em>after</em> some other token. To make things simpler, if a pair of tokens happens twice, it will be recorded twice.</p>\n<p>This magically gives us the ability to properly weigh the random function that chooses what to generate next.</p>\n<pre lang=\"haskell\">next_token::(RandomGen g) =&gt; g -&gt; Map String [String] -&gt; String -&gt; (g, String)\r\nnext_token gen map s =\r\n  let choices = findWithDefault [] s map\r\n      (i, gen') = randomR (0, length choices - 1) gen\r\n  in (gen', choices!!i)\r\n\r\nproduce::(RandomGen g) =&gt; g -&gt; String -&gt; Map String [String] -&gt; [String]\r\nproduce gen s map =\r\n  let (gen', next) = next_token gen map s\r\n  in s:(produce gen' next map)</pre>\n<p>I have a nasty suspicion the <em>next_token</em> and <em>produce</em> functions could be merged, but I found this easier to reason about.</p>\n<p><em>Next_token</em> is the meat of our algorithm &#8211; it does nothing but take a token, find a list of its possible successors in the HashMap and return a random member of that list. To avoid any issues it will return an empty string if nothing is found.</p>\n<p>The <em>produce</em> function takes care of driving <em>next_token</em> and makes sure it gets a fresh random generator every time.</p>\n<p>A problem with my technique is that once you give a random generator to the markov chain, you&#8217;re not getting it back. While it does ensure the result will always be fresh, you might be using a stale generator in other parts of your code if you&#8217;re not careful.</p>\n<p>Maybe I should finally look into that random monad I&#8217;ve been hearing about.</p>\n<p>Either way, here&#8217;s the full code, which is 38 sloc because I like including the function headers &#8211; makes code easier to think about, but I&#8217;ve tried and it does work without any type hints. Haskell is smarter than I am. Plus I added the whole part that only exposes <em>start_population</em> to the outside world, which isn&#8217;t otherwise necessary.</p>\n<pre lang=\"haskell\">module Initiators.MarkovChain (\r\n  start_population\r\n  ) where\r\n\r\nimport System.Random\r\nimport Data.HashMap\r\nimport Data.List.Split as Split\r\nimport Data.Char\r\n\r\nimport Config\r\n\r\n-- read corpus data\r\n-- build markov chain\r\n-- spit out data\r\nstart_population::(RandomGen g) =&gt; g -&gt; String -&gt; IO String\r\nstart_population gen start = do\r\n  return . (foldr detokenize \"\") . (take Config.seed_length) . (produce gen start). chain . tokenize =&lt;&lt; readFile Config.seed_data tokenize::String -&gt; [String]\r\ntokenize s = Prelude.filter (\\x -&gt; x /= \" \" &amp;&amp; x /= \"\") $\r\n             Split.split (whenElt\r\n                          (\\x -&gt; isSeparator x || isPunctuation x || x == '\\n')) $\r\n             Prelude.map toLower s\r\n\r\ndetokenize::String -&gt; String -&gt; String\r\ndetokenize a b\r\n  | punctuation a || punctuation b = a++b\r\n  | otherwise = a++\" \"++b\r\n  where punctuation = (\\x -&gt; length x &gt; 0 &amp;&amp; isPunctuation (x!!0))\r\n\r\nchain::[String] -&gt; Map String [String]\r\nchain [now, last] =\r\n  insert now [last] $ singleton last []\r\nchain (token:xs) =\r\n  insertWith (\\new old -&gt; new++old) token [xs!!0] $ chain xs\r\n\r\nnext_token::(RandomGen g) =&gt; g -&gt; Map String [String] -&gt; String -&gt; (g, String)\r\nnext_token gen map s =\r\n  let choices = findWithDefault [] s map\r\n      (i, gen') = randomR (0, length choices - 1) gen\r\n  in (gen', choices!!i)\r\n\r\nproduce::(RandomGen g) =&gt; g -&gt; String -&gt; Map String [String] -&gt; [String]\r\nproduce gen s map =\r\n  let (gen', next) = next_token gen map s\r\n  in s:(produce gen' next map)</pre>\n<h6 class=\"zemanta-related-title\" style=\"font-size: 1em;\">Related articles</h6>\n<ul class=\"zemanta-article-ul zemanta-article-ul-image\" style=\"margin: 0; padding: 0; overflow: hidden;\">\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://isnerd.wordpress.com/2012/08/28/the-markovian-mind/\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/109018143_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://isnerd.wordpress.com/2012/08/28/the-markovian-mind/\" target=\"_blank\">The Markovian Mind</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://terse-words.blogspot.com/2012/02/generating-gibberish-in-python-markov.html\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/noimg_79_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://terse-words.blogspot.com/2012/02/generating-gibberish-in-python-markov.html\" target=\"_blank\">Generating Gibberish in Python &#8211; Markov Chains</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://swizec.com/blog/amdahls-law-in-action-27s-to-0-03s-by-changing-a-function/swizec/5106\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/107290574_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://swizec.com/blog/amdahls-law-in-action-27s-to-0-03s-by-changing-a-function/swizec/5106\" target=\"_blank\">Amdahl&#8217;s law in action &#8211; 27s to 0.03s by changing a function</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://swizec.com/blog/monads-monads-monads-monads/swizec/5206\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/110047375_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://swizec.com/blog/monads-monads-monads-monads/swizec/5206\" target=\"_blank\">Monads, monads, monads, monads</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://swizec.com/blog/an-elegant-way-to-randomly-change-every-list-member-in-haskell/swizec/5060\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/106367996_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://swizec.com/blog/an-elegant-way-to-randomly-change-every-list-member-in-haskell/swizec/5060\" target=\"_blank\">An elegant way to randomly change every list member in Haskell</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://blog.ezyang.com/2012/09/common-misconceptions-about-safe-haskell/\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/noimg_61_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://blog.ezyang.com/2012/09/common-misconceptions-about-safe-haskell/\" target=\"_blank\">Common misconceptions about Safe Haskell</a></li>\n</ul>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" src=\"http://img.zemanta.com/zemified_e.png?x-id=3a0ab92f-5b51-431b-8e1b-7e2fee5375a0\" alt=\"Enhanced by Zemanta\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"c692ba16-e375-5dbc-80be-53a452d8e220"}}