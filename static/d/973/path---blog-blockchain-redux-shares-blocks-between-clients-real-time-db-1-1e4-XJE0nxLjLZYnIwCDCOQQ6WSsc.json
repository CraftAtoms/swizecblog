{"data":{"wordpressPost":{"title":"Livecoding recap: Blockchain-redux now shares blocks between clients in real-time","content":"<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/N9YIInvZZEU?feature=oembed\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe></p>\n<p>Sunday was fun. We built a thing! üéâ</p>\n<p>Well‚Ä¶ we added a thing to the You Can Use Blockchain To Store And Share UI State proof of concept I&#8217;ve been livecoding on. I&#8217;d share a live link with you, but‚Ä¶ err‚Ä¶ the app broke.</p>\n<p><em>This is a Livecoding Recap ‚Äì an almost-weekly post about interesting things discovered while livecoding. Usually shorter than 500 words. Often with pictures. Livecoding happens almost <strong>every Sunday at 2pm PDT</strong> on multiple channels. You should subscribe to <a href=\"https://www.youtube.com/TheSwizec\">My Youtube</a> channel to catch me live.</em></p>\n<p>It was working, you see. Then it wasn&#8217;t. Infinite loop on page load.</p>\n<img src=\"https://media.giphy.com/media/6lScd4x2D5Oko/giphy.gif\" />\n<p>Next time! I promise.</p>\n<p>We did get <em>something</em> working, however. When you <code>dispatch</code> an action on <code>blockchain-redux</code>, the generated block is shared live  with all other clients. That sharing still happens via Firebase, so it&#8217;s not thaaaat impressive, but it&#8217;s a step in the right direction.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">YAY IT WORKS!!!!!1111oneone blockchain-redux is getting useful for realz</p>\n<p>Blocks are shared between clients in real-time. Still backed by Firebase, but baby steps.</p>\n<p>ü§ò <a href=\"https://t.co/3L6uO3YenT\">pic.twitter.com/3L6uO3YenT</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/983112275526496256?ref_src=twsrc%5Etfw\">April 8, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>See, you create new benchmark measurements in one browser window, and the other window reacts. Magic üßô‚Äç‚ôÇÔ∏è</p>\n<p>Here&#8217;s how it works üëá</p>\n<h2>How blockchain-redux shares blocks between clients in real timeat</h2>\n<p>Long validation times got you down? Blockchain-redux is all real-time with the <code>firebaseMiddleware</code>. Soon with the WebRTC middleware too, I hope.</p>\n<p>In part that&#8217;s because there&#8217;s no <em>real</em> consensus algorithm. Any valid block is accepted to the chain. Longest chain wins by default.</p>\n<p>You may have seen <a href=\"https://swizec.com/blog/blockchain-redux-experiment-part-2/swizec/8055\">how blockchain initialization works</a> before. We read the whole chain from Firebase and replace the local chain stub.</p>\n<div id=\"attachment_8319\" style=\"width: 1574px\" class=\"wp-caption alignnone\"><img class=\"alignnone size-full wp-image-8319\" src=\"https://swizec.com/blog/wp-content/uploads/2018/04/firebase-blockchain-init.png\" alt=\"Initializing the blockchain from Firebase\" width=\"1564\" height=\"1102\" srcset=\"https://swizec.com/blog/wp-content/uploads/2018/04/firebase-blockchain-init.png 1564w, https://swizec.com/blog/wp-content/uploads/2018/04/firebase-blockchain-init-300x211.png 300w, https://swizec.com/blog/wp-content/uploads/2018/04/firebase-blockchain-init-768x541.png 768w, https://swizec.com/blog/wp-content/uploads/2018/04/firebase-blockchain-init-1024x722.png 1024w\" sizes=\"(max-width: 1564px) 100vw, 1564px\" /><p class=\"wp-caption-text\">Initializing the blockchain from Firebase</p></div>\n<p>You can read more <a href=\"https://swizec.com/blog/blockchain-redux-experiment-part-2/swizec/8055\">details about this code in a previous blogpost</a>.</p>\n<p>The part that&#8217;s new is calling <code>listenForNextBlock</code> after replacing the local chain.</p>\n<div id=\"attachment_8318\" style=\"width: 1508px\" class=\"wp-caption alignnone\"><img class=\"alignnone size-full wp-image-8318\" src=\"https://swizec.com/blog/wp-content/uploads/2018/04/wait-for-next-block.png\" alt=\"Listen for the next block\" width=\"1498\" height=\"1066\" srcset=\"https://swizec.com/blog/wp-content/uploads/2018/04/wait-for-next-block.png 1498w, https://swizec.com/blog/wp-content/uploads/2018/04/wait-for-next-block-300x213.png 300w, https://swizec.com/blog/wp-content/uploads/2018/04/wait-for-next-block-768x547.png 768w, https://swizec.com/blog/wp-content/uploads/2018/04/wait-for-next-block-1024x729.png 1024w\" sizes=\"(max-width: 1498px) 100vw, 1498px\" /><p class=\"wp-caption-text\">Listen for the next block</p></div>\n<p>We have a local chain and want to make sure we catch the next block that shows up. So we fetch the latest index with <code>store.getLastBlock().index</code>, increment by 1, and listen for changes on <code>blockchain/${nextIndex}</code>.</p>\n<p>When that block shows up, we call <code>valueHandler</code>.</p>\n<p><code>valueHandler</code> then parses the value and calls <code>store.addBlock()</code>, which validates the block fits our chain, and if it does fit, it gets added. If the block makes it to our local chain, then the redux-y stuff kicks in, wakes up all subscribed components, and re-renders happen.</p>\n<h2>Completely transparent to your app</h2>\n<p>All this real-time sharing is completely invisible to your app. You build your code just like it was any other Redux-based app.</p>\n<p>To initialize the blockchain and render a live count of nodes, you&#8217;d do something like this üëá</p>\n<pre lang=\"javascript\">\n// App.js\n\nclass App extends Component {\n    blockchain = {};\n\n    componentDidMount = async () => {\n        const FirebaseApp = firebase.initializeApp({\n            apiKey: \"\",\n            databaseURL: \"https://thing.firebaseio.com\",\n            projectId: \"thing\"\n        });\n\n        this.blockchain = await createStore(\n            benchmarkReducer,\n            firebaseMiddleware(FirebaseApp)\n        );\n\n        this.unsubscribe = this.blockchain.subscribe(() => {\n            console.log(\"Hello\");\n            this.forceUpdate();\n        });\n        this.forceUpdate();\n    };\n\n    componentWillUnmount() {\n        this.unsubscribe();\n    }\n\n   render() {\n        console.log(\"in render\", this.blockchain);\n\n        if (this.blockchain.getState) {\n            console.log(\"Current state\", this.blockchain.getState());\n        }\n\n        return (\n        <div className=\"App\">\n            <BlockchainContext.Provider value={this.blockchain}>\n                <IntroCopy />\n\n                <BlockchainContext.Consumer>\n                    {blockchain => (\n                        <Benchmarks blockchain={blockchain} />\n                    )}\n                </BlockchainContext.Consumer>\n\n                <div style={{ padding: \"3vh\" }} />\n            </BlockchainContext.Provider>\n        </div>       \n         );\n    }\n}\n</pre>\n<p>Initialize the store in <code>componentDidMount</code>, subscribe to changes, run <code>forceUpdate</code> to get around async issues, unsubscribe on unmount.</p>\n<p>The best way to make this store available to the rest of your app is via the new context API using <code>&lt;Context.Provider value={this.blockchain}&gt;</code>.</p>\n<p>Then inside <code>&lt;IntroCopy /&gt;</code>, where you display the node count, you do something like this.</p>\n<pre lang=\"javascript\">\n// IntroCopy.js\n\n// functional component boilerplate ...\n// ... render stuff\n\n<BlockchainContext.Consumer>\n    {({ getWholeChain = () => [] }) => (\n        There are {getWholeChain().length} nodes on the chain\n    )}\n</BlockchainContext.Consumer>\n\n// ... more other render stuff\n</pre>\n<p>Value passed into render prop is the whole <code>blockchain</code> store. Take out <code>getWholeChain</code> and show the length. You could use <code>getState()</code> to get the latest block value, for example.</p>\n<p>Lots of stuff you can do.</p>\n<p>And to add a new block? Just call <code>dispatch</code> and have a reducer. Blockchain-redux handles the rest üôÇ</p>\n<h2>Next steps</h2>\n<p>Still have to resolve a few TODO comments around block conflicts. What happens if your network is slow and you add blocks locally that other clients haven&#8217;t seen and you get blocks from the outside world that conflict? Which do you pick?</p>\n<p>I&#8217;m not sure yet.</p>\n<p>Plus I really want to move away from Firebase. That&#8217;s gonna be fun.</p>\n<p>Join me next Sunday as we continue exploring this experiment.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"45767736-c998-51af-ad1c-537f6a14e1d2"}}