{"data":{"wordpressPost":{"title":"Livecoding #25: Adding MobX to a vanilla React project","content":"<p><em>This is a Livecoding Recap â€“ an almost-weekly post about interesting things discovered while livecoding ?. Always under 500 words and with pictures. You can follow my channel, <a href=\"https://livecoding.tv/swizec\">here</a>. New content almost <strong>every Sunday at 2pm PDT</strong>. Thereâ€™s live chat, come say hai ?</em></p>\n<p>Well, this is embarrassingâ€¦ there&#39;s supposed to be an embedded video right here butâ€¦ I didn&#39;t make one.</p>\n<p>After an hour of coding and talking and streaming and explaining all the things I was doing and struggling with OBS eating 300% CPU, leaving one core to almost keep up with Emacs and Chrome and Npm and JavaScript, someone said, <em>&quot;Errrâ€¦ chatting with you is great butâ€¦ uhmâ€¦ no video today?&quot;</em></p>\n<p>?</p>\n<p>No wonder the view count wasn&#39;t rising and everyone was bouncing! I had done 10 seconds of streaming, then I went blank ?</p>\n<p>But I think I came up with a generalized, albeit not fleshed out, approach to taking a vanilla React project and adding MobX or Redux for state management. You should think of the code samples in this article as pseudocode.</p>\n<p>Let&#39;s say you&#39;ve been a good programmer, and youâ€™ve followed a faux flux approach even without a state handling library. React is good at encouraging that practice. If you didn&#39;t, you&#39;re going to have problems refactoring. If you followed it loosely like I did, you&#39;re going to have problems, but not quite as many.</p>\n<p>You have a main component that is <em>the</em> source of truth. Child components have a bit of their own state, and they use callback chains to propagate changes back up the tree.</p>\n<img class=\"alignnone size-full wp-image-7168\" src=\"https://swizec.com/blog/wp-content/uploads/2016/10/photo.png\" width=\"4032\" height=\"3024\" srcset=\"https://swizec.com/blog/wp-content/uploads/2016/10/photo.png 4032w, https://swizec.com/blog/wp-content/uploads/2016/10/photo-300x225.png 300w, https://swizec.com/blog/wp-content/uploads/2016/10/photo-768x576.png 768w, https://swizec.com/blog/wp-content/uploads/2016/10/photo-1024x768.png 1024w\" sizes=\"(max-width: 4032px) 100vw, 4032px\" />\n<p>In theory, following the unidirectional dataflow paradigm: data/state flows down the tree, changes flow up the tree.</p>\n<p>This is superb for example projects and small hierarchies, but it gets real messy real fast. You lose a lot of flexibility, and passing all those callbacks around gets old fast.</p>\n<p>Oh, you want to make a global state change from a button deep down in this 10-step hierarchy? Better make all those components aware of what the tiny button is doing! Don&#39;t even think about moving it somewhere else.</p>\n<p>That&#39;s where Redux or MobX step in.</p>\n<p><strong>First</strong>, you look at your App component&#39;s state. Let&#39;s say it has 5 important parts:</p>\n<pre lang=\"javascript\">\nclass App extends Component {\n    state = {\n        rawData: [],\n        filteredData: [],\n        filteringBy: null,\n        filter: () => true\n        someRandomBool: false\n    };\n}\n</pre>\n<p>You can deduce your entire component tree from the value of those 5 properties. If that&#39;s not true, then your refactor will require more steps, and most of them will hurt ðŸ™‚</p>\n<p>Your <strong>next step</strong> is to create a Redux or MobX store. I&#39;m going to show you MobX because I&#39;ve been enjoying it a lot lately.</p>\n<p>Looking at that <code>state</code>, you can guess that <code>rawData</code>, <code>filteringBy</code>, <code>filter</code>, and <code>someRandomBool</code> are the state properties. <code>filteredData</code> can be computed. It smells like <code>filter</code> might be computable as well, but it&#39;s on the fence.</p>\n<p>In a MobX store, that looks like this:</p>\n<pre lang=\"javascript\">\nclass Store {\n    @observable rawData = [];\n    @observable filteringBy = null;\n    @observable filter = () => true;\n    @observalbe someRandomBool = false;\n \n    @computed filteredData() {\n        return this.rawData.filter(this.filter);\n    }\n}\n</pre>\n<p><code>@observable</code> is a decorator that makes a variable observable. That&#39;s MobX lingo for <em>&quot;I want stuff to happen when this changes&quot;</em>. <code>@computed</code> is a decorator that makes the return value of a method observable <em>and</em> adds memoization.</p>\n<p>So no matter how often you hit that function, it only executes when its result might change. Otherwise, it&#39;s as fast as a static value.</p>\n<p>That&#39;s why we used to put computable stuff in <code>this.state</code>. To make things faster. I like this new approach because it tells anyone who cares what&#39;s a base state of the system and what&#39;s deducible.</p>\n<p><strong>After that</strong>, you go back to your <code>App</code>, replace <code>state</code> with a <code>store</code>, and make App an observer.</p>\n<pre lang=\"javascript\">\n@observer\nclass App extends Component {\n    store = new Store()\n \n    render() {\n        // change all this.state to this.store\n    }\n}\n</pre>\n<p>And you&#39;re done. Mostly.</p>\n<p>From this point onward, you should use <code>this.store</code> instead of <code>this.state</code>, and you can ignore <code>this.setState</code> in favor of good old <code>this.store.someRandomBool = true</code>. MobX&#39;s engine will trigger a re-render on any component that is an <code>@observer</code> and touches that value.</p>\n<p>Neat.</p>\n<p>Tomorrow, we&#39;ll talk about refactoring <em>that</em> into actions so your business logic becomes an easy-to-understand state machine.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"81238d65-232a-5557-bfa1-e51f8072fc60"}}