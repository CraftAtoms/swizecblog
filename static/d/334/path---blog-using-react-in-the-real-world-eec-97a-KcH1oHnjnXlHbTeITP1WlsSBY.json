{"data":{"wordpressPost":{"title":"React components as jQuery plugins","content":"<p>Did you know, you can use React without rewriting your whole app?</p>\n<p>A client recently asked me for a shiny graph. They had an <a class=\"zem_slink\" title=\"Application programming interface\" href=\"http://en.wikipedia.org/wiki/Application_programming_interface\" target=\"_blank\" rel=\"wikipedia\">API</a> that spits out a lot of data, and they wanted an interactive visualization that would help users make decisions. Deadline was tight, technology restrictions were <em>&#8220;As long as it works&#8221;</em>, and specs were loose.</p>\n<p><em>&#8220;A-ha!&#8221;</em>, I thought, <em>&#8220;This is a job for <a href=\"http://swizec.com/reactd3js\">React+d3.js</a>!&#8221;</em>. Small, well-contained, perfect. The best kind of project for testing new technologies.</p>\n<img src=\"https://i.imgflip.com/p5x14.jpg\" alt=\"React evil plot\" />\n<p>But their web app was built in Joomla or WordPress or something. And their front-end stack was <a class=\"zem_slink\" title=\"JQuery\" href=\"http://en.wikipedia.org/wiki/JQuery\" target=\"_blank\" rel=\"wikipedia\">jQuery</a>. When I asked the engineer about integration, he talked about framework plugins that create views in PHP and load <a class=\"zem_slink\" title=\"JavaScript\" href=\"http://en.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"wikipedia\">JavaScript</a> files and stuff.</p>\n<p>It sounded a lot like gems for <a class=\"zem_slink\" title=\"Ruby on Rails\" href=\"http://en.wikipedia.org/wiki/Ruby_on_Rails\" target=\"_blank\" rel=\"wikipedia\">Ruby on Rails</a>. Tiny packages that work as self-contained apps designed to be integrated into larger projects.</p>\n<p>They&#8217;d been at it for over a year already. The whole thing built out of these framework plugin component things that put most of the hard work on the server, and use JavaScript sparingly.</p>\n<p>A team of engineers isn&#8217;t going to rewrite their whole project into React, just so you can make a small component. I wasn&#8217;t going to ask, and they wouldn&#8217;t have done it.</p>\n<p><em>I</em> would have to accommodate <em>them</em>.</p>\n<p>But how?</p>\n<h2 id=\"thesolution\">The solution</h2>\n<p>Well, at the end of the day it&#8217;s still just a website. There&#8217;s a modern browser, <a class=\"zem_slink\" title=\"HTML\" href=\"http://en.wikipedia.org/wiki/HTML\" target=\"_blank\" rel=\"wikipedia\">HTML</a>, <a class=\"zem_slink\" title=\"Document Object Model\" href=\"http://en.wikipedia.org/wiki/Document_Object_Model\" target=\"_blank\" rel=\"wikipedia\">the DOM</a> model, CSS, all the basics.</p>\n<p>But there&#8217;s no ES6, no fancy build system, no JavaScript module management. None of the fancy pants future stuff.</p>\n<p>And you don&#8217;t need any of that stuff anyway. Not on the deploy side. Not on the user side. You only need that stuff when you&#8217;re developing. Once <a href=\"http://webpack.github.io/\">Webpack</a> is done compiling your code, you&#8217;ve got run of the mill present-day ES5 that runs in any mostly modern browser. I&#8217;ll tell you more about Webpack later, keep reading.</p>\n<p>I made my client happy by exporting the whole visualization component into a global function that they could call anywhere. It only took a a bit of forethought:</p>\n<pre lang=\"javascript\">const React = require('react'),\r\n           Chart = require('./chart');\r\n\r\nfunction RenderChart(options) {\r\n    React.render(\r\n        <Counter />,\r\n        document.querySelectorAll(options.selector)[0]\r\n    );\r\n}\r\n\r\nwindow.RenderChart = RenderChart;\r\n</pre>\n<p>Now my client could integrate the React component by just:</p>\n<ul>\n<li>loading React</li>\n<li>loading the compiled JS file</li>\n<li>calling a function with some parameters</li>\n</ul>\n<p>Yes, there&#8217;s some overhead with loading the whole React library for just one component. But it&#8217;s only 38KB after minifying and compressing. jQuery is 29KB and nobody bats an eye.</p>\n<p>Besides, if you&#8217;re using a public <a href=\"https://en.wikipedia.org/wiki/Content_delivery_network\">CDN</a>, many users well have React cached already. That makes it a 400 byte download to confirm you&#8217;ve got a good version. Not bad at all.</p>\n<p>But I don&#8217;t think global functions are the best way to go about integrating a React component. They mess with the global namespace, and they can only do one-way one-time communication. Once you invoke a component, it&#8217;s left to do own thing, and you have no insight.</p>\n<p>We can do better.</p>\n<h2 id=\"reactcomponentsasjquerypluginsproof-of-concept\">React components as jQuery plugins, proof-of-concept</h2>\n<p>We can package React components as jQuery plugins. Yes, we could make Backbone views, yes, we could make Angular components, yes this is an affront to sensible architecture.</p>\n<p>And it&#8217;s perfect anyway. Name one website or web app built in the last 10 odd years that doesn&#8217;t have jQuery? Name one web developer who can&#8217;t help themselves with a jQuery plugin?</p>\n<p>Exactly.</p>\n<p>Here&#8217;s a proof of concept I prepared earlier:</p>\n<p><iframe src=\"http://swizec.github.io/react-real-world/\" width=\"650\" height=\"450\" border=\"0\"></iframe></p>\n<p>You&#8217;re looking at a component that tells you how many times you&#8217;ve clicked on The Button. That&#8217;s it. Nothing fancy.</p>\n<p>The rest is a normal old school web app. There&#8217;s some jQuery to render the component, and two jQuery buttons to interact with the component once it&#8217;s rendered.</p>\n<p>The jQuery-driven white buttons can both read and write the component&#8217;s internal state. They need no React to do so. To whomever implements them, they just look like jQuery code.</p>\n<h3 id=\"usingthecomponentplugin\">Using the component/plugin</h3>\n<p>The <em>&#8220;render my component here&#8221;</em> code looks like this:</p>\n<pre lang=\"javascript\">$(\".container .counter\").clickCounter();\r\n</pre>\n<p>Nice and easy &#8211; select element, call jQuery plugin. Bam.</p>\n<p>The plugin exposes its internal state via a <code>val()</code> function. I&#8217;ll show you what the function looks like later. Using it looks like this:</p>\n<pre lang=\"javascript\">// src/integrate.js\r\n$(\".btn-10x\").click(function () {\r\n    var counter = $(\".container .counter\")\r\n            .clickCounter()[0];\r\n\r\n    counter.val(counter.val()+10);\r\n});\r\n\r\n$(\".btn-get\").click(function () {\r\n    var val = $(\".container .counter\")\r\n            .clickCounter()[0]\r\n            .val();\r\n\r\n    alert(\"Current counter value is: \"+val);\r\n});\r\n</pre>\n<p>We select an element, get its instance of the plugin, and call <code>val()</code> with or without an argument. Depending on what we need.</p>\n<p>We&#8217;re doing <code>.clickCounter()[0]</code> because I didn&#8217;t know how to properly turn the plugin into a per-element singleton. Getting the reference was easy enough, but jQuery selectors can return arrays and that means I have to return an array as well. But then the <code>.val()</code> function gets confused, which is why we have to access a single element of the returned array.</p>\n<p>Good enough for now. Anyone who knows how to use jQuery can use our React component. And they don&#8217;t even need React.</p>\n<p>Winning.</p>\n<h3 id=\"packingreactcomponentsintojqueryplugins\">Packing React components into jQuery plugins</h3>\n<p>To turn our React component into a jQuery plugin, we&#8217;ll have to take care of two things: making the plugin, and compiling our code for the real world.</p>\n<p>We&#8217;ll take care of the plugin first.</p>\n<p>I like to put this code in a <code>src/main.jsx</code> file. It serves as an entry point for the component and exports everything the outside world needs. When somebody wants to use my component from React, they can <code>require</code> the component directly.</p>\n<p>We load React, the component, and make a render function:</p>\n<pre lang=\"javascript\">// src/main.jsx\r\nconst React = require('react'),\r\n      Counter = require('./Counter');\r\n\r\nfunction RenderCounter(selector) {\r\n    React.render(\r\n        <Counter />,\r\n        document.querySelectorAll(selector)[0]\r\n    );\r\n}\r\n</pre>\n<p>This will allow us to both export the function, and set it as a global. Like this:</p>\n<pre lang=\"javascript\">module.exports = RenderCounter;\r\nwindow.RenderCounter = RenderCounter;\r\n</pre>\n<p>Anyone who&#8217;s got a dependency loader, but isn&#8217;t using React, can <code>require</code> our component, then call a function to render it inside a particular element.</p>\n<p>Anyone without a dependency loader, can use the global function.</p>\n<p>The base for our jQuery plugin comes straight off the <a href=\"http://jqueryboilerplate.com/\">jQuery boilerplate</a> project.</p>\n<pre lang=\"javascript\">// src/main.jsx\r\nif (typeof jQuery !== 'undefined') {\r\n    (function ($) {\r\n        var pluginName = \"clickCounter\",\r\n            defaults = {\r\n                value: 0\r\n            };\r\n\r\n        function Plugin(element, options) {\r\n            this.element = element;\r\n            this.settings = $.extend({}, defaults, options);\r\n            this._defaults = defaults;\r\n            this._name = pluginName;\r\n            this.init();\r\n        }\r\n\r\n        $.extend(Plugin.prototype, {\r\n            init: function () {\r\n                this.component = React.render(\r\n                    <Counter value={this.settings.value} />,\r\n                    this.element\r\n                );\r\n                return this;\r\n            },\r\n\r\n            val: function (val) {\r\n                if (!arguments.length) {\r\n                    return this.component.state.counter;\r\n                }else{\r\n                    this.settings.value = val;\r\n                    this.init();\r\n                }\r\n            }\r\n        });\r\n    })(jQuery);\r\n}\r\n</pre>\n<p>Whew, that&#8217;s a lot of code.</p>\n<p>We&#8217;re only making a plugin if jQuery is available, and we&#8217;re wrapping its definition in a closure so that we can share the <code>pluginName</code> and <code>defaults</code> variables. Then we&#8217;re defining a constructor function called <code>Plugin</code>, which stores some basic properties in the newly constructed object, and calls <code>init</code>.</p>\n<p>Inside <code>init</code>, we render our React component. We didn&#8217;t have to use <code>document.querySelectorAll</code>, because <code>this.element</code> already refers to the target DOM element.</p>\n<p>And we defined a <code>val</code> function, which we can use to access our component&#8217;s internal state. If there&#8217;s an argument, we change the value, and re-render the component. React is smart enough to say <em>&#8220;Hold up there, that&#8217;s the same component, but with different properties! I&#8217;ll just update it&#8221;</em></p>\n<p>If <code>val</code> doesn&#8217;t get an argument, it will return the component&#8217;s current state.</p>\n<p>Also notice that React was nice enough to let us access our component&#8217;s internal state with <code>this.component.state.counter</code>. No React incantation required, just some knowledge of where components store state.</p>\n<p>Okay, we&#8217;ve got the plugin function. We&#8217;ll need 5 more lines of code to add the plugin to jQuery:</p>\n<pre lang=\"javascript\">// src/main.jsx\r\n        $.fn[pluginName] = function (options) {\r\n            return this.map(function () {\r\n                if (!$.data(this, 'plugin_'+pluginName)) {\r\n                    $.data(this, 'plugin_'+pluginName, new Plugin(this, options));\r\n                }\r\n                return $.data(this, 'plugin_'+pluginName);\r\n            });\r\n        };\r\n    })(jQuery);\r\n</pre>\n<p>This will let us call <code>$(...).clickCounter()</code>. And because it saves each instance of the plugin in each element&#8217;s <code>$.data</code> collection, we can make sure to treat each instance as a per-element singleton. Every time somebody calls <code>clickCounter</code> on an element, they will get the same object.</p>\n<p>Which is neat when you want to mess around with components&#8217; internal values.</p>\n<h3 id=\"usingwebpacktocompilereactfortherealworld\">Using Webpack to compile React for the real world</h3>\n<p>Great, we&#8217;ve got the plugin. All we need now is to make a JavaScript file that people in the real world can use.</p>\n<p>We&#8217;re going to use Webpack because it&#8217;s really nice to use. It works primarily as a JavaScript dependency manager much like <a href=\"http://requirejs.org/\">RequireJS</a> or <a href=\"http://browserify.org/\">Browserify</a>.</p>\n<p>Webpack analyzes your <code>require()</code> statements to build a dependency tree of your code, and outputs a single JavaScript file that includes everything your code needs. It can potentially split your code into multiple modules, load stylesheets, various JavaScript templating files, and even images.</p>\n<p>We&#8217;ll stick to the basics &#8211; use React to transform ES6/JSX code into normal present-day JavaScript, and compile a single file for the end-user to load.</p>\n<p>It doesn&#8217;t take much, just telling Webpack to treat React and jQuery as externals, and to put the compiled code in a <code>./build/counter.js</code> file. The config looks like this:</p>\n<pre lang=\"javascript\">// webpack.config.js\r\nmodule.exports = {\r\n    entry: [\r\n        './src/main.jsx'\r\n    ],\r\n    output: {\r\n        filename: 'counter.js',\r\n        path: path.join(__dirname, 'build'),\r\n        publicPath: '/build/'\r\n    },\r\n    module: {\r\n        loaders: [\r\n            {\r\n                test: /\\.jsx$/,\r\n                loaders: ['babel'],\r\n                include: path.join(__dirname, 'src')\r\n            }\r\n        ]\r\n    },\r\n    resolve: {\r\n        extensions: ['', '.js', '.jsx']\r\n    },\r\n    externals: {\r\n        \"react\": \"React\",\r\n        \"react/addons\": \"React\",\r\n        \"jQuery\": \"jQuery\"\r\n    },\r\n};\r\n</pre>\n<p>With this, we tell Webpack that the entry point for our module is <code>./src/main.jsx</code>. That&#8217;s where we put the plugin code.</p>\n<p>Then we told it where to put compiled code &#8211; <code>./build/counter.js</code>, and that it should use <code>babel-loader</code> for source files. This allows us to use React&#8217;s JSX syntax for embedding HTML in JavaScript, as well as all the fancy new ES6 features.</p>\n<p>Using <code>externals</code>, we explained that both React and jQuery are external dependencies. This way Webpack won&#8217;t try to bundle them into the compiled file.</p>\n<p>It might make sense in some cases to bundle both of those into the same file, but we lose the benefit of serving from CDNs and the users&#8217;s browser cache.</p>\n<h2 id=\"sumup\">Sum up</h2>\n<p>There you go, a React component packaged as a jQuery plugin. For when you don&#8217;t have the time or the budget to commit to a full rewrite.</p>\n<p>You write the component as you always would, make a thin jQuery wrapper, and make sure people outside the ecosystem can include your file. Bam.</p>\n<p>You can find the whole example code on Github, <a href=\"https://github.com/Swizec/react-real-world\">here</a>.</p>\n<p>What have I done &#8230;</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"2b8b2e1b-e9a1-5a03-993c-c0c3d356beaa"}}