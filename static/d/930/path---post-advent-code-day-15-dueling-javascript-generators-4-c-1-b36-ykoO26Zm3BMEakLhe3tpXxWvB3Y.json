{"data":{"wordpressPost":{"title":"Advent of Code Day 15 â€“Â Dueling JavaScript Generators","content":"<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/mM5iTlp-Pe4?feature=oembed\" frameborder=\"0\" gesture=\"media\" allow=\"encrypted-media\" allowfullscreen></iframe></p>\n<div id=\"attachment_7972\" style=\"width: 1182px\" class=\"wp-caption alignnone\"><img class=\"alignnone size-full wp-image-7972\" src=\"https://swizec.com/blog/wp-content/uploads/2017/12/carbon-generator.png\" alt=\"JavaScript generators are ðŸ‘Œ\" width=\"1172\" height=\"580\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/12/carbon-generator.png 1172w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-generator-300x148.png 300w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-generator-768x380.png 768w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-generator-1024x507.png 1024w\" sizes=\"(max-width: 1172px) 100vw, 1172px\" /><p class=\"wp-caption-text\">JavaScript generators are ðŸ‘Œ</p></div>\n<p>Advent of Code Day 15 was basically all about finding the right programming language. It needs built-in support for generators. You don&#8217;t want to build that from scratch.</p>\n<p>But what&#8217;s a generator anyway?</p>\n<p>Well, a generator is like an infinite loop that doesn&#8217;t cause problems. The computer holds it paused in memory and only advances to the next iteration when you say, <em>&#8220;Hey, what&#8217;s the next value?&#8221;</em></p>\n<p>I don&#8217;t know how it&#8217;s implemented internally. If I had to guess, I&#8217;d say the engine holds the entire state on a stack of some sort and advances values when you ask for the next step. A lot like recursion.</p>\n<p>The full generator for Day 15 looks like this ðŸ‘‡</p>\n<pre lang=\"javascript\">\nfunction* star2generator(factor, startingValue, denominator) {\n    let val = startingValue;\n    while (true) {\n        val = (val * factor) % 2147483647;\n        if (val % denominator === 0) {\n            yield val;\n        }\n    }\n}\n</pre>\n<p>This starts from a <code>startingValue</code> and multiplies <code>val</code> with <code>factor</code> and mods the result with <code>2147483647</code> <em>forever</em>. Notice the <code>while(true)</code>? When I say forever, I mean <em>forever</em>.</p>\n<p>But it won&#8217;t crash your node runtime or your browser. Because <code>function*</code> and <code>yield</code> turn it into a generator that follows the &#8220;only execute when called&#8221; logic.</p>\n<p>You get the next value like this:</p>\n<pre lang=\"javascript\">\nconst A = generator(16807, startA, denomA);\nA.next().value // some number\nA.next().value // next number\n</pre>\n<p>The full generator only returns values that are divisible by a <code>denominator</code>. That&#8217;s from part 2 of Day 15. The first part returned every value.</p>\n<p>If that <code>2147483647</code> number looks familiar, it&#8217;s because that&#8217;s the highest number you can represent in 32 bits. This is significant because we&#8217;re going to be doing some bitwise operations and JavaScript can only do those up to 32 bits.</p>\n<p>Numbers are generally represented as 64 bits in JavaScript.</p>\n<h2>Wtf are we doing?</h2>\n<p>Right, so that&#8217;s how generators work. The reason we need generators is that the puzzle for Advent of Code Day 15 goes like this</p>\n<blockquote><p>\nTake two generators that follow similar logic and see how often the lowest 16 bits of their output match in 40,000,000 tries.</p>\n<p>For Star 2 we make them sync up a little better, check for only 5,000,000 tries\n</p></blockquote>\n<p>The generator above can handle both puzzle generators. They only differ in starting value and denominator.</p>\n<p>To count the number of matches, I used this function ðŸ‘‡</p>\n<pre lang=\"javascript\">\nfunction countMatches({\n    startA,\n    startB,\n    generator,\n    denominators = [],\n    sampleSize\n}) {\n    const A = generator(16807, startA, denominators[0]),\n        B = generator(48271, startB, denominators[1]);\n\n    let judge = 0,\n        mask = 0b00000000000000001111111111111111;\n\n    for (let i = 0; i < sampleSize; i++) {\n        if ((A.next().value &#038; mask) === (B.next().value &#038; mask)) {\n            judge += 1;\n        }\n    }\n\n    return judge;\n}\n</pre>\n<p>The same function can do both Star 1 and Star 2 of the puzzle depending on input.</p>\n<p>Here's how it works:</p>\n<ol>\n<li>Create generators <code>A</code> and <code>B</code></li>\n<li>Start at count of <code>0</code> (the <code>judge</code> variable)</li>\n<li>Create a mask that takes out the lower 16 bits of a number</li>\n<li>Loop until <code>sampleSize</code></li>\n<li>Take <code>next()</code> values from the generators, bitwise <code>AND</code> them with the mask<sup><a id=\"ffn1\" href=\"#fn1\" class=\"footnote\">1</a></sup>, compare values</li>\n<li>If numbers match, increment <code>judge</code></li>\n<li>When it's done looping, <code>judge</code> is our result</li>\n</ol>\n<p>Solving for Star 1 and Star 2 then becomes a matter of calling the <code>matchCount</code> function with our inputs.</p>\n<pre><code>console.log(\n    countMatches({\n        startA: 591,\n        startB: 393,\n        generator: star2generator,\n        denominators: [4, 8],\n        sampleSize: 5000000\n    })\n);\n</code></pre>\n<p>Boom ðŸ’¥ puzzle solved in about 20 minutes. ðŸ¤™</p>\n<p>And now you know how generators work. Although I still don't know where you'd use them in a web app.</p>\n<ol id=\"footnotes\">\n<li id=\"fn1\">If you're not used to bitwise operations, they're rare in JavaScript, the idea is that bits follow a truth table. 0 &amp; 0 == 0, 0 &amp; 1 == 0, 1 &amp; 0 == 0, 1 &amp; 1 == 1. You can use this to cut away parts of numbers with a <code>mask</code>. For example 0b1010 &amp; 0b0011  == 0b0010. ðŸ¤“ <a href=\"#ffn1\">&#8617;</a></li>\n</ol>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"3e789a91-ab4e-5407-9e82-fefff5db175a"}}