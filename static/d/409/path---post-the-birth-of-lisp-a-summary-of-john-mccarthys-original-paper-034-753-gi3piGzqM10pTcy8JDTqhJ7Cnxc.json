{"data":{"wordpressPost":{"title":"The birth of LISP &#8211; a summary of John McCarthy&#8217;s original paper","content":"<blockquote><p>A programming system called <a class=\"zem_slink\" title=\"Lisp (programming language)\" href=\"http://en.wikipedia.org/wiki/Lisp_%28programming_language%29\" rel=\"wikipedia\" target=\"_blank\">LISP</a> (for LISt Processor) has been developed for the IBM 704 computer by the <a class=\"zem_slink\" title=\"Artificial intelligence\" href=\"http://en.wikipedia.org/wiki/Artificial_intelligence\" rel=\"wikipedia\" target=\"_blank\">Artificial Intelligence</a> group at M.I.T. The system was designed to facilitate experiments with a proposed system called the Advice Taker, whereby a machine /../ could exhibit “common sense” in carrying out its instructions.</p>\n<p>/../</p>\n<p>LISP  eventually came to be based on a scheme for representing the <a class=\"zem_slink\" title=\"Computable function\" href=\"http://en.wikipedia.org/wiki/Computable_function\" rel=\"wikipedia\" target=\"_blank\">partial recursive functions</a> of a certain class of symbolic expressions. It now seems expedient to expound the system by starting with the class of expressions called S-expressions and the functions called S-functions.</p></blockquote>\n<p>With that,  <a class=\"zem_slink\" title=\"John McCarthy (computer scientist)\" href=\"http://en.wikipedia.org/wiki/John_McCarthy_%28computer_scientist%29\" rel=\"wikipedia\" target=\"_blank\">John McCarthy</a> starts off his <a href=\"https://docs.google.com/viewer?url=http%3A%2F%2Fwww.cs.berkeley.edu%2F~christos%2Fclassics%2Flisp.ps\" target=\"_blank\">Recursive Functions of Symbolic Expressions and Their Computation by Machine</a> paper. Two years after LISP was originally developed, long before many of the concepts presented in the paper become the norm.</p>\n<p>Garbage collection, for instance, was first proposed/described in this paper (invented in 1959, paper published in 1960).</p>\n<p>While LISP never really delivered on its promise of artificial intelligence and the whole field has started turning in a <a href=\"http://www.tor.com/blogs/2011/06/norvig-vs-chomsky-and-the-fight-for-the-future-of-ai\" target=\"_blank\">probabilistic rather than descriptive approach</a>, this paper is a good read for anyone whose interests in computer science and engineering go beyond comparing Ruby to PHP on a syntactical basis.</p>\n<p>The Paper is 34 pages long and took me roughly 6 hours to grok, here&#8217;s the gist in ~1300 words. For details, read the original 🙂</p>\n<h2>Functions and function definitions</h2>\n<p>For starters we need some core mathematical constructs. These are well known, but the conditional expression was believed to be new at the time.</p>\n<ul>\n<li><em><a class=\"zem_slink\" title=\"Partial function\" href=\"http://en.wikipedia.org/wiki/Partial_function\" rel=\"wikipedia\" target=\"_blank\">Partial Functions</a></em> &#8211; functions only defined on parts of their domain, they arise because the computation is intractable for some values (turing completeness)</li>\n<li><em>Propositional Expressions and Predicates</em> &#8211; functions/operators returning a <em>true</em> or a <em>false</em> (and, or, not, etc.)</li>\n<li><em>Conditional Expressions</em> &#8211; a notation for expressing values depending on predicates, which was traditionally done using human words. For instance, definining the function <em>abs(x)</em>  benefits from this concept. Best explained with an example:\n<pre lang=\"math\">(1 < 2→4, 1 > 2→3) = 4\r\n(2 < 1→4, 2 > 1→3, 2 > 1→2) = 3\r\n(2 < 1→4,T →3) = 3\r\n(2 < 1→ 0 0,T →3) = 3\r\n(2 < 1→3,T → 0 0) is undefined\r\n(2 < 1→3, 4 < 1→4) is undefined</pre>\n</li>\n<li><em>Recursive Function Definitions</em> - because of the way <em>conditional expression</em>s are defined, we can use them recursively without falling into infinite loops:\n<pre lang=\"math\">n! = (n = 0→1,T →n · (n−1)!)\r\n\r\n2! = (2 = 0→1,T →2 · (2−1)!)\r\n   = 2 · 1! = 2 · (1 = 0→1T →·(1−1)!)\r\n   = 2 · 1 · 0!\r\n   = 2 · 1 · (0 = 0→1,T →0 · (0−1)!)\r\n   = 2 · 1 · 1\r\n   = 2</pre>\n<p>The paper also defines propositional operators as recursive functions, because this helps us handle intractability without messing everything up.</p>\n<pre lang=\"math\">p ∧ q = (p→q,T →F)\r\np ∨ q = (p→T,T →q)\r\n¬p = (p→F,T →T)\r\np ⊃ q = (p→q,T →T)</pre>\n</li>\n<li><em>Functions and Forms</em> - the paper makes a distinction between forms - <em>y^2+x -</em> and functions - <em>f(x) = ...</em> - because we need a clean notation for applying functions to parameters. Thus the notion of a <em>lambda</em> is introduced that takes arguments, binds them to an expression and returns the result:\n<pre lang=\"math\">λ((x, y), y^2 + x),\r\nλ((u, v), v^2 + u)\r\nand λ((y, x), x^2 +y)\r\nare the same function</pre>\n</li>\n<li><em>Expressions and Recursive Functions</em> - lambdas aren't good enough for defining things recursively because you can't have an operator as <em>\"the whole expression\"</em>. To fix this a <em>label</em> is introduced that binds the lambda expression to a name, so it can be reused:\n<pre lang=\"math\">label(sqrt, λ((a, x, eps), (|x2 −a| < eps→x,T →sqrt(a, 1/2(x+ a/x), eps))))</pre>\n</li>\n</ul>\n<h2>Recursive functions of Symbolic expressions</h2>\n<p>Now that we have a solid basis, it's time to define symbolic expressions (S-expressions for short), show how they can be used to define functions, how those functions can in turn be represented as S-expressions and finally we will define the all important <em>apply</em> function, which lets the computer calculate anything.</p>\n<p><strong>S-expressions</strong> are formed by using the special characters <em>dot, left-, right- parentheses</em> [<em>·</em>()] and distinguishable atomic symbols (defined in this paper as capital Latin letters, digits and a single space).</p>\n<ol>\n<li>Atomic symbols are S-expressions</li>\n<li>If <em>e1</em> and <em>e2</em> are S-expressions, so is <em>(e1 · e2)</em></li>\n</ol>\n<p>So an S-expression is any ordered pair of S-expressions. Strictly speaking we are supposed to terminate any nesting of S-expressions with a <em><a class=\"zem_slink\" title=\"NIL (programming language)\" href=\"http://en.wikipedia.org/wiki/NIL_%28programming_language%29\" rel=\"wikipedia\" target=\"_blank\">NIL</a></em>, but we agree that <em>(m)</em> stands for <em>(m<em> · NIL) </em></em>and that instead of a dot operator we can write expressions as lists, which makes our lives a lot easier</p>\n<pre lang=\"math\">((AB,C),D) for ((AB · (C ·NIL)) · (D ·NIL))\r\n((A,B),C,D·E) for ((A· (B ·NIL)) · (C · (D · E)))</pre>\n<p><strong>Functions of S-expressions</strong> use conventional notation, except they're limited to lower case letters, brackets and semicolons to distinguish them from S-expressions. These are called M-expressions (meta-expressions)</p>\n<pre lang=\"math\">car[x]\r\ncar[cons[(A· B); x]]</pre>\n<p>McCarthy then defines five<strong> Elementary S-functions and Predicates</strong>. <em>atom</em> tells us whether something is atomic, <em>eq</em> compares two atomic things and tells us if they're equal, <em>car</em> returns the left part of an S-expression, <em>cdr</em> returns the right and <em>cons</em> constructs an S-expression from two atoms.\\</p>\n<p>By introducing <strong>Recursive S-functions</strong> we finally get a strong enough class of functions that we can construct all computable functions. McCarthy now defines a bunch of useful functions<em> - </em>let's look at the example of <em>ff</em>, which returns the first element of an S-expression.</p>\n<pre lang=\"math\">ff[x] = [atom[x]→x;T →ff[car[x]]]\r\n\r\nff [((A · B) · C)] = A\r\ncalculation:\r\n= [atom[((A · B) · C)]→((A· B) · C);T →ff[car[((A· B)C·)]]]\r\n= [F →((A· B) · C);T →ff[car[((A· B) · C)]]]\r\n= [T →ff[car[((A· B) · C)]]]\r\n= ff[car[((A· B) · C)]]\r\n= ff[(A· B)] = [atom[(A · B)]→(A· B);T →ff[car[(A ·B)]]]\r\n= [F →(A· B);T →ff[car[(A· B)]]]\r\n= [T →ff[car[(A· B)]]]\r\n= ff[car[(A· B)]]\r\n= ff[A]\r\n= [atom[A]→A;T →ff[car[A]]]\r\n= [T →A;T →ff[car[A]]]\r\n= A</pre>\n<p>The next thing we need is <strong>Representing S-functions as S-expressions. </strong>We do this simply by changing lowercase into uppercase and properly handling some cases around labels and quotes. The M-expression for subst</p>\n<pre lang=\"math\">label [subst; λ [[x; y; z]; [atom [z] → [eq [y; z] → x; T → z]; T → cons [subst [x; y; car [z]]; subst [x; y; cdr [z]]]]]]</pre>\n<p>becomes the S-expression</p>\n<pre lang=\"math\">(LABEL, SUBST, (LAMBDA, (X, Y, Z), (COND ((ATOM, Z), (COND, (EQ, Y, Z), X), ((QUOTE, T), Z))), ((QUOTE, T), (CONS, (SUBST, X, Y, (CAR Z)), (SUBST, X, Y, (CDR, Z)))))))</pre>\n<p>Soup. It looks like a soup of weird.</p>\n<p>But it's very simple in principle. Add some tactical line breaks and code alignment and you get readable code!</p>\n<pre lang=\"math\">(LABEL, SUBST,\r\n        (LAMBDA, (X, Y, Z),\r\n                 (COND ((ATOM, Z),\r\n                        (COND, (EQ, Y, Z), X),\r\n                        ((QUOTE, T), Z))),\r\n                 ((QUOTE, T),\r\n                  (CONS, (SUBST, X, Y, (CAR Z)),\r\n                         (SUBST, X, Y, (CDR, Z)))))))</pre>\n<p><strong>The Universal S-Function <em>apply</em></strong> is the all important function that gives us a way of applying a function to a list of arguments. It's a bit tricky to define and reason about - all you have to keep in mind is that it behaves exactly the same as the function it is applying. The main consequence of this is that we can now implement a machine (an interpreter) that only needs to implement the <em>apply</em> function and it can run any program we write.</p>\n<pre lang=\"math\">λ[[x; y]; cons[car[x]; y]][(A,B); (C,D)]\r\n= apply[(LAMBDA, (X,Y ), (CONS, (CAR,X),Y )); ((A,B), (C,D))] = (A,C,D)</pre>\n<p>In the background, <em>apply</em> is an expression that represents the value of the function applied to arguments, while <em>eval</em> does the heavy lifting of calculation, which takes an expression and its \"name\" as arguments, so it can attach the value to something useful in the next step of calculation.</p>\n<p>And we've come at the juicy goodness of functional programming - <strong>Functions with Functions as Arguments. </strong>The idea is that we can use an S-expression as an argument for another S-expression similar to what we did with <em>apply</em>, except in a more generally useful way.</p>\n<p>The paramount example is <em>maplist </em>(called \"map\" these days), which applies a function to every member of a list to construct a different list - for instance increasing all values by +1.</p>\n<h2>The LISP programming system</h2>\n<p>LISP's core is a system of translating S-expressions into list structures that can be evaluated by a computer. This system was intended for various uses, the ultimate of which was the Advice Taker system.</p>\n<p><strong>Representing S-Expressions by a List Structure</strong> can be visualised with a set of connected boxes. Each box is divided into two parts - the right being the <em>address field</em> and the left being the <em>decrement field</em>. They contain the locations for subexpressions returned by <em>car</em> and <em>cdr</em> respectively.</p>\n<div id=\"attachment_5133\" style=\"width: 475px\" class=\"wp-caption alignnone\"><a href=\"http://swizec.com/blog/wp-content/uploads/2012/08/list-structure.png\"><img class=\"size-full wp-image-5133 \" title=\"List structure\" src=\"http://swizec.com/blog/wp-content/uploads/2012/08/list-structure.png\" alt=\"List structure\" width=\"465\" height=\"309\" srcset=\"https://swizec.com/blog/wp-content/uploads/2012/08/list-structure.png 465w, https://swizec.com/blog/wp-content/uploads/2012/08/list-structure-300x199.png 300w\" sizes=\"(max-width: 465px) 100vw, 465px\" /></a><p class=\"wp-caption-text\">List structure</p></div>\n<p>Substructures can be repeated, but cycles aren't allowed - the bottom-right example wouldn't fly. When subexpressions are repeated their in-memory representation depends mostly on the program's history, but luckily this doesn't affect the final result.</p>\n<p>The reason McCarthy prohibits circular structures is interesting - they might help with representing, say, recursive functions, but there are too many difficulties with printing them in a world with our topology.</p>\n<div id=\"attachment_5134\" style=\"width: 175px\" class=\"wp-caption alignnone\"><a href=\"http://swizec.com/blog/wp-content/uploads/2012/08/example-list-structure.png\"><img class=\"size-full wp-image-5134 \" title=\"((A · B) · (C · (E · F)))\" src=\"http://swizec.com/blog/wp-content/uploads/2012/08/example-list-structure.png\" alt=\"((A · B) · (C · (E · F)))\" width=\"165\" height=\"167\" /></a><p class=\"wp-caption-text\">((A · B) · (C · (E · F)))</p></div>\n<p>When storing atomic symbols an <strong>association list</strong> is used. These are used for anything from print names, to memory locations of values - the machine uses them for whatever low-level concept it needs to make the mathematical principles of LISP work.</p>\n<p>For example, to store the word <em>DIFFERENTIATE</em> in an association list on a computer with 6-bit words a structure such as this is used:</p>\n<div id=\"attachment_5136\" style=\"width: 380px\" class=\"wp-caption alignnone\"><a href=\"http://swizec.com/blog/wp-content/uploads/2012/08/association-list.png\"><img class=\"size-full wp-image-5136\" title=\"Association list for &quot;DIFFERENTIATE&quot;\" src=\"http://swizec.com/blog/wp-content/uploads/2012/08/association-list.png\" alt=\"Association list for &quot;DIFFERENTIATE&quot;\" width=\"370\" height=\"148\" srcset=\"https://swizec.com/blog/wp-content/uploads/2012/08/association-list.png 370w, https://swizec.com/blog/wp-content/uploads/2012/08/association-list-300x120.png 300w\" sizes=\"(max-width: 370px) 100vw, 370px\" /></a><p class=\"wp-caption-text\">Association list for &quot;DIFFERENTIATE&quot;</p></div>\n<p>Even back then computers had more memory than a typical program would be using at all times, so a concept of a <strong>free storage list</strong> was introduced. At its core, the free storage list is simply a list structure that catalogs all the available free memory and starts with a pointer called <em>FREE</em>.</p>\n<p>A straightforward concept no doubt, but it introduces the invention of <strong>garbage collection</strong>. Whenever a subexpression is no longer needed it can be added to the free storage list. And because we're using lists, every single redeemed element is useful!</p>\n<p>Sweet!</p>\n<p>When our program runs out of free memory the garbage collector (called <em>\"a reclamation cycle\" </em>back then) goes through all accessible registers and marks them. Then it simply goes through the whole memory and anything that wasn't marked as accessible gets added to the free storage list.</p>\n<p>It's easy to imagine how the <strong>elementary S-functions work in the Computer</strong><em>. </em>They amount to nothing more than returning the correct part of the word. So <em>car</em> returns the address value, <em>cdr</em> the decrement value, <em>cons</em> takes from free storage and fills the values ... and so on.</p>\n<p>Everything else is merely constructed from elementary functions.</p>\n<p>Another interesting observation is that talking about <strong>representation of S-functions by Programs</strong> McCarthy ever so casually introduces lazy evaluation by saying that compilation is simple and <em>\"conditional expressions must be so compiled that only the </em>p's<em> and </em>e's<em> that are required are computed\"</em></p>\n<p>There are some problems with compiling recursive functions because of a possibility of register collisions - needing a part of memory that is also used by the previous level of recursion - which is solved by employing a mechanism we now know as <em>The Stack</em>.</p>\n<h2>Fin</h2>\n<p>Further on McCarthy details the current state of the LISP system - everything basically works, a manual is being prepared, the compiler is 60-times faster than the interpreter and floating point operations are slow.</p>\n<p>There is also a short chapter on an alternative presentation of functions of symbolic expressions called <em>L-expressions</em>. They are the basis of linear LISP and use the more familiar elementary functions <em>first, rest</em> and <em>combine</em>.</p>\n<p>Mathematically speaking linear LISP includes LISP, but for computers regular LISP is said to be faster.</p>\n<p>Now if only there weren't so many damn parentheses ... <a href=\"http://swizec.com/blog/tag/clojure\" target=\"_blank\">I tried to learn LISP (clojure really)</a>, I really did. But the syntax was just too jarring.</p>\n<h6 class=\"zemanta-related-title\" style=\"font-size: 1em;\">Related articles</h6>\n<ul class=\"zemanta-article-ul zemanta-article-ul-image\" style=\"margin: 0; padding: 0; overflow: hidden;\">\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://passionsjustlikemine.wordpress.com/2012/07/27/john-mccarthy-in-the-literary-arena/\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/102977749_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://passionsjustlikemine.wordpress.com/2012/07/27/john-mccarthy-in-the-literary-arena/\" target=\"_blank\">John McCarthy in the Literary Arena</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://blog.fogus.me/2012/07/25/some-lisp-books-and-then-some/\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/noimg_97_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://blog.fogus.me/2012/07/25/some-lisp-books-and-then-some/\" target=\"_blank\">Some Lisp books (and then some)</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://nic.ferrier.me.uk/blog/2012_07/tips-and-tricks-for-emacslisp\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/noimg_3_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://nic.ferrier.me.uk/blog/2012_07/tips-and-tricks-for-emacslisp\" target=\"_blank\">Tips and tricks with emacslisp for fun and profit</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://www.drdobbs.com/tools/developers-reading-list/240003875\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/101202848_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://www.drdobbs.com/tools/developers-reading-list/240003875\" target=\"_blank\">Developer's Reading List</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://kresimirbojcic.com/2012/08/14/why-lisp-did-not-and-never-will-gain-enough-traction.html\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/noimg_46_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://kresimirbojcic.com/2012/08/14/why-lisp-did-not-and-never-will-gain-enough-traction.html\" target=\"_blank\">Why Lisp Did Not and Never Will Gain Enough Traction</a></li>\n</ul>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" src=\"http://img.zemanta.com/zemified_e.png?x-id=27a245ba-8da2-4b42-a319-61686149e5a2\" alt=\"Enhanced by Zemanta\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"d008ea0a-fad3-56a5-b787-18d875498b26"}}