{"data":{"wordpressPost":{"title":"Declarative `canvas` Animation with React and Konva","content":"<div style=\"position:relative;height:0;padding-bottom:56.25%\"><iframe src=\"https://www.youtube.com/embed/oli1qacE-wo?ecver=2\" width=\"640\" height=\"360\" frameborder=\"0\" style=\"position:absolute;width:100%;height:100%;left:0\" allowfullscreen></iframe></div>\n<p>Today we&#39;re looking at declarative animation that renders on <code>&lt;canvas&gt;</code>:  React for declarativeness, <a href=\"https://konvajs.github.io/\">Konva</a> as a canvas abstraction layer, and <a href=\"https://github.com/lavrton/react-konva\">react-konva</a> to make them work together.</p>\n<p>In theory, this combination has better performance than SVG+React but worse performance than raw canvas because of the additional abstraction layers. We have canvas as the rendering layer, then Konva gives us basic shapes and interactions, <code>react-konva</code> turns those into React components, and our own React code makes it work together.</p>\n<p>If that sounds complicatedâ€¦ it probably is. I barely know how to use it, and I have no idea how it <em>actually</em> works.</p>\n<img class=\"alignnone size-full wp-image-7442\" src=\"https://swizec.com/blog/wp-content/uploads/2017/02/bouncing-marbles-1.gif\" width=\"1030\" height=\"710\" />\n<p>We&#39;re building a marble simulation. You can pick up a marble and throw it, and it bounces around until it stops. I wanted to add collision detection as well, but <a href=\"https://en.wikipedia.org/wiki/N-body_problem\">N-body collisions are hard</a>. Next time!</p>\n<p>You can see the <a href=\"https://github.com/Swizec/declarative-canvas-react-konva\">code on Github</a> and play with marbles on the <a href=\"https://swizec.github.io/declarative-canvas-react-konva/\">live demo</a>. The live demo looks better than the gif, I promise.</p>\n<p>We have two components:</p>\n<ul>\n<li><code>Marble</code>, which renders each marble and deals with drag events</li>\n<li><code>Collisions</code>, which renders all the marbles and deals with the game loop logic</li>\n</ul>\n<p>Yes, the game loop logic should totally be a Redux or MobX store instead of shoved into a component. This is fine. Small example ?</p>\n<h2>Marble</h2>\n<p>The <code>Marble</code> component uses <code>react-konva</code> to render a <code>&lt;Circle&gt;</code> and listen for a <code>dragend</code> event. That&#39;s how you &quot;throw&quot;.</p>\n<p>You can think of react-konva as a very thin abstraction layer on Konva. I looked at the source code once, and it just uses a bit of magic to translate all of <a href=\"https://konvajs.github.io/api/Konva.html\">Konva&#39;s classes</a> into React components. Props are passed through unchanged as Konva attributes.</p>\n<p>That means you don&#39;t have to think about using react-konva. Focus on the Konva docs, it&#39;s all the same.</p>\n<pre lang=\"javascript\">\nclass Marble extends Component {\n    onDragEnd() {\n        const { x, y } = this.props,\n              circle = this.refs.circle;\n\n        this.props.onShoot({\n            x: circle.attrs.x,\n            y: circle.attrs.y,\n            vx: (circle.attrs.x-x)/7,\n            vy: (circle.attrs.y-y)/7\n        });\n    }\n\n    render() {\n        const { x, y, sprite, type, draggable } = this.props;\n\n        return (\n            <Circle x={x} y={y} radius={MarbleR}\n                    fillPatternImage={sprite}\n                    fillPatternOffset={Marbles[type]}\n                    fillPatternScale={{ x: MarbleR*2/111, y: MarbleR*2/111 }}\n                    shadowColor={Marbles[type].c}\n                    shadowBlur=\"15\"\n                    shadowOpacity=\"1\"\n                    draggable={draggable}\n                    onDragEnd={this.onDragEnd.bind(this)}\n                    ref=\"circle\"\n                    />\n        );\n    }\n}\n</pre>\n<p>We&#39;re rendering a <code>&lt;Circle&gt;</code> element at position <code>(x, y)</code> and giving it a radius of <code>15</code>. Very similar to SVG, right?</p>\n<p>Here&#39;s where it gets crazy. To get the marble look, we use <code>fillPattern*</code> props and use a <code>sprite</code> for the background. We reposition and scale it to get the sprite to fit and make marbles look different.</p>\n<img class=\"alignnone size-full wp-image-7441\" src=\"https://swizec.com/blog/wp-content/uploads/2017/02/sprite.png\" width=\"800\" height=\"600\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/02/sprite.png 800w, https://swizec.com/blog/wp-content/uploads/2017/02/sprite-300x225.png 300w, https://swizec.com/blog/wp-content/uploads/2017/02/sprite-768x576.png 768w\" sizes=\"(max-width: 800px) 100vw, 800px\" />\n<p>For the shine effect, we use <code>shadow*</code> props. Shadows get a color that matches each marble (I used Photoshop), some blur, and an opacity. This gives each marble a glow that makes the marbles look shiny.</p>\n<p>They&#39;re still shadows though, so a bunch of things are wrong. Especially when the marbles get close together, you can see that the shadows look darker when combined. Real shines would look brighter.</p>\n<p>To get draggability, we turn it on. Konva handles the rest for us. <code>onDragEnd</code> we call the <code>onShoot</code> callback with the marble&#39;s new position and movement vector. This part is janky. I&#39;ll explain why later.</p>\n<h2>Collisions</h2>\n<p>The <code>&lt;Collisions&gt;</code> component is called collisions because this was meant to be a simulation of <a href=\"https://en.wikipedia.org/wiki/Inelastic_collision\">inelastic N-body collisions</a>. High school physics stuff.</p>\n<p>But that&#39;s hard to do, so you get just the bouncing off of walls.</p>\n<p>This component has three major parts:</p>\n<ul>\n<li>calculating the initial positions to make a triangle</li>\n<li>the game loop that drives animation</li>\n<li>declaratively rendering the marbles</li>\n</ul>\n<pre lang=\"javascript\">\nclass Collisions extends Component {\n    constructor(props) {\n        // setting up this.state\n    }\n\n    get initialPositions() {\n        // calculating initial positions\n    }\n\n    componentDidMount() {\n        // loading sprite\n    }\n\n    shoot(newPos, i) {\n        // updating a thrown marble\n    }\n\n    gameLoop() {\n        // moving\n    }\n\n    render() {\n            // rendering\n    }\n</pre>\n<h3>Initial positions and sprite loading</h3>\n<pre lang=\"javascript\">\n    componentDidMount() {\n        const sprite = new Image();\n        sprite.src = MarbleSprite;\n\n        sprite.onload = () => {\n            this.setState({\n                sprite: sprite\n            });\n\n            this.timer = timer(() => this.gameLoop());\n        };\n    }\n</pre>\n<p>Konva takes sprites as ES6 <code>Image</code> objects. We load one up, wait for the <code>onload</code> event to fire, add it to state, which triggers a re-render, and start the game loop timer.</p>\n<p>If you&#39;re not familiar with the <code>Image</code> object, it&#39;s basically an in-memory representation of the image bytestream. Unless you&#39;re doing something very particular, you don&#39;t need to know the details. It loads an image into memory ðŸ™‚</p>\n<pre lang=\"javascript\">\n    get initialPositions() {\n        const { width, height } = this.props,\n              center = width/2;\n\n        let marbles = range(3, 0, -1).map(y => {\n            if (y === 3) return [{ x: center, y: 200,\n                                   vx: 0, vy: 0}];\n\n            const left = center - y*(MarbleR+5),\n                  right = center + y*(MarbleR+5);\n\n            return range(left, right, MarbleR*2+5).map(x => ({\n                x: x,\n                y: 200-y*(MarbleR*2+5),\n                vx: 0,\n                vy: 0\n            }));\n        }).reduce((acc, pos) => acc.concat(pos), []);\n\n        marbles = marbles.concat({\n            x: width/2,\n            y: height-150,\n            vx: 0,\n            vy: 0\n        });\n\n        return marbles;\n    }\n</pre>\n<p>Thisâ€¦ this took me embarrassingly long to code. It&#39;s one of those interview question things: Render stuff in a triangle. Then you fumble for an hour, and they&#39;re like <em>&quot;LoL you&#39;re an idiot, pass&quot;</em>.</p>\n<p>That was going through my mind the entire time. How the hell am I struggling <em>this</em> hard to put marbles in a triangle?</p>\n<p>Here&#39;s how it works:</p>\n<ul>\n<li>loop from 3 to 0 to create the rows</li>\n<li>in each row. go from the <code>left</code> edge to the <code>right</code> edge with a step of &quot;marble size&quot;</li>\n<li>add position to array</li>\n</ul>\n<p>You get the left edge is <code>y</code> marble halves to the left, and the right is <code>y</code> marble halves to the right. This nested loop approach returns a nested array so you flatten it with a <code>.reduce</code>.</p>\n<p>Oh, and those <code>range()</code> functions are actually <code>d3.range</code>. I got them with <code>import { range } from &#39;d3-array&#39;</code>.</p>\n<h3>Game loop</h3>\n<p>Our game loop is a function that <code>d3.timer</code> calls on every <code>requestAnimationFrame</code>. It goes through our array of marbles, updates their positions, and triggers a re-render.</p>\n<p>Like this:</p>\n<pre lang=\"javascript\">\n    shoot(newPos, i) {\n        let marbles = this.state.marbles;\n\n        marbles[i] = newPos;\n\n        this.setState({\n            marbles: marbles\n        });\n    }\n\n    gameLoop() {\n        const { width, height } = this.props;\n\n        const moveMarble = ({x, y, vx, vy}) => ({\n            x: x+vx,\n            y: y+vy,\n            vx: ((x+vx < MarbleR) ? -vx : (x+vx > width-MarbleR) ? -vx : vx)*.99,\n            vy: ((y+vy < MarbleR) ? -vy : (y+vy > height-MarbleR) ? -vy : vy)*.99\n        });\n\n        this.setState({\n            marbles: this.state.marbles.map(moveMarble)\n        });\n    }\n</pre>\n<p>See? Loop through marbles and update their positions by adding the speed vector to the position. We invert the speed vector when a marble is about to hit a wall in the next step.</p>\n<p>Nested ternary expressions are hard to read. I should refactor that. If <code>x+vx</code> is smaller than left edge, invert <code>vx</code>. Otherwise if <code>x+vx</code> is bigger than right edge, invert <code>vx</code>. Otherwise, leave it alone.</p>\n<p>The <code>shoot()</code> function is that dragend callback that <code>&lt;Marble&gt;</code> calls. It updates the particular marble with the new position and the new speed vector.</p>\n<h3>Rendering</h3>\n<p>After all that logic, rendering is the easy part. We loop through the marbles and declaratively add them to the <code>Stage</code>. Stage is what Konva calls the canvas element. I don&#39;t fully understand why, but I&#39;m sure there&#39;s a reason.</p>\n<pre lang=\"javascript\">\n    render() {\n        const { sprite } = this.state,\n              { width, height } = this.props,\n              marbleTypes = Object.keys(Marbles);\n\n        if (!sprite) {\n            return (<h2>Loading sprites ...</h2>);\n        }\n\n        return (\n            <Stage width={width} height={height}>\n                <Layer>\n                    <Group>\n                        {this.state.marbles.map(({x: x, y: y}, i) => (\n                            <Marble x={x}\n                                    y={y}\n                                    type={marbleTypes[i%marbleTypes.length]}\n                                    sprite={sprite}\n                                    draggable=\"true\"\n                                    onShoot={(newPos) => this.shoot(newPos, i)}\n                                    key={`marble-${i}`} />\n                        ))}\n                    </Group>\n                </Layer>\n            </Stage>\n        )\n    }\n</pre>\n<p>See? Loop through <code>marbles</code>, put down <code>Marble</code> components. All this inside a <code>Stage</code>, which is the canvas, and <code>Layer</code>, which I think makes more sense when you have more than one, and <code>Group</code> which is the same concept as SVG&#39;s <code>&lt;g&gt;</code> element. It helps you think of groups of shapes as a single thing.</p>\n<p>A Stage must always have at least one Layer. So that part is important albeit seemingly useless.</p>\n<h2>Why is your demo so janky, Swizec?</h2>\n<p>Did you guess it yet? Why am I having so much trouble throwing marbles at <a href=\"https://youtu.be/oli1qacE-wo?t=14\">0:14 in the video</a>?</p>\n<p>It&#39;s the game loop and Konva fighting each other. The game loop re-renders all our marbles every 16 milliseconds. Konva isn&#39;t telling React that they&#39;ve moved, so the position is reset.</p>\n<p>That means you <em>have to</em> complete your throw within 16ms or it won&#39;t work.</p>\n<p>Now, while this looks really bad, it&#39;s not a fundamental limitation of the React-Konva-Canvas stack. Just an extra step to take care of before I tackle the N-body collisions.</p>\n<p>Gotta add a <code>dragmove</code> listener to <code>Marble</code> and make sure it updates React state. Should be easy ?</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"36e3fd01-6902-52c2-919a-d6fd2135031e"}}