{"data":{"wordpressPost":{"title":"Week 7: Time, Clocks, and Ordering of Events in a Distributed System","content":"<p><em>[This post is part of an ongoing challenge to understand 52 papers in 52 weeks. You can read previous entries, <a href=\"http://swizec.com/blog/category/52-papers-in-52-weeks\">here</a>, or subscribe to be notified of new posts by <a href=\"http://swiz.ec/52papers-list\">email</a>]</em></p>\n<p>Have you ever wondered what it takes tell which event <a class=\"zem_slink\" title=\"Happened-before\" href=\"http://en.wikipedia.org/wiki/Happened-before\" target=\"_blank\" rel=\"wikipedia\">happened before</a> which in a distributed system?</p>\n<p>Neither have I, but it&#8217;s a problem Leslie Lamport solved in 1978 with his paper <a href=\"http://www.stanford.edu/class/cs240/readings/lamport.pdf\"><em>Time, Clocks, and the Ordering of Events in a Distributed System</em></a>. The paper even won the Dijkstra award in 2000.</p>\n<h2 id=\"the-problem\">The problem</h2>\n<p>Our lives revolve around the notion that events have an inherent ordering. That some events happen <em>before</em> other events. An airline ticket booking should only be granted if it happens <em>before</em> the flight departs. It&#8217;s 3:15 if the clock doesn&#8217;t read 3:16 yet and so on.</p>\n<p>But in a distributed system the idea of &#8220;happened before&#8221; fast becomes hazy. When you have spatially separated processes that can only communicate through messages, they can&#8217;t tell what in the system happened before something else.</p>\n<p>We usually look at the clock to decide whether <em>a</em> happened before <em>b</em>, but a well defined system can only rely only on information within the system. That&#8217;s why Lamport defined &#8220;happened before&#8221; without using real clocks.</p>\n<div style=\"width: 555px\" class=\"wp-caption alignnone\"><img title=\"Distributed system\" alt=\"Distributed system\" src=\"https://draftin.com:443/images/4760?token=Ndcukkg7IT7WRqqfOn9CUYaQmS5w3TNowpejiQMawpP1k1F4mg7W-jFsW3TLBtogU0CmJIuMq0VVrKBeN3fpTtw\" width=\"545\" height=\"475\" /><p class=\"wp-caption-text\">Distributed system</p></div>\n<p>&nbsp;</p>\n<p>In the image, each line represents a process, a dot is an event and a squiggly line is a message being sent between two processes. Sending a message and receiving a message are both events as well.</p>\n<p>Time as we think of it goes from bottom to top, but isn&#8217;t strictly defined. In this picture you can&#8217;t compare relative positions of dots in separate processes to determine order.</p>\n<p>The relation &#8220;happened before&#8221;, or → for short, between a set of events is the smallest relation that satisfies three rules:</p>\n<ol>\n<li>If <em>a</em> and <em>b</em> are in the same process and <em>a</em> comes before <em>b</em>, then <em>a → b</em></li>\n<li>If <em>a</em> is sending a message and <em>b</em> is receiving it, then <em>a → b</em></li>\n<li>If <em>a → b</em> and <em>b → c</em>, then <em>a → c</em></li>\n</ol>\n<p>We assume events can&#8217;t happen before themselves because that doesn&#8217;t make sense in our physical reality (although it could in others, but it&#8217;d break a bunch of other stuff as well).</p>\n<p>Using these rules, you can follow the progress of time by following process and message lines. If you draw time borders with a dashed line, you&#8217;ll get a diagram like this:</p>\n<div style=\"width: 559px\" class=\"wp-caption alignnone\"><img title=\"Diagram with time\" alt=\"Diagram with time\" src=\"https://draftin.com:443/images/4761?token=9CSqra29cpBmU2l3-ksLdhOOywe1D77x24tAUkr9Sb-1f4486C_qEH08rOiSP6g6nswCFWl96NWSn5bvKccETpA\" width=\"549\" height=\"487\" /><p class=\"wp-caption-text\">Diagram with time</p></div>\n<p>&nbsp;</p>\n<p>You can look at → through the lense of causality: <em>a</em> happens before <em>b</em>, if it can affect <em>b</em>. In this case, process <em>P</em> at time <em>p<sub>3</sub></em>, can&#8217;t know what <em>Q</em> is doing in <em>q<sub>3</sub></em> until the message from <em>q<sub>5</sub></em> is received in <em>p<sub>4</sub></em>. It can only guess what <em>Q</em> intends to do.</p>\n<p>This goes right at the gist of our problem: it is not immediately obvious how one can put events in correct order without an external observer.</p>\n<h2 id=\"logical-clocks-solution\">Logical clocks solution</h2>\n<p>To elegantly solve the problem Lamport introduces logical clocks, now known as <a class=\"zem_slink\" title=\"Lamport timestamps\" href=\"http://en.wikipedia.org/wiki/Lamport_timestamps\" target=\"_blank\" rel=\"wikipedia\">Lamport timestamps</a>. Simple counters that assign numbers to events.</p>\n<p>Every process <em>P<sub>i</sub></em> is going to have its own clock function <em>C<sub>i</sub></em> that assigns a number <em>C<sub>i</sub>(a)</em> to any event in that process. We assume these clocks aren&#8217;t tied to the physical concept of time, so all it takes to make this system of clocks correct are a few rules.</p>\n<ol>\n<li>If <em>a</em> and <em>b</em> are events in <em>P<sub>i</sub></em> and <em>a</em> comes before <em>b</em>, then <em>C<sub>i</sub>(a) &lt; C<sub>i</sub>(b)</em></li>\n<li>If <em>a</em> is sending a message from <em>P<sub>i</sub></em> to <em>b</em> in <em>P<sub>j</sub></em>, then <em>C<sub>i</sub>(a) &lt; C<sub>j</sub>(b)</em></li>\n</ol>\n<p>You&#8217;ll notice these two rules are essentially saying that if <em>a → b</em> (a happened before b), then <em>C(a) &lt; C(b)</em> (its timestamp is lower than b&#8217;s). This is called the Clock Condition.</p>\n<p>It doesn&#8217;t take much to create a system of clocks that satisfies these rules. And that&#8217;s just what Lamport&#8217;s timestamp algorithm is, simple.</p>\n<ol>\n<li>A process <em>P<sub>i</sub></em> advances its clock <em>C<sub>i</sub></em> between successive events</li>\n<li>Every message must contain a timestamp <em>T<sub>m</sub></em> of when it was sent and when a process receives the message, it advances its clock to be greater than <em>T<sub>m</sub></em></li>\n</ol>\n<p>And that&#8217;s it.</p>\n<p>A system of clocks that ensures you can always tell the order of two events in the system. When two events can&#8217;t influence each other through messages they are considered concurrent despite their ordering in <a class=\"zem_slink\" title=\"Time\" href=\"http://en.wikipedia.org/wiki/Time\" target=\"_blank\" rel=\"wikipedia\">physical time</a>.</p>\n<p>We can now use these timestamps to order all events in the system using an arbitrary ordering when timestamps are ambiguous. It&#8217;s important to note that while the <a class=\"zem_slink\" title=\"Partially ordered set\" href=\"http://en.wikipedia.org/wiki/Partially_ordered_set\" target=\"_blank\" rel=\"wikipedia\">partial ordering</a> from before is unique, the <a class=\"zem_slink\" title=\"Total order\" href=\"http://en.wikipedia.org/wiki/Total_order\" target=\"_blank\" rel=\"wikipedia\">total ordering</a> depends on clock choice and the arbitrariness of ordering events where no <a class=\"zem_slink\" title=\"Causality\" href=\"http://en.wikipedia.org/wiki/Causality\" target=\"_blank\" rel=\"wikipedia\">causal link</a> exists.</p>\n<p>Lamport then goes on to describe how to use clocks to design a system that can organise itself without relying on external data to order events. But this part isn&#8217;t so interesting, and you can figure out your own example well enough.</p>\n<p>The important part is that a distributed algorithm can execute the events in its state machine in the correct order, because each process is meticulous about updating the timestamps that define event and message ordering.</p>\n<div style=\"width: 546px\" class=\"wp-caption alignnone\"><img title=\"A more organised diagram\" alt=\"A more organised diagram\" src=\"https://draftin.com:443/images/4773?token=QtKLi5wT6ttb4Aeuiky5v_4ulKq9Y3gBi4WvTf5G0cyc0LBvui71Nikj9s7qFiQRZ_wdxUpfqGtcCf-dXztJabc\" width=\"536\" height=\"522\" /><p class=\"wp-caption-text\">A more organised diagram</p></div>\n<p>&nbsp;</p>\n<h2 id=\"anomalous-behaviour\">Anomalous behaviour</h2>\n<p>Despite our best efforts, the system can have anomalies where events are ordered differently than a user expects.</p>\n<p>Let&#8217;s say we have a global system of connected computers (not unlike the internet, but the best Lamport had at the time was <a class=\"zem_slink\" title=\"ARPANET\" href=\"http://en.wikipedia.org/wiki/ARPANET\" target=\"_blank\" rel=\"wikipedia\">ARPAnet</a>) and a asks computer <em>A</em> to fulfill request <em>R(A)</em>. Then they immediately call computer <em>B</em> with the request <em>R(B)</em>.</p>\n<p>As far as the user is concerned, A happened before B and should be fulfilled first as well. But because the events aren&#8217;t causally connected, the system has no way of knowing. It might give B a lower timestamp than A.</p>\n<p>One solution is to require the user to manually resolve anomalies by appending timestamps to requests. We don&#8217;t want that.</p>\n<p>A better solution is to introduce the Strong Clock Condition. The paper feels fuzzy here, because the only difference between the Strong Clock Condition and the Clock Condition is that the strong version&#8217;s → symbol is a bold version of the normal → symbol.</p>\n<p>But Lamport promises that due to how special relativity works, it is possible to use physical clocks that stay in sync regardless of time-wimey things.</p>\n<h2 id=\"adding-physical-clocks\">Adding physical clocks</h2>\n<p>Adding physical clocks to the mix looks simple. Just replace the logical timestamps from before with readings from a clock that measures physical time.</p>\n<p>The problem, however, is that you can never have a perfect clock and without synchronization clocks in separate processes are going to drift further and further apart until the system becomes useless.</p>\n<p>Physical clocks must satisfy two conditions:</p>\n<ol>\n<li>There exists a constant <em>k &lt;&lt; 1</em> such that for all i: <em>|dC<sub>i</sub>(t)/dt -1| &lt; k</em></li>\n<li>For all i, j: <em>|C<sub>i</sub>(t) &#8211; C<sub>j</sub>(t)| &lt; ε</em></li>\n</ol>\n<p>That is, the derivative of a clock&#8217;s period must always be smaller than a very small constant (the clock is precise) and the absolute difference between any two clocks must always be smaller than ε (the clocks are synchronised).</p>\n<p>Because no two clocks will ever run at the same rate on their own, we need an algorithm that synchronises a process&#8217; clock with other clocks in the system. We derive it from the logical clocks algorithm, which means that a process never needs to know the state of any clocks other than its own and message timestamps.</p>\n<p>As always in this paper, we follow two rules:</p>\n<ol>\n<li>For every <em>i</em>, if <em>P<sub>i</sub></em> does not receive a message at <em>t</em>, then <em>C<sub>i</sub></em> is differentiable at <em>t</em> and <em>dC<sub>i</sub>(t)/dt &gt; 0</em></li>\n<li>A message <em>m</em> sent from <em>P<sub>i</sub></em> at <em>t</em> contains a timestamp <em>T<sub>m</sub> = C<sub>i</sub>(t)</em>. When receiving said message at <em>t&#8217;</em>, <em>P<sub>j</sub></em> sets <em>C<sub>j</sub>(t&#8217;)</em> to the maximum <em>(C<sub>j</sub>(t&#8217; &#8211; 0), T<sub>m</sub> + μ<sub>m</sub>)</em></li>\n</ol>\n<p>Essentially the same as before, but with more symbols. Between every two events in a process, the clock&#8217;s readout is differentiable and bigger than 0 (time passes continuously). When a message is received, the process sets its clock to the maximum of its own clock and the timestamp in the message plus a known delay of receiving the message.</p>\n<p>This ensures that the whole system stays in sync at all times and because we are now using physical clocks that run regardless of what&#8217;s going on, we have removed the anomalous behaviour from before.</p>\n<p>Wonderful.</p>\n<h2 id=\"fin\">Fin</h2>\n<p>Lamport concludes that he has shown that &#8220;happening before&#8221; is merely a partial ordering in the system, but can be extended to a somewhat arbitrary total ordering. He also showed that a logical system and an external observer can disagree about the order of events, which he proposes to fix with physical clocks.</p>\n<p>He also gave a theorem about the lower bound for how long it can take for clocks to become synchronised, but the maths was completely impenetrable to me, so I can&#8217;t really get into the appendix part of the paper. Better luck next time.</p>\n<p>My favourite part of the paper was its simplicity and relative obviousness. Now that I&#8217;ve read it, the paper makes complete sense and everything is just &#8220;d&#8217;oh&#8221;, but coming up with these solutions from scratch required some serious insight.</p>\n<p>No wonder this is one of the most cited papers in computer science.</p>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" alt=\"Enhanced by Zemanta\" src=\"http://img.zemanta.com/zemified_e.png?x-id=797ec3ec-ebad-4c86-8c4f-0ed17595b04b\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"4a024125-f7ef-5da2-8e3c-0bd6eaf53115"}}