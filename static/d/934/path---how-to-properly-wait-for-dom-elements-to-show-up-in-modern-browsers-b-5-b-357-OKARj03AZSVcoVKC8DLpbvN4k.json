{"data":{"wordpressPost":{"title":"How to wait for DOM elements to show up in modern browsers","content":"<p>Remember how careful we all were of the DOM ready event a few years ago? Writing JavaScript code outside of a <code>$(document).ready()</code> callback was sacrilege. An offense of the highest order.</p>\n<p>Then about two years ago somebody went <em>&#8220;Whoa whoa, wait a minute. We don&#8217;t need all of that DOM ready nonsense. We can just put our JavaScript at the bottom&#8221;</em></p>\n<p>And everyone was like, <em>&#8220;Haha silly us, thinking that script tags belong in the header. They can go anywhere!&#8221;</em></p>\n<p>Nowadays, no JavaScript ever goes in a <code>$(document).ready()</code> callback. Our scripts&#8217; hair flows in the wind as they ride through the glen firing arrows into the sunset. Khem.</p>\n<p>Anyway, the point is. We&#8217;ve all but forgotten about the DOM ready event. By the time our scripts run, the whole DOM is already there and we don&#8217;t have to worry about accessing elements that don&#8217;t exist.</p>\n<p>That is, until we start rendering our elements with JavaScript.</p>\n<h2 id=\"building-dom-with-js-can-mess-things-up\">Building DOM with JS can mess things up</h2>\n<p>In an ideal world, you&#8217;d wholly rely on your fancy framework to build the DOM. Backbone, Angular, CanJS, React, anything really. They&#8217;re all smart enough to keep you from doing stupid things.</p>\n<p>But sometimes you&#8217;re still going to do something stupid. Like, you&#8217;ll have some init code that needs an element for some reason or another. In my case, I needed to set its width based on some stuff in local storage.</p>\n<p>However, for whatever reason deep inside your legacy code, your init function gets called before the element you need is rendered. This can happen because you&#8217;re doing ugly things with your framework, like, <code>setTimeout(foo, 100); // this solves a render loop conflict</code>. Or as often happens, the element depends on a different component, and your framework decides on the wrong order of rendering.</p>\n<p>Frameworks are fickle like that. They really really like to pretend everything renders at the same time, but in reality it renders in a loop.</p>\n<p>And then you&#8217;re tempted to write something like this:</p>\n<pre lang=\"javascript\">   function try () {\n     if (!$(\"#element\").size()) {\n       setTimeout(try, 500); // give everything some time to render\n     } \n   }</pre>\n<p>And it works. It really does. As long as you keep looking at it.</p>\n<p>But modern browsers are tricky. When the tab isn&#8217;t in focus, or your user&#8217;s computer is running slow, or whatever, that timeout won&#8217;t have enough time.</p>\n<p>You see, browsers these days are trying desperately to conserve batteries and generally be nice to computers. When a tab isn&#8217;t in focus, the JavaScript slows down. Timeouts start acting funny, and you should forget all about any rendering happening.</p>\n<p>You&#8217;ll notice this easiest when switching to your app&#8217;s tab. It shows the old content. Then flashes. Then re-renders.</p>\n<p>Really really really annoying for testing because you can no longer browse HackerNews while your app takes its 20 seconds to reload. But really useful for users.</p>\n<p>Please don&#8217;t ask why the app I&#8217;m working on takes 20 seconds to reload.</p>\n<p>But anyway, you&#8217;ve hit upon the problem of DOM elements not being there when your code needs them. No matter how long the delay in that setTimeout, the element still isn&#8217;t there.</p>\n<p>&#8220;A-ha! DOM ready! I need the DOM ready!&#8221;, you think.</p>\n<p>Nope. The DOM is long since ready by the your script runs. I&#8217;ve tried that.</p>\n<p>Turns out what you&#8217;re looking for is <code>requestAnimationFrame</code>. It&#8217;s normally used to make animation less jittery because it syncs your JavaScript&#8217;s rendering with the browser&#8217;s rendering. Normally about 60 hertz.</p>\n<p>But it&#8217;s also how the browser tells your code that it&#8217;s still waiting. That things haven&#8217;t been rendered because the user isn&#8217;t there and there&#8217;s nobody to look at your stuff.</p>\n<p>So instead of that setTimeout, you should do something like this:</p>\n<pre lang=\"javascript\">  function try() {\n    if (!$(\"#element\").size()) {\n      window.requestAnimationFrame(try);\n    }else {\n       $(\"#element\").do_some_stuff();\n     }\n  };</pre>\n<p>Yup, no timeouts. At first glance it looks like this code is going to poll the DOM every 60th of a second to see if the element is there yet.</p>\n<p>But in practice it only ever retries once. Because no matter what, by the next render frame, whether it comes in a 60th of a second, or a minute, the element will have been rendered.</p>\n<p>And that&#8217;s how you properly wait for DOM elements to show up in modern browsers. I nearly tore my hair out before I figured it out.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"e836e9ad-21d4-5e4f-aaff-fbc8e4640e2c"}}