{"data":{"wordpressPost":{"title":"JS object optimization bug in Chrome 52","content":"<blockquote class=\"twitter-tweet\" data-conversation=\"none\" data-lang=\"en\">\n<p lang=\"en\" dir=\"ltr\">Dear diary, all I did today was fix 1 bug. I don&#39;t know why it happens, but I know how to make it not happen.<a href=\"https://twitter.com/hashtag/engineering?src=hash\">#engineering</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/761722056681545729\">August 6, 2016</a></p></blockquote>\n<p>That was on Friday. I still don&#8217;t know <em>why</em> the bug happens, but I can reproduce it. Evidence says it&#8217;s a Chrome 52 bug, not a general JavaScript bug. Neither Safari nor Firefox make it happen.</p>\n<p>Sometimes when you call <code>.fetch()</code> on a Backbone model, callbacks don&#8217;t fire. There&#8217;s no JavaScript error, the REST call works, the result is vanished by the browser. Joy of joys.</p>\n<img src=\"http://swizec.com/blog/wp-content/uploads/2016/08/chrome-eats-objects.gif\" alt=\"2 fetches, 1 callback\" class=\"alignnone size-full wp-image-6909\" />\n<p>You need:</p>\n<ul>\n<li>Webpack</li>\n<li>Babel 6</li>\n<li>Backbone (maybe Backbone is doing it wrong?)</li>\n<li>A server that can serve JSON files</li>\n<li>14 lines of code</li>\n</ul>\n<p>I used <code>create-react-app</code> to set up a basic environment, ejected with <code>npm run eject</code> and added some config to Webpack to allow jQuery. Backbone depends on it. This part is not <em>that</em> relevant.</p>\n<p>To show the bug itself, we need a Backbone model:</p>\n<pre lang=\"javascript\">\r\n// A basic Backbone model\r\nclass BugModel extends Backbone.Model {\r\n    constructor() {\r\n        super();\r\n\r\n        this.url = \"bla.json\";\r\n    }\r\n}\r\n</pre>\n<p>Now I know what you&#8217;re thinking, that&#8217;s an ES6 object and Backbone was built before ES6. Official docs never mention the new <code>class</code> syntax. The traditional Backbone approach works too:</p>\n<pre lang=\"javascript\">\r\nvar BugModel = Backbone.Model.extend({\r\n    url: \"bla.json\"\r\n});\r\n</pre>\n<p>The same bug happens. I tried.</p>\n<p>To cause the bug, we have to call <code>.fetch()</code> on two instances of <code>BugModel</code> that share the same <code>id</code>. The code looks like this:</p>\n<pre lang=\"javascript\">\r\nlet bug = new BugModel();\r\nbug.fetch({\r\n    success: () => {\r\n        console.log('fetch 1'); // this happens\r\n        doWeirdness(bug);\r\n    }\r\n});\r\n\r\nfunction doWeirdness(bug) {\r\n    let newBug = new BugModel({id: bug.id});\r\n\r\n    console.log('about to re-fetch');\r\n\r\n    newBug.fetch({\r\n        success: () => console.log('fetch 2', newBug), // don't get here\r\n        error: () => console.log('error')\r\n    });\r\n}\r\n</pre>\n<p>We create an instance of <code>BugModel</code> in a variable called <code>bug</code>, then call <code>.fetch()</code>. This makes an API call to <code>/bla.json</code>, which returns a JSON file that looks like this: <code>{&quot;id&quot;: 1, &quot;hai&quot;: &quot;hello&quot;}</code>. </p>\n<p>Backbone automagically parses this JSON string and sets an <code>id</code> and <code>hai</code> attribute. This part works like a charm.</p>\n<p>Then we call <code>doWeirdness</code> and pass our <code>bug</code> object as an attribute. Inside <code>doWeirdness</code>, we make a new instance of <code>BugModel</code> called <code>newBug</code> and give it the same <code>id</code> as <code>bug</code> had. This is a crucial step.</p>\n<p>When we call <code>fetch</code> on this new instance, the API call happens, but the callbacks do not. <code>'fetch 2'</code> never prints.</p>\n<p>This whole sequence of events might sound redundant, but it made sense in my real codebase. Even if re-fetching objects doesn&#8217;t make sense, it <em>should</em> work. It works in both Safari and Firefox.</p>\n<img src=\"http://swizec.com/blog/wp-content/uploads/2016/08/safari-does-not.gif\" alt=\"Works in Safari\" class=\"alignnone size-full wp-image-6910\" />\n<img src=\"http://swizec.com/blog/wp-content/uploads/2016/08/firefox-works-too.gif\" alt=\"Works in Firefox\" class=\"alignnone size-full wp-image-6911\" />\n<h2 id=\"cluesaboutwhy\">Clues about why</h2>\n<p>This smells like a bug in memory optimization. Chrome thinks <code>bug</code> and <code>newBug</code> are the same object, even though they are not.</p>\n<p>If you call <code>fetch()</code> twice on the same instance of <code>BugModel</code>, the same bug happens. (clue, part 1)</p>\n<p>If both instances have a different <code>id</code>, both <code>fetch</code> calls fire callbacks. (clue, part 2)</p>\n<p>Curiously, if you add a third <code>fetch()</code> call, that works.</p>\n<pre lang=\"javascript\">\r\n    newBug.fetch({\r\n        success: () => console.log('fetch 2', newBug), // don't get here\r\n        error: () => console.log('error')\r\n    });\r\n\r\n    newBug.fetch({\r\n        success: () => console.log('fetch 3') // prints\r\n    });\r\n</pre>\n<p>The bug didn&#8217;t happen in Chrome 51.</p>\n<p>I am confused. ?</p>\n<p>PS: <a href=\"http://swizec.com/blog/i-broke-ajax-in-chrome-52-%f0%9f%98%b1/swizec/6914\">there is a followup</a></p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"5b5a0b01-9c2b-5bbc-8afc-f6a42dfefc57"}}