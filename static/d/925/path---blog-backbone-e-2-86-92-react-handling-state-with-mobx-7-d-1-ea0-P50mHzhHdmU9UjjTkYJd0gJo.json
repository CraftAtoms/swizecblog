{"data":{"wordpressPost":{"title":"Backbone → React: Handling state with MobX","content":"<p>I did it! ?? I figured out a way to reliably interop between modern unidirectional data flow React components and old Backbone views. It ain&#8217;t pretty, but it works.</p>\n<p><iframe src=\"https://swizec.github.io/react-backbone-proof-of-concept/\" width=\"600\" height=\"600\"></iframe></p>\n<p>There are three components in that page:</p>\n<ul>\n<li>a <code>CurrentCount</code> component that shows current counter state; it’s pure React</li>\n<li>a <code>ButtonWrapper</code> component that shows counter state and does <code>+1</code> on click; it’s a wrapped Backbone view</li>\n<li>a <code>ReactButton</code> component that does <code>+10</code> on click; it’s <em>also</em> pure React</li>\n</ul>\n<p>I know this is a trivial example, but it shows a powerful concept. That <code>+1</code> button is still the same <a href=\"https://swizec.com/blog/backbone-react-step-1/swizec/7042\">Backbone view from Tuesday</a>. It stores state in a local Backbone Model, it uses a Handlebars template, and it remains the same idiomatic Backbone View it&#8217;s always been. Yet it interops with the React app, blissfully unaware that something fucky&#8217;s going on.</p>\n<figure>\n<img src=\"http://i.imgur.com/ZlUUWAf.gif\" alt=\"The Backbone view\" /><figcaption>The Backbone view</figcaption></figure>\n<p>All three components share the same MobX data store, which has a single observable value called <code>N</code>. It looks like this: </p>\n<pre lang=\"javascript\">\r\nclass CounterStore {\r\n\t@observable N = 0\r\n}\r\n</pre>\n<p>In MobX, stores are classes with observable properties. They often have methods and computed values as well, but this example is too simple. </p>\n<p><code>@observable</code> is a decorator that compiles into something like <code>makeObservable(this.N, 0)</code>, which in turn uses ES6 to add magical getters and setters that fire up the MobX engine whenever you access – dereference – the observable value. Doing it yourself would look like this:</p>\n<pre lang=\"javascript\">\r\nclass CounterStore {\r\n\tN = 0\r\n\t\r\n\tset N (val) {\r\n\t\tthis.N = val;\r\n\t\t\r\n\t\t// notify all observers that N has changed\r\n\t}\r\n\t\r\n\tget N () {\r\n\t\t// add call site to list of observers\r\n\t\t\r\n\t\treturn N;\r\n\t}\r\n}\r\n</pre>\n<p>MobX saves you from writing that logic yourself, and it adds a bunch of smartness to make it fast and efficient. I don&#8217;t really know how the engine works, but after reading the docs and some of Michel Weststrate&#8217;s Medium posts, I&#8217;m convinced it&#8217;s amaze.</p>\n<blockquote class=\"twitter-tweet\" data-lang=\"en\">\n<p lang=\"en\" dir=\"ltr\">Benchmarked Immutables against Observables in TodoMVC. More details at <a href=\"https://twitter.com/ReactAmsterdam\">@ReactAmsterdam</a> conf! <a href=\"https://twitter.com/hashtag/reactjs?src=hash\">#reactjs</a> <a href=\"https://twitter.com/hashtag/redux?src=hash\">#redux</a> <a href=\"https://twitter.com/hashtag/mobxjs?src=hash\">#mobxjs</a> <a href=\"https://t.co/tL536DWR6f\">pic.twitter.com/tL536DWR6f</a></p>\n<p>&mdash; Michel Weststrate (@mweststrate) <a href=\"https://twitter.com/mweststrate/status/718444275239882753\">April 8, 2016</a></p></blockquote>\n<p><script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>So that&#8217;s the store &#8211; no boilerplate involved. The two pure React components don&#8217;t involve much boilerplate either.</p>\n<pre lang=\"javascript\">\r\n@inject('counterStore')\r\nclass ReactButton extends Component {\r\n    buttonClicked() {\r\n        this.props.counterStore.N += 10;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <p>React Button:</p>\r\n                <button onClick={action('inc-counter', this.buttonClicked.bind(this))}>Jump click count +10</button>\r\n            </div>\r\n        );\r\n    }\r\n};\r\n\r\n@inject('counterStore') @observer\r\nclass CurrentCount extends Component {\r\n    render() {\r\n        const { N } = this.props.counterStore;\r\n        return (<p>Current count in counterStore: {N}</p>)\r\n    }\r\n}\r\n</pre>\n<p>The <code>@inject</code> decorator takes props from a React context and adds them to a component. I don&#8217;t know how MobX-specific this is, but it reduces our boilerplate. Instead of giving each component a <code>store={this.props.store}</code> type of prop, we can wrap the whole thing in a <code>&lt;Provider&gt;</code> and give everyone access.</p>\n<p>At the end of the day, you <em>always</em> realize that all your components need access to your application state. Global singletons for things everyone needs make life easier. Trust me.</p>\n<p>The <code>@observer</code> decorator comes from MobX&#8217;s React bindings. It automagically makes the <code>render()</code> method listen to store changes, but only those changes that it uses.</p>\n<p><strong>This is key</strong>. It&#8217;s what makes MobX fast. It&#8217;s also what leads to confusion when you&#8217;re doing things that are not idiomatic React, like inserting Backbone views into React components.</p>\n<blockquote class=\"twitter-tweet\" data-lang=\"en\">\n<p lang=\"en\" dir=\"ltr\">This is weird. If I add console.log to the render() method, MobX works as expected. Take it out, and observer isn&#39;t updating.<a href=\"https://twitter.com/mweststrate\">@mweststrate</a>?</p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/778666202457440256\">September 21, 2016</a></p></blockquote>\n<p><script async src=\"//platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>Thanks to Michel Weststrate for helping me out. His tip about using <code>autorun</code> saved the day ??</p>\n<p>And with that out of the way, I had a Backbone view wrapped in a React component, including full data interop. Change local Backbone state, and the global data store finds out, changes the data store, and the Backbone view updates.</p>\n<p>It looks like this:</p>\n<pre lang=\"javascript\">\r\n@inject('counterStore') @observer\r\nclass ButtonWrapper extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this._init();\r\n\r\n        autorun(this._render.bind(this));\r\n    }\r\n\r\n    _init() {\r\n        this.button = new BackboneButton({\r\n            N: this.props.counterStore.N\r\n        });\r\n        this.button.model.on('change:N', action('inc-counter', (_, N) => {\r\n            this.props.counterStore.N = N;\r\n        }));\r\n    }\r\n\r\n    componentDidUpdate() { this._render(); }\r\n    componentDidMount() { this._render(); }\r\n\r\n    _render() {\r\n        this._cleanup();\r\n        this._init();\r\n        this.button.setElement(this.refs.anchor).render();\r\n    }\r\n\r\n    componentWillUnmount() { this._cleanup(); }\r\n\r\n    _cleanup() {\r\n        this.button.undelegateEvents();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <p>Backbone Button:</p>\r\n                <div className=\"button-anchor\" ref=\"anchor\" />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n</pre>\n<p>Like I said, it ain&#8217;t pretty ?</p>\n<p>It works like this:</p>\n<ul>\n<li>React renders an anchor <code>div</code></li>\n<li>on component mount or update, it runs Backbone view rendering in <code>_render</code></li>\n<li>on component unmount, it cleans up Backbone&#8217;s DOM event listeners</li>\n<li>inside <code>_render</code> it:\n<ul>\n<li>cleans up Backbone DOM event listeners</li>\n<li>instantiates a new Backbone view with <code>_init</code></li>\n<li>tells the view to render inside that anchor <code>&lt;div&gt;</code></li>\n</ul>\n</li>\n<li>when initializing the view in <code>_init</code> it:\n<ul>\n<li>creates a new <code>BackboneButton</code> instance and gives it the <em>value</em> of <code>N</code> from our store</li>\n<li>listens for changes to <code>N</code> on the view&#8217;s internal state and communicates them upstream with a MobX action</li>\n</ul>\n</li>\n</ul>\n<p>This approach is a leaky abstraction. The <code>_init</code> method has to know intimate details about the Backbone view you&#8217;re wrapping. There’s no way to get around that because MobX needs those getters and setters to observe state changes.</p>\n<p>As soon as you pass a value, MobX loses track. I tried passing the whole store into a Backbone view and using it directly as a model, but that didn&#8217;t work. Backbone Model&#8217;s <code>set()</code> and <code>get()</code> methods circumvent native getters and setters, which means MobX can&#8217;t track changes or uses.</p>\n<p>Another issue is that because <a href=\"https://swizec.com/blog/backbone-%E2%86%92-react-its-a-people-problem-after-all-%F0%9F%98%91/swizec/7049\">our Backbone views aren&#8217;t pure</a>, the UI could sometimes look wrong to the user. It won&#8217;t be stale, but it won&#8217;t show all side-effects from user actions either.</p>\n<p>But we can deal with that later. The important part is that we have a way forward! A way to go from Backbone to React without resorting to a full complete rewrite of everything from scratch. \\o/</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"f4122d00-c471-550c-bc23-970f5611984d"}}