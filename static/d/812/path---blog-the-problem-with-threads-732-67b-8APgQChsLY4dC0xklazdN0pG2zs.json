{"data":{"wordpressPost":{"title":"The problem with threads","content":"<div style=\"width: 250px\" class=\"wp-caption alignright\"><a href=\"http://www.flickr.com/photos/45448242@N02/4800996644\"><img class=\"zemanta-img-inserted zemanta-img-configured\" title=\"Regular Expression NFA\" src=\"http://swizec.com/blog/wp-content/uploads/2011/12/4800996644_c46de09b40_m1.jpg\" alt=\"Regular Expression NFA\" width=\"240\" height=\"128\" /></a><p class=\"wp-caption-text\">Image by jl_2 via Flickr</p></div>\n<p>This morning there was a link going around listing the <a href=\"https://plus.google.com/111191895515210271225/posts/HN2ZTbf7Cgg\" target=\"_blank\">15 papers you should read to understand node.js&#8217;s background</a>. A large portion of the list is devoted to the comparison of thread- and event- based models of execution. Since I hear a lot about event loops being better than threads, I read <em><a href=\"http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf\" target=\"_blank\">The problem with threads</a></em> written in 2006 by one Edward A. Lee, a professor at Berkeley.</p>\n<blockquote><p>If the next generation of programmers makes more intensive use of <a class=\"zem_slink\" title=\"Thread (computer science)\" href=\"http://en.wikipedia.org/wiki/Thread_%28computer_science%29\" rel=\"wikipedia\">multithreading</a>, then the next generation of computers will become nearly unusable.</p></blockquote>\n<p>And this bleak future is almost inevitable when you think about it. The rule of <a class=\"zem_slink\" title=\"Moore's law\" href=\"http://en.wikipedia.org/wiki/Moore%27s_law\" rel=\"wikipedia\">Moore&#8217;s law</a> has been changing from faster chips, to more and more cores. And yet the only software making good use of multiple cores are what Lee calls &#8220;<a class=\"zem_slink\" title=\"Embarrassingly parallel\" href=\"http://en.wikipedia.org/wiki/Embarrassingly_parallel\" rel=\"wikipedia\">embarrassingly parallel</a>&#8221; applications &#8211; those that simply split themselves into independent processes.</p>\n<p>Problems with threads stem from sharing memory space. Without proper care this can lead to a situation where one thread changes a piece of data, while the other is reading it. Now you have two threads that both have a different understanding of what the value of a certain variable is.</p>\n<p>While in theory solvable with semaphores, locks and so on, without very proper care this can then lead to deadlocks &#8211; more importantly, taking care of  interleaving threads is <em>very hard. </em>You are essentially facing a <a class=\"zem_slink\" title=\"Nondeterministic finite-state machine\" href=\"http://en.wikipedia.org/wiki/Nondeterministic_finite-state_machine\" rel=\"wikipedia\">nondeterministic machine</a> and trying to understand it through a poor abstraction that doesn&#8217;t  make use of your natural ability to deal with concurrency.</p>\n<p>Lee also makes the case that this isn&#8217;t merely a problem of syntax or tools, but that threads are a fundamentally flawed model of computation. I won&#8217;t burden you with his whole proof/argumentation (page 3 to 5). The gist is that</p>\n<blockquote><p>/../ given a sequental program and an initial state, you have a defined sequence of events. Any two programs can be compared &#8211; they are equivalent if they halt for the same initial states and the final state is the same. When threads are introduced these essential properties are lost /../ if two threads can provide the next action, we can no longer compare two programs, we might be able to compare all interleavings, but on a <a class=\"zem_slink\" title=\"Thread (computer science)\" href=\"http://en.wikipedia.org/wiki/Thread_%28computer_science%29\" rel=\"wikipedia\">multithreaded</a> envrionment even that is lost since we&#8217;d have to know about  all the other programs as well.</p></blockquote>\n<p>Essentially the problem is this &#8211; the core abstraction of computation is a deterministic assembly of deterministic components, but threads are inherently nondeterministic. The car analogy Lee provides is trying to compose an <a class=\"zem_slink\" title=\"Internal combustion engine\" href=\"http://en.wikipedia.org/wiki/Internal_combustion_engine\" rel=\"wikipedia\">internal combustion engine</a> out of a pot of iron,  hydrocarbon and oxygen molecules randomly moving according to thermal forces.</p>\n<p>This is so bad in practice even using very strict and rigid engineering principles, doesn&#8217;t help. In early 2000 Lee started the <a class=\"zem_slink\" title=\"Ptolemy Project (computing)\" href=\"http://ptolemy.eecs.berkeley.edu\" rel=\"homepage\">Ptolemy Project</a>, a project designing concurrent embedded systems. But this is also an experiment in battling threads with rigorous engineering discipline &#8211; they developed a code maturity rating system, design reviews, <a class=\"zem_slink\" title=\"Code review\" href=\"http://en.wikipedia.org/wiki/Code_review\" rel=\"wikipedia\">code reviews</a>, nightly builds, the works. Reviewers included concurrency experts and there are regression tests with 100% code coverage.</p>\n<p>When the system started being used in 2000 no problems were observed until a deadlock on April 26th, 2004. Just the fact they know the exact date this happened tells a lot about how rigorously engineering principles are applied. Still, a very serious problem took <em>four years</em> to be discovered.</p>\n<p>Many other approaches exist that try to combat this problem, but they either wallow in obscurity or aren&#8217;t very effective; perhaps the most effective is the use of higher-order principles like <a class=\"zem_slink\" title=\"MapReduce\" href=\"http://en.wikipedia.org/wiki/MapReduce\" rel=\"wikipedia\">MapReduce</a>, which aim to  break the problem into tiny fractions that can be computed separately and then combining the results.</p>\n<p>An interesting solution Lee proposes is using the so-called Rendezvous pattern, which as far as I can tell is a generalization of MapReduce, with the use of a nondeterministic merge, so that each part of the program is executing deterministically and <a class=\"zem_slink\" title=\"Nondeterministic algorithm\" href=\"http://en.wikipedia.org/wiki/Nondeterministic_algorithm\" rel=\"wikipedia\">nondeterminism</a> is only used in a single spot on the network &#8211; where threads <em>actually</em> have to interact. Lee proposes using this with some sort of coordination language, so that programmers aren&#8217;t burdened with learning new ways of implementing their solutions (a historically <em>very</em> slow process), but can assemble different solutions almost like <a class=\"zem_slink\" title=\"Lego\" href=\"http://www.lego.com/\" rel=\"homepage\">Lego</a>&#8216;s.</p>\n<p>Lee concludes that concurrency in software is difficult, but much of it is our own fault due to using poor abstractions. To deal with concurrency in a robust and predictable manner, we should stop using threads and focus on using nondeterminism only where it is warranted.</p>\n<h6 class=\"zemanta-related-title\" style=\"font-size: 1em;\">Related articles</h6>\n<ul class=\"zemanta-article-ul\">\n<li class=\"zemanta-article-ul-li\"><a href=\"http://go.theregister.com/feed/www.theregister.co.uk/2011/11/03/peregrine_multithreading/\">Better multithreading offered by Columbia U researchers</a> (go.theregister.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://powersthatbeat.wordpress.com/2011/11/12/major-breakthrough-improves-software-reliability-and-security-the-fu-foundation-school-of-engineering-applied-science-columbia-university/\">Major Breakthrough Improves Software Reliability and Security | The Fu Foundation School of Engineering &amp; Applied Science &#8211; Columbia University</a> (powersthatbeat.wordpress.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://stackoverflow.com/questions/8458576/worker-threads-and-controller-thread-synchronization\">Worker threads and a controller thread</a> (stackoverflow.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://stackoverflow.com/questions/8007465/what-does-really-happen-if-i-access-a-singleton-in-a-multithreaded-program\">What does really happen if I access a singleton in a multithreaded Program</a> (stackoverflow.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://stackoverflow.com/questions/8363864/multithreading-performance\">Multithreading performance</a> (stackoverflow.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://www.eurekalert.org/pub_releases/2011-11/cu-mbi110211.php\">Major breakthrough improves software reliability and security</a> (eurekalert.org)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://stackoverflow.com/questions/4430388/access-violation-in-a-multithreaded-application-c\">Access violation in a multithreaded application, C++</a> (stackoverflow.com)</li>\n</ul>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" src=\"http://img.zemanta.com/zemified_e.png?x-id=062c52b7-3f63-459d-bdc0-9e6a09bf5955\" alt=\"Enhanced by Zemanta\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"b51dc274-b97a-5f6c-8211-246b2b6a1f66"}}