{"data":{"wordpressPost":{"title":"JavaScript promises are just like monads and I can explain both in less than 2 minutes","content":"<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/KVYm0qC4b1Y?feature=oembed\" frameborder=\"0\" allowfullscreen></iframe></p>\n<p>There&#8217;s a joke in functional programming that once you understand monads, it becomes impossible to explain them to others. The <a href=\"https://wiki.haskell.org/Monad_tutorials_timeline\">amount of monad tutorials on the internet</a> is growing almost exponentially üòÅ</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Monad_(functional_programming)\">Monads</a> are a funky concept that&#8217;s nearly impossible to understand in all of its nuance. Maybe I&#8217;m just not smart enough. That&#8217;s why I&#8217;m not going to explain any of that.</p>\n<p>Screw the mathematical definition. Look at this shit üëá</p>\n<img src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/9adf49871aefe9b313db56ab037c1a3dc2840c73\" alt=\"continuation monad\" />\n<p>o.O wat O.o</p>\n<p>Here&#8217;s a handwavy explanation instead: Monads are like a bubble. They wrap your dirty values and protect the rest of your code from weird effects.</p>\n<p>I used the continuation monad as an example because it is similar to JavaScript Promises. A way to talk about the future. <sup><a id=\"ffn1\" class=\"footnote\" href=\"#fn1\">1</a></sup></p>\n<p>Let&#8217;s pretend you&#8217;re a <a href=\"http://hitchhikers.wikia.com/wiki/Mice\">mouse looking for the ultimate question to life, the universe, and everything</a>. You build a super computer that will calculate the answer, and you call it Earth.</p>\n<p>You know Earth will take around 4.54 billion years to calculate the question. But you&#8217;re writing the code right now. You can&#8217;t wait 4.54 billion years to finish your project.</p>\n<p>What do you do? You put Earth in a time bubble.</p>\n<p>Like this:</p>\n<pre><code>function getQuestion() {\nreturn Earth()\n.then(ArthurDent =&gt; ArthurDent.subconscious())\n.then(subconscious =&gt; Scrabble.output(subconscious))\n}\n</code></pre>\n<p>In <a href=\"http://hitchhikers.wikia.com/wiki/Ultimate_Question\">The HitchHiker&#8217;s Guide to The Galaxy</a>, Arthur Dent was the final result of a 4.54 billion year calculation. He mindlessly picked letters out of a pile of Scrabble‚Ñ¢ tiles, and the result produced the ultimate question.</p>\n<p>That means our <code>getQuestion</code> function first constructs an Earth, then gets <code>ArthurDent</code>, accesses his subconsciousness, and uses Scrabble‚Ñ¢ to print the result. ü§ô</p>\n<h2>Here&#8217;s what that looks like in practice:</h2>\n<p>Let&#8217;s compare promises to callbacks. You&#8217;re likely to have met with callbacks before, JavaScript is full of them.</p>\n<pre lang=\"javascript\">\nlet theFuture = function (callback) {\n    setTimeout(callback, 5000);\n}\n\ntheFuture(() => {\n    console.log(\"It is now 5 seconds later\");\n});\n</pre>\n<p>We turn <code>theFuture</code> into a Promise and trigger its <code>resolve</code> method after 5 seconds. The <code>Promise</code> wrapped everything inside its body into a protective time bubble.</p>\n<p>With a promise, we can pass <code>theFuture</code> around and do all sorts of stuff. But if we want to access the future, we have to use <code>.then</code> and give it a function.</p>\n<p>When I first saw this, I thought <em>&#8220;So what&#8217;s the big deal? This is the same as callbacks.‚Äù</em></p>\n<p>So here&#8217;s the big deal: Once you&#8217;re in a promise, you&#8217;re always in a promise. Because promises are like monads üòÅ</p>\n<p>Check out this simplified real world example from my day job.</p>\n<pre lang=\"javascript\">\nmakePurchase(){\n    this.paymentView\n          .fetchPaymentInfo()\n          .then(paymentInfo  => this.finishPurchase(paymentInfo))\n      .then(token => this.showSuccessModal())\n      .catch(error => console.error(error));\n}\n\nfetchPaymentInfo(){\n    if (this.paypal) {\n        return this.getPaypalPaymentInfo(); // returns promise\n    }else{\n        return this.getCCPaymentInfo(); // returns promise\n    }\n}\n\ngetPaypalPaymentInfo(){\n    return this.brainTreeClient\n                         .tokenizePaypal()\n                         .then(response => {\n                 return response.paymentInfo; \n                         });\n}\n\nfinishPurchase( paymentInfo ) {\n    return fetch('/purchase/path')\n                        .then(response => response.json())\n                        .then(json => {\n                            if (json.token) {\n                                return json.token;\n                            }else{\n                                throw new Error(\"Purchase failed\")\n                            }\n                        });\n}\n</pre>\n<p>Don&#8217;t worry about the behind-the-scenes details of that code. Here&#8217;s what you should focus on:</p>\n<ol>\n<li>The main <code>makePurchase</code> function does everything through Promise access. The <code>.then</code> and <code>.catch</code> methods are like peeking into the Promise time bubble. You&#8217;re saying: Once this time bubble resolves, I want to do so and so with the result.</li>\n<li>The <code>fetchPaymentInfo</code> is the first method in our chain that creates a Promise. From then onwards, we can access returned values only through <code>.then</code> and <code>.catch</code>. It uses <code>getPaypalPaymentInfo</code> and <code>getCCPaymentInfo</code> to talk to Braintree, which is an operation that takes some time.</li>\n<li><code>braintreeClient.tokenizePaypal()</code> returns a promise. There&#8217;s no need to wrap this in another Promise inside <code>fetchPaymentMethod</code>. You can return it like any normal value.</li>\n<li><code>getPaypalPaymentInfo</code> uses <code>.then</code> to look into the Braintree response. Since you&#8217;re in a Promise, you can <code>return</code> flat values without worry. They&#8217;re already wrapped in a Promise.</li>\n<li>As a result, we can chain multiple <code>.then</code> calls in <code>makePurchase</code>. Some methods return a regular value, some return a Promise. JavaScript don&#8217;t care, it&#8217;s all the same <em>because everything returned from a Promise is a Promise</em>.</li>\n</ol>\n<p>And that&#8217;s why Promises are just like monads.</p>\n<p>Oh, and error handling. Don&#8217;t worry about that either. As long as there&#8217;s a <code>.catch</code> call somewhere in the chain, you&#8217;re good. Errors bubble up through the chain of Promise look-into-s until they encounter a <code>.catch</code>.</p>\n<p>Hope that helps, it took me months of practice to grok ü§ì</p>\n<ol id=\"footnotes\">\n<li id=\"fn1\">Technically continuations are more similar to callbacks, but bear with me. <a href=\"#ffn1\">‚Ü©</a></li>\n</ol>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"ed2e5b48-de46-51a6-9775-e97761a91dfe"}}