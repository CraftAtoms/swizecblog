{"data":{"wordpressPost":{"title":"You don&#8217;t want to build your own list virtualization","content":"<p>Chatroom is slow? I know, I&#8217;ll just use list virtualization!</p>\n<p>Well now you have two problems.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">So I&#39;ve been working on this scroll UX today and it&#39;s surprisingly hard to get this right. </p>\n<p>Did you know mouse wheel scroll deltaY can jump as much as 2000px in a single event? <a href=\"https://t.co/HnC3AOqNVe\">pic.twitter.com/HnC3AOqNVe</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/958840988495093760?ref_src=twsrc%5Etfw\">January 31, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>List virtualization is hard, dear reader. <em>So</em> hard. ‚ÄúPfft, I can build that in an hour,‚Äù I thought until I tried.</p>\n<p>It&#8217;s been 3 days. Last night, I dreamed scrollbars and mouse wheel events.</p>\n<h2>Hold up, what&#8217;s list virtualization?</h2>\n<p><a href=\"https://www.google.com/search?q=list+virtualization&amp;oq=list+virtualization&amp;aqs=chrome..69i57j0l5.2398j0j1&amp;sourceid=chrome&amp;ie=UTF-8\">List virtualization</a> is a performance improvement technique for large lists or tables. Whenever your UI becomes slow because you&#8217;re rendering too much stuff, you can use list virtualization to make it fast again.</p>\n<p>We&#8217;ve been hit with this problem recently at <a href=\"https://www.yup.com\">Yup</a>. When our sessions get long, like hundreds of messages between tutor and student, tutors start complaining about the UI feeling sluggish.</p>\n<p>They can&#8217;t type, they can&#8217;t talk, it&#8217;s like teaching through a paper bag. Terrible.</p>\n<p>We don&#8217;t know why it became such a big problem right now, but 600 milliseconds to add a message to a chatroom is just too much. Needs to be fixed.</p>\n<p>That&#8217;s where list virtualization comes in.</p>\n<p>Instead of keeping the whole hundreds-of-messages chatroom rendered, you render just 30 messages. Or 40, or 10. Whatever the number, you render a small subset of the messages.</p>\n<p>And that gives you a performance boost. Fewer DOM nodes to deal with, faster rendering times. Especially on slow computers.</p>\n<p>The problem may have become a problem because of the <a href=\"https://techcrunch.com/2018/01/03/a-major-kernel-vulnerability-is-going-to-slow-down-all-intel-processors-2/\">Spectre and Meltdown fixes that hit Intel processors with up to 30% slowdowns</a>. When you&#8217;re already using a slow $300 computer‚Ä¶ yeah.</p>\n<h2>How to virtualize a list, in theory</h2>\n<p>So, how do you virtualize a list?</p>\n<img src=\"https://swizec.com/blog/wp-content/uploads/2018/02/Image-uploaded-from-iOS-1-1-1024x768.jpg\" alt=\"\" class=\"alignnone size-large wp-image-8166\" />\n<p>Virtualizing a list is simple in theory. You maintain a window and move it around your list.</p>\n<p>A <code>windowSize</code> variable tells you how many nodes you&#8217;re rendering, and a <code>windowIndex</code> variable tells you where to start rendering. Then you <code>.splice</code> your data array and render away.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">Building something in Backbone that would&#39;ve been 5 seconds in React.</p>\n<p>List windowing &#8230;</p>\n<p>React:<br />this.elements.splice(start, end).map()<br />detect scroll, change start/end. Done.</p>\n<p>Backbone:<br />So if you go up you prepend elements and if you go down you append them and you &#8230; <a href=\"https://t.co/gE6XV140ld\">pic.twitter.com/gE6XV140ld</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/958497773749395456?ref_src=twsrc%5Etfw\">January 31, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>I was doing it in <a href=\"http://backbonejs.org/\">Backbone</a>, so it seemed super tricky. We had complex logic in place to append and remove and prepend messages to the list as necessary.</p>\n<p>Think things like</p>\n<ol>\n<li>Find previous message with <code>$(\"nth-child\")</code></li>\n<li>Manipulate with <code>$(ul).append</code></li>\n<li>Find the correct scroll position</li>\n</ol>\n<p>Messy.</p>\n<p>After a few hours of that approach, I gave up.</p>\n<blockquote><p>\nScrew DOM manipulation, it&#8217;s 2018 and the DOM is fast. Re-render it.\n</p></blockquote>\n<p>To my surprise, throwing away the list and re-rendering for every message insertion or scroll event works friggin‚Äô great. Like really seriously great. Even in Backbone where you get none of React&#8217;s diffing magic.</p>\n<p>I didn&#8217;t run proper benchmarks, but on my 2017 MBP at home, re-rendering a 30-element list happens in 10 to 15 milliseconds.</p>\n<ol>\n<li><code>$(\"ul\").html(\"\")</code></li>\n<li><code>elements.splice(windowIndex, windowSize)</code></li>\n<li>loop and append</li>\n</ol>\n<p>That re-renders in just 10 milliseconds on my 15&#8243; MBP, 30 milliseconds on my 13&#8243; MBP. Both running RoR and sidekiq and webpack and the rest in the background.</p>\n<p>13&#8243; is so much slower because it&#8217;s just dual core. I&#8217;ll run a proper benchmark for this soon because I&#8217;m curious.</p>\n<p>My point is that re-rendering is fast and easy. You can totally get away with re-rendering on every mousewheel event if your <code>windowSize</code> is small enough.</p>\n<p>I now had a virtualized list. Worked great.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">Is this a confusing scroll experience? <a href=\"https://t.co/wyHsu3C2IY\">pic.twitter.com/wyHsu3C2IY</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/958518929504088064?ref_src=twsrc%5Etfw\">January 31, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>Except the UX is confusing. You get to the edge of the scrollbar and it just keeps going and going. Wat?</p>\n<h2>Where things get tricky</h2>\n<p>This strange scrolling UX is where things go belly up and life gets hard. Users don&#8217;t expect to hit the edge of the scrollbar before the edge of the content, you see.</p>\n<p>So I tried a couple things and haven&#8217;t really figured this out. I think I&#8217;m on the right path, but I&#8217;m also starting to lose my mind.</p>\n<p>Watch this gif. Scrolling up works great, but then you start scrolling down and everything goes topsy turvy.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">So I&#39;ve been working on this scroll UX today and it&#39;s surprisingly hard to get this right. </p>\n<p>Did you know mouse wheel scroll deltaY can jump as much as 2000px in a single event? <a href=\"https://t.co/HnC3AOqNVe\">pic.twitter.com/HnC3AOqNVe</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/958840988495093760?ref_src=twsrc%5Etfw\">January 31, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>The version in this gif tries to compensate for a few things.</p>\n<ol>\n<li>Uses an offset from the edge to start adding messages before you hit the edge</li>\n<li>Adjusts this offset to your scrolling speed</li>\n<li>Adjusts <code>windowIndex</code> delta to your scrolling speed</li>\n</ol>\n<p>Adding messages is basically just moving the <code>windowIndex</code>. That part is easy.</p>\n<p>But the mousewheel is a tricky beast. On my mouse, the smallest <code>deltaY</code> is 4 pixels. That&#8217;s okay.</p>\n<p>The biggest <code>deltaY</code> I&#8217;ve seen is around 3000 pixels. In a single event call.</p>\n<img src=\"https://media2.giphy.com/media/xT0xeJpnrWC4XWblEk/giphy.gif\" />\n<p>So that&#8217;s what I&#8217;ve been dealing with. I wish I could just use <a href=\"https://github.com/bvaughn/react-virtualized\">react-virtualized</a>, but I can&#8217;t because <em>&#8220;We&#8217;ll have time to rewrite later&#8221;</em>. Can&#8217;t come soon enough üòÖ</p>\n<h2>Update: OMG I DID IT</h2>\n<p>It&#8217;s not as smooth as Slack, but it&#8217;s good enough for now.</p>\n<blockquote class=\"twitter-tweet\" data-conversation=\"none\" data-lang=\"en\">\n<p lang=\"en\" dir=\"ltr\">OMG I DID IT! <a href=\"https://t.co/s85429V067\">pic.twitter.com/s85429V067</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/959151765185691650?ref_src=twsrc%5Etfw\">February 1, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>Wasn&#8217;t that complicated after all. Just a bunch of maths with magic numbers.</p>\n<img src=\"https://swizec.com/blog/wp-content/uploads/2018/02/carbon-2-1024x1013.png\" alt=\"\" class=\"aligncenter size-large wp-image-8173\" srcset=\"https://swizec.com/blog/wp-content/uploads/2018/02/carbon-2-1024x1013.png 1024w, https://swizec.com/blog/wp-content/uploads/2018/02/carbon-2-300x297.png 300w, https://swizec.com/blog/wp-content/uploads/2018/02/carbon-2-768x759.png 768w, https://swizec.com/blog/wp-content/uploads/2018/02/carbon-2-125x125.png 125w, https://swizec.com/blog/wp-content/uploads/2018/02/carbon-2.png 1256w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" />\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"b5316771-4ae3-5fdc-ab07-62bc7123ebf9"}}