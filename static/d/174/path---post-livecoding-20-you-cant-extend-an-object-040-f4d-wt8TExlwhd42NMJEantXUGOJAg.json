{"data":{"wordpressPost":{"title":"Livecoding #20: You can&#8217;t extend an object","content":"<p><em>This is a Livecoding Recap – an almost-weekly post about interesting things discovered while livecoding ?. Always under 500 words and with pictures. You can follow my channel, <a href=\"https://livecoding.tv/swizec\">here</a>. New content almost <strong>every Sunday at 2pm PDT</strong>. There’s live chat, come say hai ?</em></p>\n<p><iframe src=\"https://www.livecoding.tv/swizec/videos/Nrq7j/embed\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"true\" scrolling=\"no\"></iframe></p>\n<p>Today we battled with a fearsome error, an error of odd implications and no clear solutions. <code>Uncaught TypeError: Super expression must either be null or function</code></p>\n<p>What does that even mean!? ?</p>\n<p>Well, it means that when you <code>import TransitionableComponent from 'react-transitionable-component'</code>, you get an object instead of a function. We confirmed the problem with some console.log calls. After importing <code>TransitionableComponent</code> is an object.</p>\n<img src=\"https://swizec.com/blog/wp-content/uploads/2016/08/Screen-Shot-2016-08-21-at-17.32.42.png\" alt=\"It&#039;s an object!\" class=\"aligncenter size-full wp-image-6949\" srcset=\"https://swizec.com/blog/wp-content/uploads/2016/08/Screen-Shot-2016-08-21-at-17.32.42.png 631w, https://swizec.com/blog/wp-content/uploads/2016/08/Screen-Shot-2016-08-21-at-17.32.42-300x132.png 300w\" sizes=\"(max-width: 631px) 100vw, 631px\" />\n<p>It looks just like a React component is supposed to. There&#8217;s a constructor method, a bunch of default object methods, and – I assume – all the <code>Component</code> methods as well. That&#8217;s great when you want to use a component in your <code>render()</code> function. Not so great when you want to use it as a parent class.</p>\n<p>When you do something like <code>class Arc extends TransitionableComponent</code>, it fails. You can extend a <code>null</code> or a <code>function</code>, but not an object.</p>\n<p>You can inherit from a class, but not from an instance of a class. I&#8217;m sure it&#8217;s like that in every language, but the reason it&#8217;s like that in JavaScript is that <code>class TransitionableComponent extends Component</code> transpiles into:</p>\n<pre lang=\"javascript\">\r\nvar TransitionableComponent = function (_Component) {\r\n        _inherits(TransitionableComponent, _Component);\r\n    \r\n        function TransitionableComponent(props) {\r\n            _classCallCheck(this, TransitionableComponent);\r\n    \r\n                    // I think this is super(props)\r\n            var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TransitionableComponent).call(this, props));\r\n    \r\n            // this is where your constructor body goes\r\n            return _this;\r\n        }\r\n    \r\n        _createClass(TransitionableComponent, [{\r\n           // this is where your class body goes\r\n        }])\r\n        \r\n        return TransitionableComponent;\r\n    }(_react.Component);\r\n</pre>\n<p>That <code>_inherits</code> call is the crucial piece. It does a bunch of <code>.prototype</code> magic to extend the definition of a given class with the definition of a child class. Instances don&#8217;t have prototypes, functions do.</p>\n<p>Functions have a <code>prototype</code> property because of legacy reasons, I&#8217;m sure. That&#8217;s how JavaScript has always understood the concept of classes – generator/constructor functions double as classes.</p>\n<p>At this point <code>TransitionableComponent</code> is a function &#8211; just like we&#8217;d expect. With some <code>console.log</code>-ing we confirmed that it remains a function right until the point we import it in our sample project.</p>\n<p>Hmmm ?</p>\n<p>I don&#8217;t know why it becomes an object. Our guessing and prodding didn&#8217;t reveal much. This is what importing transpiles to:</p>\n<pre lang=\"javascript\">\r\nvar _TransitionableComponent = __webpack_require__(16);\r\n\r\nvar _TransitionableComponent2 = _interopRequireDefault(_TransitionableComponent);\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n</pre>\n<p>This code might return an object, if you&#8217;re importing something that isn&#8217;t an ES6 Module. But we know that&#8217;s not our problem because <code>TransitionableComponent.default</code> is undefined.</p>\n<p>You&#8217;d think <code>__webpack_require__</code> was instantiating our component and returning an object instead of a function, but it works correctly when you import React&#8217;s default <code>Component</code>. Curiously, React&#8217;s compiled code looks like normal ES5 without even a hint of Webpack or Babel. Hmmm ?</p>\n<p>I am at a loss. I have no idea what&#8217;s going on or why. But until we figure this out, <code>react-transitionable-component</code> will not be a usable library and my chance at open source glory lays trampled in the wastelands of <a href=\"https://www.npmjs.com/package/react-transitionable-component\">npmjs.com</a>. ?</p>\n<p>Ideas?</p>\n<p><em></p>\n<p>PS: the edited and improved versions of these videos are becoming a video course. Readers of the engineer package of <a href=\"http://swizec.com/reactd3js/\">React+d3js ES6</a> get the video course for free when it’s ready.</p>\n<p></em></p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"81dc91bf-35e3-581f-a3b8-412b553dd86a"}}