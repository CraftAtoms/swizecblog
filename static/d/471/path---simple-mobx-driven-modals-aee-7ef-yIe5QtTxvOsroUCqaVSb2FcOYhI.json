{"data":{"wordpressPost":{"title":"Simple MobX-driven modals","content":"<img class=\"alignnone size-full wp-image-7165\" src=\"https://swizec.com/blog/wp-content/uploads/2016/10/modal-inception.gif\" width=\"662\" height=\"448\" />\n<p>Continuing from yesterday&#39;s article about <a href=\"link\">using MobX with create-react-app</a>, we&#39;re going to build a simple MobX-driven modal. Why? Because I just did it at The Day Job™, and I think it&#39;s neat.</p>\n<p>If you don&#39;t think it&#39;s neat, that&#39;s okay. It&#39;s neat anyway.</p>\n<p>Ingredients:</p>\n<ul>\n<li><a href=\"https://github.com/facebookincubator/create-react-app\">create-react-app</a></li>\n<li><a href=\"https://github.com/mobxjs/mobx\">MobX</a> and <a href=\"https://github.com/mobxjs/mobx-react\">MobX React</a></li>\n<li><a href=\"https://github.com/legitcode/modal\">simple-react-modal</a></li>\n</ul>\n<p>You can see the full code on GitHub <a href=\"https://github.com/Swizec/mobx-modal\">here</a>. There&#39;s a link to a compiled&amp;hosted version. I&#39;m still figuring out why the component inception from the gif doesn&#39;t work after compiling. <a href=\"mailto:swizec@swizec.com\">Let me know</a> if you have any ideas.</p>\n<p>We&#39;re going to build a modals system that lets you:</p>\n<ul>\n<li>easily open a modal from anywhere in the code</li>\n<li>specify general modal styling/behavior just once</li>\n<li>define modal contents at call point</li>\n<li>tie modals to URLs if needed</li>\n</ul>\n<p>All of this might sound easy to you, but it&#39;s harder than it looks. It <em>sounds</em> easy, and it&#39;s frustrating as hell every damn time you do it. I&#39;ve done it more times than I dare count.</p>\n<p>MobX with React has been the easiest and most flexiblest approach I&#39;ve ever used.</p>\n<p>You start with a store.</p>\n<pre lang=\"javascript\">\n// src/App.js for example purposes\nclass Store {\n    @observable modal = {\n        show: false,\n        body: null\n    }\n\n    @action showModal(body) {\n        this.modal.show = true;\n        this.modal.body = body;\n    }\n\n    @action closeModal() {\n        this.modal.show = false;\n        this.modal.body = null;\n    }\n}\n</pre>\n<p>Your real life data store would be bigger and have more properties and more actions. This is an example.</p>\n<p>We have an <code>@observable</code> property <code>modal</code>, which has a boolean to denote whether the modal is shown, and a variable for the modal body. Ideally, it&#39;s a React component, but you can use anything that React&#39;s engine knows how to render.</p>\n<p>MobX uses the <code>@observable</code> decorator to create deep getters and setters for object properties. This allows the MobX engine to know when properties are dereferenced (read or set), and run relevant observers.</p>\n<p>We use the <code>@action</code> decorator to say that a function is an action. I don&#39;t know if this does anything practical, but it makes your code better.</p>\n<p>If you only change store properties in actions, then you can model your application as a state machine. If you can model your application as a state machine, then you can understand what it&#39;s doing and your life will be easier.</p>\n<p>Limiting yourself to performing changes in actions increases boilerplateiness a little tiny bit, and gives you this in return:</p>\n<img class=\"alignnone size-full wp-image-7164\" src=\"https://swizec.com/blog/wp-content/uploads/2016/10/mobx-debugging.gif\" width=\"764\" height=\"204\" />\n<p>Trust me, you want it. ?</p>\n<p>In <code>App.js</code>, you add a helper function or two. These aren&#39;t necessary, but make the markup code cleaner. You&#39;ll see.</p>\n<pre lang=\"javascript\">\n// src/App.js\n\n@observer\nclass App extends Component {\n    store = new Store();\n\n        // this is useful for debugging only\n    componentDidMount() {\n        window.store = this.store;\n    }\n\n    openModal1() {\n        this.store.showModal(<strong>Strong Hello</strong>);\n    }\n\n    openModal2() {\n        this.store.showModal(<App />);\n    }\n</pre>\n<p>Note that your <code>App</code> must be an <code>@observer</code>. This allows the MobX engine to infer which data store changes are interesting to your component.</p>\n<p>In our example, the <code>openModal</code> functions invoke the <code>this.store.showModal</code> action and give it some JSX as the modal body. That&#39;s the nice thing about HTML as a first-class citizen: You can pass it around any way you want. Neat ?</p>\n<p>For the modal component itself, we&#39;re using <code>simple-react-modal</code> because it&#39;s got a clean API and makes it easy to override the styling. Ask your designer; I&#39;m sure they want custom styling if they can get it.</p>\n<pre lang=\"javascript\">\n// src/App.js -> render()\n\n            <Modal show={this.store.modal.show}\n                   closeOnOuterClick={true}\n                   onClose={this.store.closeModal.bind(this.store)}>\n\n                <a onClick={this.store.closeModal.bind(this.store)}\n                   style={closeStyle}>X</a>\n\n                {this.store.modal.body}\n            </Modal>\n</pre>\n<p>We&#39;re deferring to <code>simple-react-modal</code> to provide the <code>Modal</code> component and take care of the basic styling. Dark backdrop, centered white rectangle, that sort of thing.</p>\n<p>We tell it to show itself via the <code>show</code> prop, which we feed straight from our data store. To close our modal, we use the <code>store.closeModal</code> action, which sets <code>show</code> to <code>false</code>. Isn&#39;t that cool? Flipping a boolean makes a modal show or hide.</p>\n<p>For full flexibility, we use <code>this.store.modal.body</code> to render the modal&#39;s body. React makes it easy to store just about anything in that property. Even <code>&lt;App /&gt;</code> itself…  but only in debug mode ?</p>\n<p>And… yeah… that&#39;s about it, really. You can open modals from anywhere in your application that has access to the data store. Call <code>store.showModal(&lt;stuff&gt;)</code>, and it shows up. Call <code>store.closeModal()</code>, and it goes away.</p>\n<p>You could tie it to your routing and make it so users can refresh the page and keep the modal. I wish more webapps did that.</p>\n<p>PS: if you put the store in <code>window</code>, you can call actions in your browser console and see how your app reacts.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"b8b035ca-1385-58b3-b6c5-2a4a9507e4da"}}