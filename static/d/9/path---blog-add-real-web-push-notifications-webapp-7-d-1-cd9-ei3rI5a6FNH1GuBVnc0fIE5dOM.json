{"data":{"wordpressPost":{"title":"How to add real web push notifications to your webapp","content":"<p>You&#8217;ve probably seen web notifications before. YouTube shows them when it goes to a new song, Facebook pings them when a new message comes in, scammy websites ask for permissions and you say no. The usual.</p>\n<p>You can fire those notifications from anywhere inside your JavaScript.</p>\n<pre lang=\"javascript\">\nconst notification = new Notification(title, {\n    body: body,\n    icon: iconURL\n});\n</pre>\n<p>That creates a new browser notification and shows it to the user. Since Chrome 60-something on a Mac, they&#8217;re integrated with native notifications. It&#8217;s great.</p>\n<img class=\"alignnone size-full wp-image-7923\" src=\"https://swizec.com/blog/wp-content/uploads/2017/11/Screen-Shot-2017-11-16-at-09.37.29.png\" width=\"349\" height=\"105\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/11/Screen-Shot-2017-11-16-at-09.37.29.png 349w, https://swizec.com/blog/wp-content/uploads/2017/11/Screen-Shot-2017-11-16-at-09.37.29-300x90.png 300w\" sizes=\"(max-width: 349px) 100vw, 349px\" />\n<p>You can close the browser notification with <code>notification.close</code>, and you can listen for click events with <code>notification.onclick = () =&gt; ...</code>. Most often you&#8217;d want to use that click event to focus on your browser tab.</p>\n<p>To make this work however, the user must keep your webapp open and you must keep your fingers crossed the browser hasn&#8217;t throttled your JavaScript too much for inactivity. Browsers do that, you know.</p>\n<p>But did you know you can also add <em>real</em> push notifications to your webapp? The kind that come from a server and work even with no open tabs? Oh yes, just like a mobile app.</p>\n<p>I had no idea this has been part of Chrome since version 40-something. Firefox supports it, too. Safari and Internet Explorer, no.</p>\n<p>It is not a part of the JavaScript standard yet. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Push_API\">MDN lists web push notification support as experimental</a>.</p>\n<p>Here&#8217;s what you&#8217;ll need to make it work ðŸ‘‡</p>\n<ul>\n<li>a service worker</li>\n<li>some code to register the service worker</li>\n<li>some code to ask for notification permissions</li>\n<li>bit of code to subscribe to web push notifications</li>\n<li>a server to trigger the push notification</li>\n</ul>\n<h2>Service worker that listens for push events</h2>\n<p>You can think of service workers as a piece of JavaScript that lives in your user&#8217;s browser and does stuff. They can do stuff even when your site isn&#8217;t loaded, or even open.</p>\n<p>Most commonly they&#8217;re used for caching in what&#8217;s called progressive web apps â€“ PWA. They intercept requests and serve code from a local cache. Even if the browser is offline.</p>\n<p>But none of that right now. We&#8217;re using them for push notifications.</p>\n<p>A service worker will live in our user&#8217;s browser and listen for <code>push</code> events. The browser gets these events from a so-called push service, triggers the service worker, and our service worker does whatever.</p>\n<p>For security reasons, we can&#8217;t control <em>which</em> push service the browser uses. The browser tells us instead. You&#8217;ll see how in the section about subscribing.</p>\n<p>For privacy reasons, we also have to accept a sort of gentleman&#8217;s agreement with the browser where we promise to always show a notification when a push event comes in.</p>\n<p>Soâ€¦ a service worker is just a JavaScript file. Nothing fancy going on. You use <code>self</code> to refer to the global scope because there&#8217;s no <code>window</code> and no <code>document</code>.</p>\n<pre lang=\"javascript\">\n// service-worker.js\n\nfunction showNotification(event) {\n    return new Promise(resolve => {\n        const { body, title, tag } = JSON.parse(event.data.text());\n     \n        self.registration\n            .getNotifications({ tag })\n            .then(existingNotifications => { // close? ignore? })\n            .then(() => {\n                const icon = `/path/to/icon`;\n                return self.registration\n                    .showNotification(title, { body, tag, icon })\n            })\n            .then(resolve)\n    })\n}\n\nself.addEventListener(\"push\", event => {\n event.waitUntil(\n    showNotification(event)\n        );\n    }\n});\n\nself.addEventListener(\"notificationclick\", event => {\n    event.waitUntil(clients.openWindow(\"/\"));\n});\n</pre>\n<p>That&#8217;s all the code that goes into our service worker.</p>\n<p>In <code>showNotification</code>, we return a <code>Promise</code> that resolves once we&#8217;re done showing our notification.</p>\n<p>We use <code>JSON.parse</code> to unpack notification parameters using the convention of putting JSON into the <code>message</code> portion of our push notification.</p>\n<p>Before showing our push notification with <code>self.registration.showNotification</code>, we can clear any existing notifications with the same <code>tag</code> using <code>self.registration.getNotifications</code>. This gives us a list of notifications that we can <code>.close</code>.</p>\n<p>I&#8217;ve noticed (at least on a Mac) that subsequent notifications with the same <code>tag</code> sometimes don&#8217;t show up unless you close the previous ones.</p>\n<p>We use <code>self.addEventListener</code> to listen for both <code>push</code> and <code>onclick</code> events. In the push handler, we call <code>showNotification</code> to show our web push notification, and in <code>notificationclick</code> we open our site.</p>\n<p>That&#8217;s the service worker ðŸ˜„</p>\n<h2>Register the service worker</h2>\n<p>Registering said service worker happens in our regular JavaScript code. Usually in the main <code>index.js</code> entry point because there can be only one service worker for an entire domain.</p>\n<pre lang=\"javascript\">\nfunction registerServiceWorker() {\n    navigator.serviceWorker\n        .register('/service-worker.js')\n        .then(registration => {\n            console.log(\n                \"ServiceWorker registered with scope:\",\n                registration.scope\n            );\n        })\n        .catch(e => console.error(\"ServiceWorker failed:\", e));\n}\n\nif (navigator && navigator.serviceWorker) {\n    registerServiceWorker();\n}\n</pre>\n<p>We call <code>navigator.serviceWorker.registe</code> with the URL of our service worker and wait for the promise to resolve. If all goes well, we print a success message, otherwise we print an error.</p>\n<p>This is not a piece of code you&#8217;ll have to write often. Once per project at most. Many just find it online and copypasta when they need it, I think.</p>\n<p>One caveat to keep in mind is that service workers are limited to the scope they&#8217;re served from. You can&#8217;t serve that file from a CDN, or from a <code>static.domain.com</code>, or even <code>domain.com/static/</code>.</p>\n<p>This is a security precaution.</p>\n<p>My solution was to use the Webpack <a href=\"https://github.com/idiotWu/sw-loader\"><code>sw-loader</code></a> and configure it to compile this particular file into a different location and with a different publicPath than all other JavaScript, which goes into CDNs and has fingerprinting and stuff.</p>\n<p>That part was tricky, but it&#8217;s very specific to every webapp, so itâ€™s not a good candidate for this article ðŸ™‚</p>\n<h2>Ask for web notification permissions</h2>\n<p>If you&#8217;ve ever used web notifications before, you already know this part: You have to ask the user for permission.</p>\n<p>Here&#8217;s how that goes</p>\n<pre lang=\"javascript\">\nconst permission = Notification.requestPermission();\n\nif (permission !== 'granted') {\n    // no notifications\n}else{\n    // yay notifications\n}\n</pre>\n<p>Yep, that&#8217;s it.</p>\n<p>Running <code>Notification.requestPermission</code> pops up a little dialog for our user asking them to grant us web notification permissions. If they do, the permission is set to <code>granted</code>. Other options include <code>denied</code>, and I think it stays null if they ignore us.</p>\n<p>You can check permission status at any time with <code>Notification.permission</code>.</p>\n<h2>Subscribe to web push notifications</h2>\n<p>Here comes the interesting part: subscribing to web push notifications. This is where we ask the browser <em>&#8220;Hey, which push service do you wanna use?&#8221;</em></p>\n<p>The process has 2 to 3 steps depending on how you count ðŸ‘‡</p>\n<ol>\n<li>Create VAPID keys for our server, one-time</li>\n<li>Ask browser to subscribe</li>\n<li>Save subscription info for our user</li>\n</ol>\n<p><a href=\"https://blog.mozilla.org/services/2016/04/04/using-vapid-with-webpush/\">VAPID keys</a> are a way for our server to identify itself with the push service. That way our user&#8217;s browser can be sure that push notifications are coming from us and not from some random spammer who got in the way.</p>\n<p>I used the <a href=\"https://github.com/zaru/webpush\"><code>Webpush</code></a> gem to generate these keys, there&#8217;s a <a href=\"https://github.com/web-push-libs/web-push\"><code>web-push</code></a> package for node as well.</p>\n<pre lang=\"ruby\">\n# One-time, on the server\nvapid_key = Webpush.generate_key\n\n# Save these in your application server settings\nvapid_key.public_key\nvapid_key.private_key\n</pre>\n<p>You will have to send the <code>public_key</code> to your frontend somehow because you&#8217;ll need it to subscribe to web push notifications. The subscription itself happens like this:</p>\n<pre lang=\"javascript\">\nfunction subscribeToPushNotifications(registration) {\n    return registration.pushManager\n        .subscribe({\n            userVisibleOnly: true,\n            applicationServerKey: window.vapidPublicKey\n        })\n        .then(pushSubscription => {\n            console.log(\n                \"Received PushSubscription:\",\n                JSON.stringify(pushSubscription)\n            );\n            return pushSubscription;\n        });\n}\n</pre>\n<p>We call <code>registration.pushManager.subscribe</code> to subscribe with our <code>applicationServerKey</code>. That&#8217;s the <code>vapid.public_key</code>. And as I mentioned earlier, we promise to always show a notification with <code>userVisibleOnly: true</code>.</p>\n<p>Not a single browser currently supports <code>userVisibleOnly: false</code> because it could lead to privacy issues. Think sending a push and having your service worker send back detailed GPS location for your user. No bueno.</p>\n<p>That <code>pushSubscription</code> will have a bunch of data inside. Everything from which API endpoint to use when sending notifications to info about how to authenticate with the service.</p>\n<p>The browser is in full control.</p>\n<p>You should save that info on the backend and associate it with your user. As far as I can tell, it&#8217;s unique for every subscription request and definitely for every browser.</p>\n<p>The tricky part here is when the same user is using multiple browsers and devices. If you want to send push notifications to all of them, you&#8217;re going to have to keep multiple copies of this info.</p>\n<h2>Trigger a web push notification</h2>\n<p>To trigger a web push notification from your server, I suggest using a library. Something like <a href=\"https://github.com/zaru/webpush\">Webpush for Ruby</a> or <a href=\"https://github.com/web-push-libs/web-push\">web-push for node</a>. I&#8217;m sure libraries exist for other languages as well.</p>\n<p>Here&#8217;s how you&#8217;d send a notification in Ruby/Rails:</p>\n<pre lang=\"ruby\">\ndef send_web_push_notification(user_id)\n    subscription = User.find(user_id).web_push_subscription\n\n    message = {\n        title: \"You have a message!\",\n        body: \"This is the message body\",\n        tag: \"new-message\"\n    }\n \n    unless subscription.nil?\n        Webpush.payload_send(\n            message: JSON.generate(message),\n            endpoint: subscription[\"endpoint\"], \n            p256dh: subscription[\"keys\"][\"p256dh\"], \n            auth: subscription[\"keys\"][\"auth\"], \n            ttl: 15, \n            vapid: { \n                subject: 'mailto:admin@example.com', \n          public_key: Rails.application.config.webpush_keys[:public_key], \n          private_key: Rails.application.config.webpush_keys[:private_key] \n        }\n        )\n    end\nend\n</pre>\n<p>We use a database JSON field called <code>web_push_subscription</code> to save the <code>pushSubscription</code> info on our users.</p>\n<p>If that field has info, we can use <code>Webpush</code> to send a notification to the API. The API then sends it out to our service worker, which then shows a notification.</p>\n<h2>Fin</h2>\n<p>You should now be able to add web push notifications to your webapp. I left out some details around setting up Webpack to serve service worker code correctly, but we can get into that some other day.</p>\n<p>If you do decide to add push notifications to your webapp, please use them responsibly. Remember what happened to mobile app notifications and what a mess that has become.</p>\n<p>Wouldn&#8217;t want to train users to automatically deny notification permissions now would we ðŸ™‚</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"9665e725-865d-5357-8dba-f6bffb55d224"}}