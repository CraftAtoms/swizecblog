{"data":{"wordpressPost":{"title":"Livecoding recap #41: Towards declarative 3D scenes with React and Three.js","content":"<p><em>This is a Livecoding Recap ‚Äì an almost-weekly post about interesting things discovered while livecoding. Usually shorter than 500 words. Often with pictures. Livecoding happens almost <strong>every Sunday at 2pm PDT</strong> on multiple channels. You should follow <a href=\"https://www.youtube.com/channel/UCoyHgaeLLI7Knp7LDHOwZMw\">My Youtube</a> channel to catch me live.</em></p>\n<p>17 years ago, in 6th grade, I set out to build a 3D spinning cube and failed miserably. You can&#8217;t do 3D without sine and cosine.</p>\n<p>Today, I made it happen! <em>Two</em> 3D spinning cubes. ü§òüèº</p>\n<div id=\"attachment_7671\" style=\"width: 802px\" class=\"wp-caption alignnone\"><img class=\"alignnone size-full wp-image-7671\" src=\"https://swizec.com/blog/wp-content/uploads/2017/06/cubes-1.gif\" alt=\"Two spinning cubes\" width=\"792\" height=\"755\" /><p class=\"wp-caption-text\">Two spinning cubes</p></div>\n<p>As promised <a href=\"https://twitter.com/Swizec/status/876537115760222208\">poolside on Sunday</a>, this week&#8217;s livecoding session happened on Monday. Together, we admired the speed of <a href=\"https://swizec.com/blog/first-day-new-2017-macbook-pro/swizec/7643\">my new laptop</a>, wondered why YouTube still garbles my voice, and built two green spinning 3D cubes. Declaratively üòè</p>\n<p><iframe width=\"853\" height=\"480\" src=\"https://www.youtube.com/embed/eRMhOpdaKE8\" frameborder=\"0\" allowfullscreen></iframe></p>\n<p>The main render code looks like this:</p>\n<pre lang=\"javascript\">\n                <div className=\"App-intro\">\n                    <ThreeScene width={800} height={600}\n                                style={{margin: '0 auto' }}>\n                        <PerspectiveCamera fov={75}\n                                           aspect={800/600}\n                                           near={0.1}\n                                           far={1000}\n                                           position={{x: 0, y: 0, z: 30}}>\n\n                            <Cube rotation={rotation1}\n                                  position={{x: 2, y: 0, z: 25}}  />\n                            <Cube rotation={rotation2}\n                                  position={{x: -10, y: 5, z: 10 }} />\n\n                        </PerspectiveCamera>\n                    </ThreeScene>\n                </div>\n</pre>\n<p>A <code>ThreeScene</code>, which is a scene done with <a href=\"https://threejs.org/\">Three.js</a>, contains a <code>PerspectiveCamera</code>, which contains 2 <code>Cube</code> elements. Cube positions come from state, get changed on <code>requestAnimationFrame</code> in an infinite loop, and voil√†: Two Spinning Cubes.</p>\n<p>The goal was to come up with a declarative approach to creating 3D scenes. Write React components, use all the normal React idioms, and have stuff come out in 3D.</p>\n<p>I&#8217;m sure someone&#8217;s already built a React-to-Three library, but I wanted to give it a shot myself. You can think of this as a proof of concept.</p>\n<p>This is also the first time I&#8217;ve played with Three.js, and I have to say, it&#8217;s easier than I thought it would be. At least to render two cubes. Other stuff I&#8217;m sure is super hard.</p>\n<p>Here&#8217;s how it works. üëá</p>\n<p>PS: Full <a href=\"https://github.com/Swizec/something-3d\">code is on GitHub</a></p>\n<h2>Step 1: A <code>&lt;ThreeScene&gt;</code></h2>\n<pre lang=\"javascript\">\nclass ThreeScene extends Component {\n    scene = new THREE.Scene();\n    renderer = new THREE.WebGLRenderer();\n\n    componentDidMount() {\n        this.updateThree(this.props);\n\n        this.refs.anchor.appendChild(this.renderer.domElement);\n    }\n    componentDidUpdate() {\n        this.updateThree(this.props);\n    }\n\n    updateThree(props) {\n        const { width, height } = props;\n\n        this.renderer.setSize(width, height);\n    }\n\n    getChildContext() {\n        return {\n            scene: this.scene,\n            renderer: this.renderer\n        }\n    }\n\n    render() {\n        const { width, height, style } = this.props;\n\n        return (\n            <div ref=\"anchor\" style={[{width, height}, style]}>\n                 {this.props.children}\n            </div>\n        )\n    }\n}\n\nThreeScene.childContextTypes = {\n    scene: PropTypes.object,\n    renderer: PropTypes.object\n}\n</pre>\n<p>A <code>ThreeScene</code> component defines a new Three.js <code>Scene</code> and a <code>WebGLRenderer</code>. Both are added into React Context via <code>getChildContext</code>.</p>\n<p>Context is messy but it gives every child access to the scene and renderer. They&#8217;ll need the scene for rendering themselves, and the camera component will need access to the renderer.</p>\n<p>In <code>componentDidMount</code>, we manually update the DOM and <code>appendChild</code> to the rendered anchor element. This mounts our Three.js canvas to the DOM.</p>\n<img class=\"alignnone size-full wp-image-7672\" src=\"https://swizec.com/blog/wp-content/uploads/2017/06/dom-screenshot.jpg\" width=\"724\" height=\"195\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/06/dom-screenshot.jpg 724w, https://swizec.com/blog/wp-content/uploads/2017/06/dom-screenshot-300x81.jpg 300w\" sizes=\"(max-width: 724px) 100vw, 724px\" />\n<h2>Step 2: A <code>&lt;PerspectiveCamera&gt;</code></h2>\n<p>Three.js comes with a bunch of different camera configurations, and I don&#8217;t know what they all mean. I think one of them, the StereoCamera, is meant for VR.</p>\n<p>The base example uses <code>PerspectiveCamera</code>, so that&#8217;s what I used, too. This component sets up our camera and renders our scene.</p>\n<pre lang=\"javascript\">\nclass PerspectiveCamera extends Component {\n    constructor(props) {\n        super(props);\n\n        this.updateThree(props);\n    }\n    componentDidUpdate() {\n        this.updateThree(this.props);\n        this._render();\n    }\n\n    updateThree(props) {\n        const { fov, aspect, near, far, position } = this.props;\n\n        this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n        this.camera.position.x = position.x;\n        this.camera.position.y = position.y;\n        this.camera.position.z = position.z;\n    }\n\n    componentDidMount() {\n        this._render();\n    }\n\n    _render() {\n        this.context.renderer.render(this.context.scene, this.camera);\n    }\n\n    render() {\n        return <div>{this.props.children}</div>;\n    }\n}\n\nPerspectiveCamera.contextTypes = {\n    scene: PropTypes.object,\n    renderer: PropTypes.object\n}\n</pre>\n<p>We call <code>updateThree</code> when <code>&lt;PerspectiveCamera&gt;</code> is first initialized and whenever props or children update. This creates a new camera instance with updated properties.</p>\n<p>I&#8217;m sure Three.js supports changing field of view, aspect ratio, and other properties of an already instantiated camera, but there was no clear way of doing so. It looks like creating a new camera on every <code>requestAnimationFrame</code> doesn&#8217;t cause issues.</p>\n<p>Every time React updates our component, we call <code>_render</code>. It performs the actual Three.js rendering of our scene.</p>\n<h2>Step 3: Two <code>&lt;Cube&gt;</code>s</h2>\n<p>Finally, our <code>&lt;Cube&gt;</code> components know how to render a 3D cube from props, and add themselves to the scene when mounted. They should remove themselves when unmounted, but I didn&#8217;t implement that part due to <em>&#8220;Eh, it&#8217;s just an example.‚Äù</em></p>\n<pre lang=\"javascript\">\nclass Cube extends Component {\n    componentWillMount() {\n        this.geometry = new THREE.BoxGeometry(1, 1, 1);\n        this.material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n        this.cube = new THREE.Mesh(this.geometry, this.material);\n\n        this.context.scene.add(this.cube);\n    }\n\n    componentDidUpdate() {\n        const { rotation, position } = this.props;\n\n        this.cube.rotation.x = rotation.x;\n        this.cube.rotation.y = rotation.y;\n\n        this.cube.position.x = position.x;\n        this.cube.position.y = position.y;\n        this.cube.position.z = position.z;\n    }\n\n    render() {\n        return null;\n    }\n}\n\nCube.contextTypes = {\n    scene: PropTypes.object\n}\n</pre>\n<p>Officially, a <code>&lt;Cube&gt;</code> component renders <code>null</code>. Unofficially, it adds itself to the scene with <code>scene.add</code> in <code>componentWillMount</code>.</p>\n<p>When it&#8217;s being mounted, it also sets up the object itself with <code>Geometry</code>, adds a green <code>Mesh</code>, and updates its own <code>rotation</code> and <code>position</code> on every <code>componentDidUpdate</code>. This creates smooth animation if we change props often enough.</p>\n<p>Every <code>requestAnimationFrame</code> is best.</p>\n<h2>Fin</h2>\n<p>And that&#8217;s how we can render declarative 3D scenes in React. This has been a 2-hour experiment. With some more work, it could become a proper way to use Three.js with a React approach.</p>\n<p>Surely someone&#8217;s already built that‚Ä¶</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"1d227987-370e-587c-8565-e8ee03d3d1a0"}}