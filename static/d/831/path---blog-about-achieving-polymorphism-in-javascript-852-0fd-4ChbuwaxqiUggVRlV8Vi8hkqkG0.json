{"data":{"wordpressPost":{"title":"About achieving polymorphism in Javascript","content":"<p>Over the weekend I started working on a <a href=\"https://github.com/Swizec/toshl.js\">node.js client library for Toshl&#8217;s new API</a>. An old side project stopped working recently and I need to fix it because life without <a href=\"http://swizec.com/blog/a-message-from-your-future-self/swizec/3377\">frequent emails about my money</a> is disorienting as hell.</p>\n<p>The <a href=\"https://developer.toshl.com/\">Toshl beta API</a> opened up in July is well thought out, has good documentation and provides everything you could possibly want. I love the well granulated permissions system.</p>\n<p>But for users of my node.js library I wanted to make life even simpler. Let&#8217;s look at fetching expenses.</p>\n<p>After you authenticate &#8211; testing <a class=\"zem_slink\" title=\"OAuth\" href=\"http://oauth.net\" target=\"_blank\" rel=\"homepage\">OAuth</a> clients sucks, and Toshl invalidates your token <em>very</em> often. Think I had to refresh it four times in a five hour coding spree. &#8211; you can talk to <code>https://api.toshl.com/expenses</code> to get a list of expenses for the current user.</p>\n<p>This will return the last 30 entries.</p>\n<p>But there are a bunch of options. You have pagination, you can set specific <code>to</code> and <code>from</code> dates, you can filter things by tags and by not-tags.</p>\n<p>How can a library make this easy to use?</p>\n<p>One approach is to offer a way of specifying an options hash when calling a function, but can we make it even simpler?</p>\n<p>The answer lies in polymorphism.</p>\n<p>Let&#8217;s say you have a function called <code>toshl.expenses</code>, in <a class=\"zem_slink\" title=\"Haskell (programming language)\" href=\"http://haskell.org\" target=\"_blank\" rel=\"homepage\">Haskell</a> you could do something like this:</p>\n<pre lang=\"haskell\">expenses::Result\r\nexpenses = general_expenses \"\"\r\n\r\nexpenses::Number -> Result\r\nexpenses N = general_expenses \"?per_page=\"+str(N)\r\n\r\nexpenses::[String] -> Result\r\nexpenses tags = general_expenses \"?tags=\"+(tags.join \"&amp;\")\r\n\r\nexpenses::Date -> Date -> Result\r\nexpenses from to = general_expenses \"?from=\"+str(from)+\"&amp;\"+str(to)\r\n\r\nexpenses::Json -> Result\r\nexpenses params = general_expenses \"?\"+to_query(params)\r\n\r\ngeneral_expenses::String -> Result\r\ngeneral_expenses query = make_request \"/expenses\" query\r\n\r\nmake_request::String -> String -> Result\r\nmake_request endpoint query = ;; do stuff to read from full URL</pre>\n<p>The syntax is likely wrong but you get what I&#8217;m pointing at. You can always call <code>expenses</code> with the argument you care about and it will construct a call to the more generalized version of the function magically.</p>\n<p>You can tell what calling <code>expenses</code> will do in each case at a glance and checking what type of arguments the function accepts is trivial. Even somebody who isn&#8217;t familiar with Haskell could understand that code.</p>\n<p>Here&#8217;s that same polymorphic code in <a class=\"zem_slink\" title=\"JavaScript\" href=\"http://en.wikipedia.org/wiki/JavaScript\" target=\"_blank\" rel=\"wikipedia\">Javascript</a>. This time tested working code.</p>\n<pre lang=\"javascript\">exports.Toshl.prototype.expenses = function (params, to, callback) {\r\n    var options = {},\r\n        query = '';\r\n    callback = arguments[arguments.length-1];\r\n\r\n    if (params) {\r\n        if (typeof params == 'number') {\r\n            options['per_page'] = params;\r\n        }else if (arguments.length == 3) {\r\n            options['from'] = util.iso_date(params);\r\n            options['to'] = util.iso_date(to);\r\n        }else if (params instanceof Array) {\r\n            var tags = util.transform_tags(params);\r\n            options[tags.type] = tags.tags;\r\n        }else if (params instanceof Object) {\r\n            options = params;\r\n\r\n            ['from', 'to'].forEach(function (key) {\r\n                if (options[key]) {\r\n                    options[key] = util.iso_date(options[key]);\r\n                }\r\n            });\r\n        }\r\n\r\n        query = \"?\"+querystring.stringify(options);\r\n    }\r\n\r\n    this._request('/expenses'+query, callback);\r\n};</pre>\n<p>Oh wow, what?</p>\n<p>Even if you&#8217;re very comfortable with Javascript you&#8217;re going to have a hard time figuring out what&#8217;s going on. It seems the majority of the function deals with translating <code>arguments</code> into a <code>query</code>, then it defers to <code>this._request</code> for the hard work.</p>\n<p>This is the cleanest implementation I could think of so far. Let&#8217;s investigate.</p>\n<p>First we ensured that <code>callback</code> is always the last supplied argument, that makes sense when you expect variable amounts of arguments. Everything from one to three is okay.</p>\n<p>Then, if <code>params</code> is a number we use it to construct a <code>?per_page=N</code> query. If there are three arguments, we use the first two to construct a <code>?from=Date&amp;to=Date</code> query. If the first argument is an Array we use it to get tags and if it&#8217;s an Object we assume it represents a parameters hash for the API.</p>\n<p>The result is that we can do this:</p>\n<pre lang=\"javascript\">var toshl = new Toshl();\r\n\r\ntoshl.expenses(console.log); // prints last 30 expenses\r\n\r\ntoshl.expenses(5, console.log); // prints last 5 expenses\r\n\r\ntoshl.expenses(\"2013-10-01\", new Date(), console.log); // prints all expenses between October 1st and now\r\n\r\ntoshl.expenses([\"coffee\", \"food\"], console.log); // prints last 30 expenses tagged with coffee or food\r\n\r\ntoshl.expenses({per_page: 10, tags: [\"coffee\", \"food\"]}, console.log) // prints last 10 expenses tagged coffee or food</pre>\n<p>The date magic is done with the wonderful <a href=\"http://momentjs.com/\">moment.js</a> library &#8211; you can supply a Date object, a date string or a moment object, but we could obviously improve on this by assuming the <code>to</code> date is &#8220;now&#8221;, if none is provided.</p>\n<p>But the code is getting complicated as it is.</p>\n<p>Does anyone know a better way to achieve polymorphism in Javascript? I really like it when I&#8217;m using libraries, but I hate implementing it this way &#8230;</p>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" alt=\"Enhanced by Zemanta\" src=\"http://img.zemanta.com/zemified_e.png?x-id=739c8f9e-f369-4125-9471-ec1a4738359c\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"0b57215b-ff6c-5ef0-a7fd-2a03d5ac7bdf"}}