{"data":{"wordpressPost":{"title":"Livecoding #18: An abstract React transition component","content":"<p><em>This is a Livecoding Recap â€“ an almost-weekly post about interesting things discovered while livecoding ?. Always under 500 words and with pictures. You can follow my channel, <a href=\"https://livecoding.tv/swizec\">here</a>. New content almost <strong>every Sunday at 2pm PDT</strong>. Thereâ€™s live chat, come say hai ?</em></p>\n<p><iframe src=\"https://www.livecoding.tv/swizec/videos/qyWj1/embed\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"true\" scrolling=\"no\"></iframe></p>\n<p>This week we made a circle bounce back and forth. ?</p>\n<p>Trivial, right? Yes, as trivial as it gets. The bouncing circle wasn&#8217;t the point, the point was how it&#8217;s made. This: <a href=\"https://github.com/Swizec/react-transitionable-component\">react-transitionable-component</a>. My first not-just-a-cool-experiment open source contribution to the React ecosystem.</p>\n<p>It&#8217;s an abstract component that makes building transitions easy. </p>\n<p>Over the past few weeks, I&#8217;ve noticed that making a transition always follows the same pattern: move props to state, render from state instead of props, use <code>d3.transition</code> to transition prop values on every <code>componentWillReceiveProps</code>. What if we can abstract all that work away? ?</p>\n<p>We started with this jumping circle:</p>\n<blockquote class=\"imgur-embed-pub\" lang=\"en\" data-id=\"a/sFBlt\"><p><a href=\"//imgur.com/sFBlt\"></a></p></blockquote>\n<p><script async src=\"//s.imgur.com/min/embed.js\" charset=\"utf-8\"></script></p>\n<p>And ended with this transitioned circle:</p>\n<blockquote class=\"imgur-embed-pub\" lang=\"en\" data-id=\"a/Z256F\"><p><a href=\"//imgur.com/Z256F\"></a></p></blockquote>\n<p><script async src=\"//s.imgur.com/min/embed.js\" charset=\"utf-8\"></script></p>\n<p>It took me over an hour to realize that zooming-in would have made everyone&#8217;s lives easier, but here we are. Tiny little gifs for tiny little screens. Or big screens. The gifs are always tiny.</p>\n<p>Making a circle that transitions like that isn&#8217;t hard. It takes about twenty minutes to show and explain to a novice in both React and D3. At least that&#8217;s how much it takes when I do workshops.</p>\n<p>So who cares about making abstraction, right? I care. Doing it from scratch every time gets old, fast. I wanted a way to say <em>&#8220;make this component use transitions for everything.&#8221;</em> without worrying about implementation every time. </p>\n<p>As you can expect from a project that took less than two hours from start to finish, there&#8217;s little code to show. <a href=\"https://github.com/Swizec/react-transitionable-component/blob/master/src/TransitionableComponent.js\">40 lines</a> that look like this:</p>\n<pre lang=\"javascript\">\r\nclass TransitionableComponent extends Component {\r\n    constructor(props) {\r\n        // copy all props to state\r\n        // call _defineEasing and _defineDuration\r\n    }\r\n\r\n    _defineEasing(easing) {\r\n        // if this.easing undefined, get easing function from d3\r\n    }\r\n\r\n    _defineDuration(duration) {\r\n        // if this.duration undefined, set it\r\n    }\r\n\r\n    componentWillReceiveProps(newProps) {\r\n        this._defineEasing(newProps.easing);\r\n        this._defineDuration(newProps.duration);\r\n\r\n        const node = d3.select(this.refs.node);\r\n\r\n        let transition = node.transition()\r\n                             .ease(this.easing);\r\n\r\n        if (this.duration !== undefined) {\r\n            transition.duration(this.duration);\r\n        }\r\n\r\n        Object.keys(newProps)\r\n              .forEach((k) => {\r\n                  transition.attr(k, newProps[k]);\r\n              });\r\n\r\n        transition.on('end', () => this.setState(newProps));\r\n    }\r\n}\r\n</pre>\n<p>I cut out the boring bits. You can see them on GitHub, <a href=\"https://github.com/Swizec/react-transitionable-component/blob/master/src/TransitionableComponent.js\">here</a>.</p>\n<p>The fun bit is in <code>componentWillReceiveProps</code>. We update our easing function and our duration, which should&#8217;ve been dynamic getters instead. Then we get the <code>node</code> and start a <code>transition()</code> with an easing function, and a <code>duration</code>, if it&#8217;s there. After that, we walk through every prop and add it to the pile of transitioning attributes with <code>.attr</code>. When the transition is over, we use the <code>'end'</code> callback to update component state and ensure React understands what&#8217;s going on.</p>\n<p>You&#8217;ll notice <code>TransitionableComponent</code> doesn&#8217;t have a <code>render()</code> function. It&#8217;s an abstract component meant to be extended by a real component. Something like this:</p>\n<pre lang=\"javascript\">\r\nclass Circle extends TransitionableComponent {\r\n    render() {\r\n        return <circle cx={this.state.cx}\r\n                       cy={this.state.cy}\r\n                       r={this.state.r} />\r\n    }\r\n}\r\n</pre>\n<p>That&#8217;s a transitionable circle now. Any props passed into it are transitioned. You have to be careful to use <code>this.state</code> instead of <code>this.props</code> when using them though.</p>\n<p>Using the <code>Circle</code> component looks like this:</p>\n<pre lang=\"javascript\">\r\n    <Circle cx=\"100\" cy=\"100\" r=\"5\" easing=\"cubicInOut\" duration=\"1500\" />\r\n</pre>\n<p>See, easy. ðŸ™‚</p>\n<p>Join me next week when we clean this up to use dynamic getters, avoid importing the entire d3 library, and build some examples.</p>\n<p>PS: the edited and improved versions of these videos are becoming a video course. Readers of the engineer package of <a href=\"http://swizec.com/reactd3js/\">React+d3js ES6</a> get the video course for free when itâ€™s ready.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"3ead7968-5b0c-5562-b845-f4301ac4b558"}}