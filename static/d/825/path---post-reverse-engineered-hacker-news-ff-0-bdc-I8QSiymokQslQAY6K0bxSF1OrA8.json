{"data":{"wordpressPost":{"title":"How I reverse-engineered Hacker News","content":"<p><a href=\"https://github.com/HackerNews/API\">Hacker News has a public API</a>, and it&#8217;s great. Live frontpage updates, live upvote counts, live comments. Everything you want or need at the tip of your fingers in real-time.</p>\n<p>But there&#8217;s no write. You can&#8217;t login, you can&#8217;t upvote, and you can&#8217;t post. You can&#8217;t do anything but read. And you need writes to make a <a href=\"https://school.shoutem.com/lectures/hacker-news-app-part-2-upvoting-commenting/\">Hacker News App</a>.</p>\n<img src=\"http://i0.kym-cdn.com/photos/images/original/000/415/209/3b4.png\" />\n<p>Without a public write API, the only thing left to do was to reverse engineer HackerNews forms and fake them with <code>fetch()</code> requests. Technically, this falls under <a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\">cross site request forgery</a>, but it isn&#8217;t malicious.</p>\n<p>Sure, we&#8217;re pretending that we&#8217;re a browser that&#8217;s submitting forms, but we do what the user expects. That makes it okay, I think. HackerNews allows it at least. <sup><a id=\"ffn1\" href=\"#fn1\" class=\"footnote\">1</a></sup> <em>shrug</em></p>\n<p>So how do you approach this sort of problem?</p>\n<p>It happens in 3 steps:</p>\n<ol>\n<li>Do the action</li>\n<li>Inspect the request</li>\n<li>Fake the request</li>\n</ol>\n<p>The <a href=\"https://gist.github.com/Swizec/de31ad9f995b0ad6bfe84dafd92e1e53\">Unofficial HN write API wrapper</a> lives as a Gist. I&#8217;m tempted to release it as an NPM module. Should I?</p>\n<p>I&#8217;m going to show you how this works on two examples: A Login form and an Upvote button. The first is a normal POST request; the second is a GET request with some fakery protection.</p>\n<h2>Do the action</h2>\n<p>HackerNews&#8217;s login form looks like this:</p>\n<img class=\"alignnone size-full wp-image-7737\" src=\"https://swizec.com/blog/wp-content/uploads/2017/08/login-screenshot.png\" width=\"327\" height=\"139\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/08/login-screenshot.png 327w, https://swizec.com/blog/wp-content/uploads/2017/08/login-screenshot-300x128.png 300w\" sizes=\"(max-width: 327px) 100vw, 327px\" />\n<p>Which in HTML looks like this:</p>\n<pre lang=\"html\">\n<form method=\"post\" action=\"login\">\n    <input type=\"hidden\" name=\"goto\" value=\"news\">\n    <table border=\"0\">\n    <tbody>\n    <tr>\n        <td>username:</td>\n        <td>\n            <input type=\"text\" name=\"acct\" size=\"20\" autocorrect=\"off\" spellcheck=\"false\" autocapitalize=\"off\" autofocus=\"true\" autocomplete=\"off\">\n        </td>\n    </tr>\n    <tr>\n        <td>password:</td>\n        <td>\n            <input type=\"password\" name=\"pw\" size=\"20\" autocomplete=\"off\">\n        </td>\n    </tr>\n    </tbody>\n    </table><br>\n    <input type=\"submit\" value=\"login\">\n</form>\n</pre>\n<p>Looking at this HTML tells us HackerNews uses a POST request to to the <code>/login</code> URL to log you in, then it sends a <code>goto</code> field<sup><a id=\"ffn2\" href=\"#fn2\" class=\"footnote\">2</a></sup>, and two text fields; <code>acct</code> and <code>pw</code>. Whoever wrote this code doesn&#8217;t believe in typing things out.</p>\n<hr />\n<p>The Upvote action isn&#8217;t a form; it&#8217;s a link that looks like this:</p>\n<pre lang=\"html\">\n<a id=\"up_14918911\" onclick=\"return vote(event, this, &quot;up&quot;)\" href=\"vote?id=14918911&amp;how=up&amp;auth=0855997b736abc0c65600fee44fbf9bbf3bca65c&amp;goto=news\"><div class=\"votearrow\" title=\"upvote\"></div></a>\n</pre>\n<p>This tells us that voting happens through JavaScript. We can look for the <code>vote()</code> function in <a href=\"https://news.ycombinator.com/hn.js?S3M7ra4yMVMIVvYSGhjv\">HackerNews&#8217;s javascript code</a>. Lucky for us, it is neither obfuscated nor minified. This makes it easy to read right in Chrome DevTools.</p>\n<img class=\"alignnone size-full wp-image-7738\" src=\"https://swizec.com/blog/wp-content/uploads/2017/08/code-screenshot.png\" width=\"2160\" height=\"1598\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/08/code-screenshot.png 2160w, https://swizec.com/blog/wp-content/uploads/2017/08/code-screenshot-300x222.png 300w, https://swizec.com/blog/wp-content/uploads/2017/08/code-screenshot-768x568.png 768w, https://swizec.com/blog/wp-content/uploads/2017/08/code-screenshot-1024x758.png 1024w\" sizes=\"(max-width: 2160px) 100vw, 2160px\" />\n<p>The <code>vote()</code> function looks like this:</p>\n<pre lang=\"javascript\">\nfunction vote(ev, el, how) {\n  var id = el.id.split(/_/)[1];\n  var up = $('up_' + id);\n  vis(up, how == 'un');\n  vis($('down_' + id), how == 'un');\n  var unv = '';\n  if (how != 'un') {\n    unv = \" | <a id='un_\" + id\n      + \"' onclick='return vote(event, this,\\\"un\\\")' href='\"\n      + up.href.replace('how=up','how=un')\n      + \"'>\" + (how == 'up' ? 'unvote' : 'undown') + \"</a>\"\n  }\n  $('unv_' + id).innerHTML = unv;\n  new Image().src = el.href;\n  ev.stopPropagation();\n  return false;\n}\n</pre>\n<p>Most of this code deals with updating the UI. The interesting line is <code>new Image().src = el.href</code>. It tells us that HackerNews upvotes use a GET request to the URL set in the link.</p>\n<p>In this case, that link is <code>/vote?id=14918911&amp;how=up&amp;auth=0855997b736abc0c65600fee44fbf9bbf3bca65c&amp;goto=news</code>.</p>\n<p>The <code>auth</code> argument looks tricky. It&#8217;s some sort of authentication token making sure these requests don&#8217;t get forged. Look at other examples on the page, and you&#8217;ll see the <code>auth</code> token is different on every upvote button.</p>\n<p>That means it isn&#8217;t a per-user token, it&#8217;s a per-user-per-story token. Which means we&#8217;re going to have to find the URL every time we want to upvote anything.</p>\n<h2>Inspect the request</h2>\n<p>We can confirm our findings by making the actions and inspecting their requests in Chrome DevTools.</p>\n<p>Due to redirects, you have to enable <code>Preserve Log</code>. Somehow I had never noticed that feature existed before doing this.</p>\n<img class=\"alignnone size-full wp-image-7735\" src=\"https://swizec.com/blog/wp-content/uploads/2017/08/preserve-logs.png\" width=\"850\" height=\"212\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/08/preserve-logs.png 850w, https://swizec.com/blog/wp-content/uploads/2017/08/preserve-logs-300x75.png 300w, https://swizec.com/blog/wp-content/uploads/2017/08/preserve-logs-768x192.png 768w\" sizes=\"(max-width: 850px) 100vw, 850px\" />\n<p>As we assumed, the login request sends <code>goto</code>, <code>acct</code>, and <code>pw</code>, and sets a cookie.</p>\n<img class=\"alignnone size-full wp-image-7739\" src=\"https://swizec.com/blog/wp-content/uploads/2017/08/login-request-screenshot.png\" width=\"2366\" height=\"1394\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/08/login-request-screenshot.png 2366w, https://swizec.com/blog/wp-content/uploads/2017/08/login-request-screenshot-300x177.png 300w, https://swizec.com/blog/wp-content/uploads/2017/08/login-request-screenshot-768x452.png 768w, https://swizec.com/blog/wp-content/uploads/2017/08/login-request-screenshot-1024x603.png 1024w\" sizes=\"(max-width: 2366px) 100vw, 2366px\" />\n<hr />\n<p>Inspecting the upvote request follows a similar process. This is what we find:</p>\n<img class=\"alignnone size-full wp-image-7736\" src=\"https://swizec.com/blog/wp-content/uploads/2017/08/upvote-request-screenshot.png\" width=\"1019\" height=\"745\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/08/upvote-request-screenshot.png 1019w, https://swizec.com/blog/wp-content/uploads/2017/08/upvote-request-screenshot-300x219.png 300w, https://swizec.com/blog/wp-content/uploads/2017/08/upvote-request-screenshot-768x561.png 768w\" sizes=\"(max-width: 1019px) 100vw, 1019px\" />\n<p>No surprises here. We have to send a GET request to the upvote URL that&#8217;s unique for every upvote button. We also send our login cookie so we can assume the server is doing some sort of validation between who&#8217;s logged in and what the auth token says.</p>\n<h2>Fake the request</h2>\n<p>To fake these requests, we use <code>fetch()</code>. Login is simple; it looks like this:</p>\n<pre lang=\"javascript\">\nclass HN {\n    BaseURL = 'https://news.ycombinator.com';\n\n    login(username, password) {\n        let headers = new Headers({\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Access-Control-Allow-Origin\": \"*\"\n        });\n\n        return fetch(`${this.BaseURL}/login`,\n                     {\n                         method: \"POST\",\n                         headers: headers,\n                         body: convertRequestBodyToFormUrlEncoded({\n                             acct: username,\n                             pw: password,\n                             goto: 'news'\n                         }),\n                         mode: 'no-cors',\n                         credentials: 'include'\n                     }).then(res => res.text())\n                       .then(body => {\n                           if (body.match(/Bad Login/i)) {\n                               return false;\n                           }else{\n                               return true;\n                           }\n                       });\n    }\n}\n</pre>\n<p>We set a <code>Content-Type</code> header to <code>application/x-www-form-urlencoded</code>. Many servers can handle params in any shape they come, but HackerNews is not one of those. This is the only type that works.</p>\n<p>Our <code>fetch()</code> request uses the <code>POST</code> method and our <code>headers</code>, converts our <code>{acct, pw, goto}</code> data object into a URL encoded string, asks the server (or is it the browser?) to please ignore <a href=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\">CORS</a>, and we set <code>credentials: 'include'</code> to  automagically handle cookies. That&#8217;s how you expect client-side requests to behave, but you have to explicitly ask for it with <code>fetch()</code>.</p>\n<p>HackerNews responds with either the login page or the news page. If login was successful, we get the news page. Unsuccessful, and we get the login page with a <code>Bad Login</code> text.</p>\n<p>We look for said <code>Bad Login</code> text to decide if we are now logged in. Hopefully there are no frontpage stories with <code>Bad Login</code> in their title 😀</p>\n<hr />\n<p>Faking an upvote request is more tricky. We have to first fetch the URL.</p>\n<p>To do that we use <a href=\"https://github.com/cheeriojs/cheerio\">CheerioJs</a>, an HTML parser that works in JavaScript and gives us a jQuery-like interface to the document. It&#8217;s designed to work in node, but you can use the <a href=\"https://github.com/oyyd/cheerio-without-node-native\">cheerio-without-node</a> in the browser or React Native.</p>\n<p>Each HackerNews story can have its own page. This makes our job easier. We can request that page, parse it, and find the upvote button. That looks like this:</p>\n<pre lang=\"javascript\">\nclass HN {\n    // ..\n    getUpvoteURL(id) {\n        return fetch(`${this.BaseURL}/item?id=${id}`,\n                     {\n                         mode: 'no-cors',\n                         credentials: 'include'\n                     }).then(res => res.text())\n                       .then(body => {\n                           const doc = cheerio.load(body);\n\n                           return doc(`#up_${id}`).attr('href');\n                       });\n    }\n}\n</pre>\n<p>We&#8217;re making a basic GET request, asking to avoid CORS, and including our credentials. That way HackerNews thinks we&#8217;re a browser with a logged in user and gives us exactly what it would give to a normal user.</p>\n<p>We use <code>cheerio.load</code> to parse the HTML and look for the upvote URL with <code>doc(#up_${id})</code>. Just like we would with jQuery.</p>\n<p>You can find the correct ID in the upvote button&#8217;s HTML. Here it is again:</p>\n<pre lang=\"html\">\n<a id=\"up_14918911\" onclick=\"return vote(event, this, &quot;up&quot;)\" href=\"vote?id=14918911&amp;how=up&amp;auth=0855997b736abc0c65600fee44fbf9bbf3bca65c&amp;goto=news\"><div class=\"votearrow\" title=\"upvote\"></div></a>\n</pre>\n<p>This part: <code>&lt;a id=\"up_...\"</code>. It&#8217;s unique for every upvote link and helps us find the right one.</p>\n<p>To use this link, we issue a <code>fetch()</code> request similar to the one we used to find it.</p>\n<pre lang=\"javascript\">\nclass HN {\n    // ...\n    upvote(id) {\n        return this.getUpvoteURL(id)\n                   .then(url => fetch(`${this.BaseURL}/${url}`, {\n                       mode: 'no-cors',\n                       credentials: 'include'\n                   }))\n                   .then(res => res.text())\n                   .then(body => {\n                       return true;\n                   })\n                   .catch(error => {\n                       console.log(error);\n                       return false;\n                   });\n    }\n}\n</pre>\n<p>Get the URL, make a fetch, include credentials, assume it worked. HackerNews doesn&#8217;t give us any real indication that it worked or not. We have to assume.</p>\n<p>I guess we could re-fetch the item&#8217;s page and see if that upvote button is still there. 🤔 Sending 2 requests for every upvote feels bad enough, though. No need to make it 3.</p>\n<h2>Your new superpower</h2>\n<p>You can use this approach to reverse engineer any website. If it works on HackerNews, it&#8217;s going to work everywhere.</p>\n<p>Apps and websites fundamentally cannot guard against something like this. If legitimate users can use the site, then you can pretend to be a real user and fake those requests. It&#8217;s just how it is.</p>\n<p>HackerNews makes it easy. For others, it might be trickier.</p>\n<p>Use your new superpower responsibly.</p>\n<img class=\"alignnone size-full wp-image-7740\" src=\"https://swizec.com/blog/wp-content/uploads/2017/08/mr-robot.jpg\" width=\"900\" height=\"506\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/08/mr-robot.jpg 900w, https://swizec.com/blog/wp-content/uploads/2017/08/mr-robot-300x169.jpg 300w, https://swizec.com/blog/wp-content/uploads/2017/08/mr-robot-768x432.jpg 768w\" sizes=\"(max-width: 900px) 100vw, 900px\" />\n<ol id=\"footnotes\">\n<li id=\"fn1\">There are ways to prevent cross-site requests with <a href=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\">CORS policies</a>, domain filtering, and stuff like that. <a href=\"#ffn1\">&#8617;</a></li>\n<li id=\"fn2\">All HN actions have a <code>goto</code> field or argument, I assume it tells the server where to redirect after the request. <a href=\"#ffn2\">&#8617;</a></li>\n</ol>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"d035996b-9bbf-588e-9b79-32346503f557"}}