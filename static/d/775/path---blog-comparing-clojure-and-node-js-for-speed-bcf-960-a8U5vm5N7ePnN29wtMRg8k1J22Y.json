{"data":{"wordpressPost":{"title":"Comparing clojure and node.js for speed","content":"<p>For the longest of whiles I&#8217;ve been working on a speed comparison between Node.js and Clojure. Today I had some time in a place with unreliable internets and finally gave it a whirl since there was nothing better to do, I certainly wasn&#8217;t going to merely enjoy the sun.</p>\n<p><img alt=\"\" src=\"http://28.media.tumblr.com/tumblr_lja8awZaYe1qekjngo1_500.jpg\" title=\"Sun at Rimski Zid\" class=\"alignright\" width=\"500\" height=\"500\" />The comparison I chose to go for is hard computation &#8211; namely calculating a list of primes up to a certain number. Why this test? Because primes are awesome!</p>\n<p>I did my best to implement the same algorithm in both. It creates a list of numbers from 3 to N, then filters it of anything that isn&#8217;t a prime. Through a bit of trial and error this turned out to be the quickest approach, possibly because it means we can run prime-ness tests in parallel on several numbers.</p>\n<p>For node.js I also implemented a bit different algorithm that builds a list of known primes and iterates through that instead of everything under the square root of the target. It can&#8217;t run in parallel, but turns out it&#8217;s faster &#8230; couldn&#8217;t figure out how to implement it in clojure to be fast as you can see from my post on <a href=\"http://swizec.com/blog/checking-for-primes-dumber-algorithm-is-faster-algorithm/swizec/1580\">prime searching in clojure</a>.</p>\n<p>As far as initial observations go there were a few interesting things I discovered:</p>\n<ol>\n<li>Node is super fast for heavy but small calculations and seems to break down for large datasets.</li>\n<li>Clojure really benefits from native implementations of filter and such. I suspect that they are running in parallel because it is consistently burning 15+ threads.\n</li>\n<li>Jacking up the max N to 100,000,000 caused a memory allocation error in the classic node.js algorithm, but worked fine with the cutesier one.\n</li>\n<li>Both Node and Clojure were burning around 600 megs of RAM when doing the 1M test</li>\n</ol>\n<p>The computer I was testing on is my trusty MBP with 4gigs of RAM and a 2.4gig core2duo. To avoid as much artefacts as possible each test was run five times and the average runtime was calculated. Just in case it&#8217;s relevant, the computer was running on battery at the time, there&#8217;s a slight chance this means the CPU was clocked down.</p>\n<h2>The code</h2>\n<p>This is the basic implementation in node.js, the more cutesy algorithm just uses a global array of known primes and iterates over those, but otherwise the code is the same so it&#8217;d be silly to post it twice.</p>\n<pre lang=\"javascript\" line=\"1\">\r\n\r\nvar async = require('async');\r\n\r\nvar isPrime = function (n, callback) {\r\n    if (n%2 == 0) {\r\n\tcallback(false);\r\n\treturn;\r\n    }else{\r\n\tvar root = Math.sqrt(n);\r\n\tfor (var i=3; i<=root; i += 2) {\r\n\t    if (n%i == 0) {\r\n\t\tcallback(false);\r\n\t\treturn;\r\n\t    }\r\n\t}\r\n    }\r\n    callback(true);\r\n}\r\n\r\nvar primes = function (n, callback) {\r\n    var acc = new Array();\r\n\r\n    for (var i=2; i<n; acc.push(i++));\r\n\r\n    async.filter(acc, isPrime, function(results){\r\n\tresults.unshift(2);\r\n\tcallback(results);\r\n    });\r\n}\r\n\r\nprimes(process.argv[2], function (result) {\r\n});\r\n</pre>\n<p>This is practically the same code in clojure:</p>\n<pre lang=\"lisp\" line=\"1\">\r\n(defn prime? [n]\r\n  (if (even? n) false\r\n      (let [root (num (int (Math/sqrt n)))]\r\n\t(loop [i 3]\r\n\t  (if (> i root) true\r\n\t      (if (zero? (mod n i)) false\r\n\t\t  (recur (+ i 2))))))))\r\n\r\n(defn primes [n]\r\n  (let [nums (loop [i 2 acc []]\r\n\t       (if (> i n) acc\r\n\t\t   (recur (inc i) (cons i acc))))]\r\n    (concat (filter prime? nums) [2])))\r\n\r\n(primes (Integer/parseInt (first *command-line-args*)))\r\n</pre>\n<p>Immediately we can see that the clojure code is much more concise; which code is more readable is a bit harder to say. Personally I'd lean towards javascript for readability, but there is a certain level of elegance in lisp.</p>\n<p>This is the code I used to run the tests. You can see for each run a process is spawned and the cleanest possible time is measured. This helps us avoid any memory leaking issues that could slow down the code, but introduces a small penalty for spawning processes. I'm assuming this penalty is constant.</p>\n<pre lang=\"javascript\" line=\"1\">\r\n\r\nvar spawn = require('child_process').spawn;\r\n\r\nvar N = 100000000;\r\n\r\nvar runs = function (n, i, avg) {\r\n    var i = i || 0;\r\n    var avg = avg || 0;\r\n\r\n    var before = (new Date()).getTime();\r\n    var child = spawn('node', ['many-primes.js', N], {cwd: __dirname});\r\n    //var child = spawn('clj', ['many-primes.clj', N], {cwd: __dirname});\r\n\r\n    child.on(\"exit\", function (code) {\r\n\tvar time = ((new Date()).getTime()-before)/1000;\r\n\r\n\tconsole.log(time);\r\n\tif (i < n) {\r\n\t    runs(n, i+1, avg+time);\r\n\t}else{\r\n\t    console.log(avg/n);\r\n\t}\r\n    });\r\n}\r\n\r\nruns(5)\r\n</pre>\n<h2>The results</h2>\n<div style=\"width: 605px\" class=\"wp-caption alignnone\"><img alt=\"\" src=\"http://i.imgur.com/BkTG0.png\" title=\"The raw data\" width=\"595\" height=\"59\" /><p class=\"wp-caption-text\">Raw data shows that runtimes for anything under 1M are pretty reasonable.</p></div>\n<div style=\"width: 441px\" class=\"wp-caption alignnone\"><img alt=\"\" src=\"http://i.imgur.com/22s7m.png\" title=\"First graph\" width=\"431\" height=\"315\" /><p class=\"wp-caption-text\">In the first graph we can see how horribly exponential my solution is.</p></div>\n<div style=\"width: 399px\" class=\"wp-caption alignnone\"><img alt=\"\" src=\"http://i.imgur.com/qXPSS.png\" title=\"Second graph\" width=\"389\" height=\"309\" /><p class=\"wp-caption-text\">Here we can notice the initial penalty of compiling clojure</p></div>\n<p>As you can see, looking for primes is a bit of an exponential problem. However, if you have a linear solution I would absolutely love to see it.</p>\n<p>The more interesting part is how differently exponential it is with the same algorithm in different runtime environments. I have no idea what's going on with node.js on those large datasets. Both algorithms seem to be running on a nice exponential curve and then BAM, shoots through the roof and even dies completely. Whereas Clojure's biggest problem with the small datasets is apparently the run-up time itself and then it continues growing on a predictable exponential curve.</p>\n<h2>Conclusion</h2>\n<p>My conclusion from all this is that despite everything, despite all the awesome optimiziations the V8 engine does, clojure is simply more appropriate when you're doing serious calculation on serious datasets. Go ahead and use node.js for everything nice and small, it's absolutely magnificent there.</p>\n<p>The next relevant test would probably input/output since that is supposedly node's strongpoint, but something tells me the story will be similar. Node better for small bursts of activity and clojure better for more sustained hardcore work.</p>\n<p>Let me know what you think, where did I fuck up this test?</p>\n<p>PS: I know clojure has type hinting, they proved to slow down the code.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"d9bd5c7f-8c65-5378-a818-805b11a9450f"}}