{"data":{"wordpressPost":{"title":"Advent of Code Day 19 â€“ A Series of Tubes","content":"<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/3f_f1T7kaK4?feature=oembed\" frameborder=\"0\" gesture=\"media\" allow=\"encrypted-media\" allowfullscreen></iframe></p>\n<p>Advent of Code Day 19 was one of those light, easy challenges. Just hard enough to make you think a little, easy enough to solve in 20 minutes.</p>\n<p>This could make a great interview question ðŸ¤”</p>\n<p>The gist of the problem is this:</p>\n<ul>\n<li>you are given an ASCII drawing of a path</li>\n<li>you have to follow it to the end</li>\n<li>collect letters as you pass them</li>\n<li>print them in sequence</li>\n</ul>\n<p>For a map like this ðŸ‘‡</p>\n<pre><code>     |          \n     |  +--+    \n     A  |  C    \n F---|----E|--+ \n     |  |  |  D \n     +B-+  +--+ \n</code></pre>\n<p>Your result is <code>ABCDEF</code>.</p>\n<p>The real map isâ€¦ bigger. 201&#215;201 characters. Or at least mine was.</p>\n<p>Far too large to trace with your finger. I mean, you <em>could</em> if you had the patience of a gnat, but that&#8217;s why the 2nd part of today&#8217;s puzzle asks you to count the number of steps.</p>\n<img class=\"alignnone size-full wp-image-7984\" src=\"https://swizec.com/blog/wp-content/uploads/2017/12/carbon-2.png\" width=\"1634\" height=\"1226\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/12/carbon-2.png 1634w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-2-300x225.png 300w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-2-768x576.png 768w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-2-1024x768.png 1024w\" sizes=\"(max-width: 1634px) 100vw, 1634px\" />\n<p>Ain&#8217;t nobody got the patience to count the number of steps by hand.</p>\n<p>Luckily coding up a solution in Python is pretty simple.</p>\n<p>You take a current position, <code>pos</code>, that starts at the only <code>|</code> in top row â€“&nbsp;your entry point. And a vector <code>(vy, vx)</code> pointing downwards, <code>(1, 0)</code>, and you travel through the map.</p>\n<p>If you encounter a corner, <code>input[y][x] == '+'</code>, you change direction â€“&nbsp;the movement vector. If so far you were traveling vertically, then you go either left or right depending on which direction has inputs. If you were traveling horizontally, then you switch to vertical.</p>\n<pre lang=\"python\">\n        if input[y][x] == \"+\":\n            if vy != 0:\n                # go left or right\n                if input[y][x-1] == \"-\" or input[y][x-1] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                    vy = 0\n                    vx = -1\n                else:\n                    vy = 0\n                    vx = 1\n            else:\n                # go up or down\n                if input[y-1][x] == \"|\" or input[y-1][x] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                    vy = -1\n                    vx = 0\n                else:\n                    vy = 1\n                    vx = 0\n</pre>\n<p><code>vy</code> being different than <code>0</code> tells you that you&#8217;ve been moving vertically. If there&#8217;s something to the left, you go there; otherwise, you go the opposite direction.</p>\n<p>Same approach for the horizontal change.</p>\n<p>When you encounter a letter, you add it to the list of letters.</p>\n<pre lang=\"python\">\n        elif input[y][x] not in [\"-\", \"|\"]:\n            letters.append(input[y][x])\n</pre>\n<p>In the end, you make sure to update your current position and steps counter.</p>\n<pre lang=\"python\">\n        steps += 1\n        pos = (y + vy, x + vx)\n</pre>\n<p>That applies the movement vector to our position <code>pos</code> and increments the <code>steps</code> counter. Easy ðŸ‘Œ</p>\n<p>When we put it all together and add a loop, the path following implementation looks like this ðŸ‘‡</p>\n<pre lang=\"python\">\ndef followpath(input):\n    linelen = max(len(line) for line in input.split(\"\\n\"))\n    input = [line.ljust(linelen, \" \") for line in input.split(\"\\n\") if len(line) > 0]\n\n    pos = (0, input[0].index(\"|\"))\n    vx = 0\n    vy = 1\n    letters = []\n    steps = 0\n\n    print linelen, len(input)\n\n    while True:\n        y, x = pos\n\n        if y < 0 or y >= len(input) or x < 0 or x >= linelen or input[y][x] == \" \":\n            return steps, letters\n\n        if input[y][x] == \"+\":\n            if vy != 0:\n                # go left or right\n                if input[y][x-1] == \"-\" or input[y][x-1] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                    vy = 0\n                    vx = -1\n                else:\n                    vy = 0\n                    vx = 1\n            else:\n                # go up or down\n                if input[y-1][x] == \"|\" or input[y-1][x] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                    vy = -1\n                    vx = 0\n                else:\n                    vy = 1\n                    vx = 0\n        elif input[y][x] not in [\"-\", \"|\"]:\n            letters.append(input[y][x])\n        \n        steps += 1\n        pos = (y + vy, x + vx)\n</pre>\n<p>We prep the input, start an infinite loop, break out of the loop when we fall outside the <code>input</code> field or hit an empty spot (meaning line is over), and use our path-following logic to move around.</p>\n<p>Eventually, we reach the end of the line and return our result: The number of steps and the sequence of letters encountered.</p>\n<p>You can see <a href=\"https://github.com/Swizec/advent-of-code-2017/blob/master/19.py\">everything on Github</a>.</p>\n<p>That was fun ðŸ¤™</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"f6389396-10e3-5820-b7cf-3b23e24d61a1"}}