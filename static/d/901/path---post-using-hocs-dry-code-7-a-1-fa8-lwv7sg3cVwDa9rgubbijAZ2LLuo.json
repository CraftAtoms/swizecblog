{"data":{"wordpressPost":{"title":"Using HOCs to DRY up your code","content":"<p>Higher order components â€“ HOCs â€“ are one of the best ways to improve your React code. When you see a lot of components sharing similar code, it&#39;s time for a HOC.</p>\n<p>A HOC used as a decorator can turn a 36-line component like this:</p>\n<pre lang=\"javascript\">\n@inject('configStore') @observer\nclass Toolbox extends Component {\n    constructor(props) {\n        super(props);\n\n        autorun(this._render.bind(this));\n    }\n\n    componentDidUpdate() { this._render() }\n    componentDidMount() { this._render() }\n    componentWillUnmount() { this._cleanup() }\n\n    _init() {\n        this.backbone = new ToolboxView({\n            currentUser: new Backbone.Model(toJS(this.props.configStore.currentUser)),\n            pages: []\n        });\n    }\n\n    _render() {\n        this._cleanup();\n        this._init();\n        this.backbone.setElement(this.refs.anchor).render();\n    }\n\n    _cleanup() {\n        if (this.backbone) {\n            this.backbone.undelegateEvents();\n        }\n    }\n\n    render() {\n        return (\n            <div ref=\"anchor\"></div>\n        );\n    }\n}\n</pre>\n<p>Into an 11-line beauty like this:</p>\n<pre lang=\"javascript\">\n@inject('configStore') @observer @backbone(ToolboxView)\nclass Toolbox extends Component {\n    backboneProps = {\n        currentUser: new Backbone.Model(toJS(this.props.configStore.currentUser)),\n        pages: []\n    }\n\n    render() {\n        return this.anchor;\n    }\n}\n</pre>\n<img src=\"http://swizec.com/blog/wp-content/uploads/2016/12/1282786204310.jpg\" alt=\"1282786204310\" class=\"alignnone size-full wp-image-7299\" srcset=\"https://swizec.com/blog/wp-content/uploads/2016/12/1282786204310.jpg 522w, https://swizec.com/blog/wp-content/uploads/2016/12/1282786204310-300x229.jpg 300w\" sizes=\"(max-width: 522px) 100vw, 522px\" />\n<p>This is a Backbone integration HOC based on <a href=\"https://swizec.com/blog/backbone-%E2%86%92-react-handling-state-with-mobx/swizec/7051\">my approach to integrating React, MobX, and Backbone</a> from a few months ago. It takes away all the integration boilerplate and lets you focus on the important stuff â€“ setting data for the old Backbone View and potential rendering embelishments.</p>\n<p>The same approach <em>should</em> work with any component-based library like Preact, Inferno, and Vue, but I haven&#39;t tried yet.</p>\n<p>So how does this work? How did a HOC replace 25 lines of JavaScript with a single <code>@backbone(ToolboxView)</code> decorator? Let me show you.</p>\n<h2>How HOCses improve your code</h2>\n<p>The first step is to take everything generic out of your component and put it into a new one. This will be what your HOC <em>does</em>.</p>\n<p>If you can&#39;t tell what&#39;s generic, wait until you have two components that look similar. Any boilerplate they share is a good candidate for a HOC.</p>\n<p>In our example that boilerplate is:</p>\n<ul>\n<li>the constructor that sets up <code>autorun</code></li>\n<li>functions keeping Backbone and React render in sync</li>\n<li>all the Backbone rendering things</li>\n<li>an anchor element for Backbone to hook into</li>\n</ul>\n<p>Sooooâ€¦ everything. ?</p>\n<p>We&#39;re leaving React&#39;s <code>render()</code> method out of the HOC to give consumers better flexibility, and we&#39;re adding the ability to set Backbone params. Those are important.</p>\n<h3>Step 1: the core of a HOC</h3>\n<p>The core of our HOC is a React (or Preact or Inferno) component:</p>\n<pre lang=\"javascript\">\nclass Backbone extends WrappedComponent {\n    constructor(props) {\n        super(props);\n\n        autorun(this._render.bind(this));\n    }\n\n    componentDidUpdate() { \n        if (super.componentDidUpdate) {\n              super.componentDidUpdate();\n        }\n        this._render(); \n        }\n    componentDidMount() {\n        this._render();\n        if (super.componentDidMount) {\n            super.componentDidMount();\n        }\n    }\n    componentWillUnmount() { \n        if (super.componentWillUnmount) {\n                super.componentWillUnmount();\n        }\n        this._cleanup();\n        }\n\n    _init() {\n        this.backbone = new BackboneView(\n            Object.assign({},\n                                        this.props,\n                                        this.backboneProps\n                    ));\n    }\n\n    _render() {\n        this._cleanup();\n        this._init();\n        this.backbone.setElement(this.refs.anchor).render();\n    }\n\n    _cleanup() {\n        if (this.backbone) {\n            this.backbone.undelegateEvents();\n        }\n    }\n\n    get anchor() {\n        return (<div ref=\"anchor\" />)\n    }\n}\n</pre>\n<p>Looks almost the same as <a href=\"https://swizec.com/blog/backbone-%E2%86%92-react-handling-state-with-mobx/swizec/7051\">our original implementation</a>.</p>\n<p><code>constructor</code> sets up <code>autorun</code> so our component can react to MobX store changes. This automatically turns our Backbone&#39;d components into observers, but I like to include the <code>@observer</code> call when using them anyway. Helps with readability ðŸ™‚</p>\n<p>The <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> methods ensure our Backbone View gets rendered, re-rendered, and cleaned up when appropriate. Each method includes a hook for users of our HOC to add their own lifecycle logic. I haven&#39;t really had a use for this yet, but I think it&#39;s a good idea to have.</p>\n<p><code>_init</code>, <code>_render</code>, and <code>_cleanup</code> handle the actual Backbone stuff. They&#39;re helper methods that make it easier to reuse bits in different React lifecycle methods.</p>\n<p><code>get anchor</code> is like a <code>render()</code> method but not. We <em>could</em> render here, but that would reduce flexibility. Instead, we give consumers an easy way to render the Backbone anchor point wherever.</p>\n<h3>Step 2: Making it a HOC</h3>\n<p>To turn this component into a real HOC, we have to wrap it in a function. You could call this function an <a href=\"https://en.wikipedia.org/wiki/Factory_method_pattern\">class factory</a> because that&#39;s what it is. It creates classes.</p>\n<pre lang=\"javascript\">\nfunction (WrappedComponent) {\n        return // code from above\n}\n</pre>\n<p>Yep, a function that takes a component to be wrapped and returns a class extending said component. That really <em>is</em> it.</p>\n<p>Congratulations, you have made a HOC.</p>\n<p><strong>Caveat:</strong> we use <code>super</code> when to invoke a method on the parent class â€“ the wrapped component â€“ and <code>this</code> when we access instance properties <em>even if they are defined on the parent</em>. Both your wrapped component and your HOC core component share the same <code>this</code> reference.</p>\n<h3>Step 3: Adding more arguments</h3>\n<p>Now here&#39;s a tricky part. Adding more arguments â€“&nbsp;like which Backbone View to wrap with â€“ requires currying. At least it does if you want to use your HOC as a decorator like I did.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Currying\">Currying</a> means that instead of having functions with multiple arguments, we create a composition of single-argument functions. I&#39;m not entirely certain <em>why</em> currying is all the rage, but it makes many approaches to functional programming easier to use.</p>\n<p>Our HOC then looks like this:</p>\n<pre lang=\"javascript\">\nfunction backbone(BackboneView) {\n        return function (WrappedComponent) {\n                return class Backbone extens WrappedComponent {\n                        // your HOC core\n                }\n        }\n}\n</pre>\n<p>Now the logic inside your HOC can use <code>BackboneView</code> to decide which component to use. This means that you don&#39;t need a new HOC for every Backbone View you want to make available in React. Wonderful.</p>\n<h3>Step 4: Using it</h3>\n<p>With all that done, your HOC is ready to use. In our case, we use it for rendering old Backbone Views in React code.</p>\n<p>Using it looks like this:</p>\n<pre lang=\"javascript\">\n@inject('configStore') @observer @backbone(ToolboxView)\nclass Toolbox extends Component {\n    backboneProps = {\n        currentUser: new Backbone.Model(toJS(this.props.configStore.currentUser)),\n        pages: []\n    }\n\n    render() {\n        return this.anchor;\n    }\n}\n</pre>\n<p><code>backboneProps</code> lets us define parameters fed into the Backbone View â€“ the HOC accesses them as <code>this.backboneProps</code>.</p>\n<p>Inside <code>render()</code>, we use <code>this.anchor</code> anywhere we want to place the anchor point for our Backbone View. In this case we&#39;re rendering just that, but in others we might want to wrap it with useful markup that makes it look better in its new context.</p>\n<h2>Conclusion</h2>\n<p>HOCs are great, and I wish I started using them earlier. There&#39;s definitely going to be a chapter about HOCses in the <a href=\"http://swizec.com/reactd3js/\">new version of React+D3</a>. Some prime targets for this stuff in there.</p>\n<p>And yes, you <em>can</em> use them without decorators. It&#39;s just not as pretty. Something like this:</p>\n<pre lang=\"javascript\">\nclass MyThing extends Component {\n    // stuff\n}\n\nexport backbone(OldView)(MyThing);\n</pre>\n<p>Now how would I make them work with functional stateless components? ? Should be just function composition, right?</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"af7a91f6-9913-5b85-baa1-3516c3094f00"}}