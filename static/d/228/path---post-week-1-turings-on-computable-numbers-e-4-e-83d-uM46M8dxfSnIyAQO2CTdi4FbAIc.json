{"data":{"wordpressPost":{"title":"Week 1: Turing&#8217;s On computable numbers","content":"<p><em>[This post is part of an ongoing challenge to understand 52 papers in 52 weeks. You can read previous entries, <a href=\"http://swizec.com/blog/category/52-papers-in-52-weeks\">here</a> or get notified of new posts by <a href=\"http://swiz.ec/52papers-list\">email</a>]</em></p>\n<div style=\"width: 650px\" class=\"wp-caption aligncenter\"><a href=\"http://www.flickr.com/photos/90270569@N03/8235850748/in/photolist-dxLTuG-cszLeN-bCeymE-dy57vs-d5J679-bxfU1U-cU5Ncs-8NmcHu-cYc2ZW-8RvhhC-9z7TQW-cbA2tQ-czYEnw-9eejjd-9ebf7i-9eej4J-cqPSFJ-cqPSQd-cPmeY1-cqPSV5-9eeiUG-9ebeYi-9ebfbX-9eejDY-9ebftH-9eejWU-eHGDoC-a6GxEb-a6DG5x-8NiiMe-ekQTas-8Nmwmw-gnwwjK-aKtpdg-8NhkE2-8Nh7Yk-7Gr5KZ-8Nhg8B-8Nh48c-8Nh3fz-8Nka4J-8Nk7vW-8Nkp5o-8NhtS2-ga3RFt-8NkBiu-8Nhtat-8NkAxE-8Nhx62-8NkpJY-8NhuDa\"><img alt=\"Turing's Bombe machine\" src=\"http://farm9.staticflickr.com/8070/8235850748_58418329ec_z.jpg\" width=\"640\" height=\"480\" /></a><p class=\"wp-caption-text\">Turing&#8217;s Bombe machine</p></div>\n<p>What better way to start the 52 papers challenge off than the paper most computer science is based on &#8211; <a class=\"zem_slink\" title=\"Alan Turing\" href=\"http://en.wikipedia.org/wiki/Alan_Turing\" target=\"_blank\" rel=\"wikipedia\">Alan Turing&#8217;s</a> <a href=\"http://classes.soe.ucsc.edu/cmps210/Winter11/Papers/turing-1936.pdf\">On Computable Numbers, With an Application to the Entscheidungsproblem</a>?</p>\n<p>There are two main takeaways from this paper:</p>\n<ul>\n<li>a hypothetical machine can be constructed that can solve any solvable problem using simple rules (turing machine)</li>\n<li>the entscheidungsproblem is unsolvable in the general case</li>\n</ul>\n<p>The third, despite being discussed off-handedly in the paper, has massive implications as well: Church&#8217;s lambda-calculus is no more or less powerful than turing machines. What <a class=\"zem_slink\" title=\"Turing machine\" href=\"http://en.wikipedia.org/wiki/Turing_machine\" target=\"_blank\" rel=\"wikipedia\">Turing</a> states as &#8220;obvious&#8221; later developed into the <a class=\"zem_slink\" title=\"Church–Turing thesis\" href=\"http://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis\" target=\"_blank\" rel=\"wikipedia\">Church-Turing thesis</a>, which stipulates that all systems of computation are equal in their power. If a problem can be solved by one system, then it can be solved in another, and vice-versa.</p>\n<p>Despite many attempts to find stronger computation system, all have eventually been proven to be equal to all the rest. If memory serves, the jury&#8217;s still out on quantum computation.</p>\n<p>But let&#8217;s start from the beginning.</p>\n<h2>The Entscheidungsproblem</h2>\n<p>In 1928 Hilbert posed a challenge to the mathematical community &#8211; create an algorithm that takes as input a statement in <a class=\"zem_slink\" title=\"First-order logic\" href=\"http://en.wikipedia.org/wiki/First-order_logic\" target=\"_blank\" rel=\"wikipedia\">first-order logic</a> (with possibly a finite number of additional axioms) and answers <em>&#8220;Yes&#8221;</em> or <em>&#8220;No&#8221;</em> whether it is universally valid. That is, valid in every structure that can be translated into the basic axioms.</p>\n<p>Having such an algorithm would mean that there is no such thing as an <a class=\"zem_slink\" title=\"Undecidable problem\" href=\"http://en.wikipedia.org/wiki/Undecidable_problem\" target=\"_blank\" rel=\"wikipedia\">unsolvable problem</a>. You could construct an algorithm to solve any problem you can state using first-order logic &#8211; logic statements with predicates.</p>\n<p><code>∀x(C(x)→¬D(x))</code>, where <code>C(x)</code> means &#8220;x is a cat&#8221;, and <code>D(x)</code> means &#8220;x is a dog&#8221;. The statement then reads <em>&#8220;for every x, if x is a cat then x is not a dog&#8221;</em></p>\n<p>Can we have an algorithm that tells us whether this statement is universally valid and nothing can be both a dog and a cat?</p>\n<p>To answer the question Turing had to begin by formally defining both computability and algorithm.</p>\n<h2>Computing machines</h2>\n<p>Turing states that <a class=\"zem_slink\" title=\"Computable number\" href=\"http://en.wikipedia.org/wiki/Computable_number\" target=\"_blank\" rel=\"wikipedia\">computable numbers</a> are those numbers whose decimals can be computed in finite time. His justification is that human minds are limited and a number that takes infinitely long to compute isn&#8217;t very useful.</p>\n<p>He bases his computational machine on the model of a person solving a problem.</p>\n<ul>\n<li>a <strong>machine</strong> is a device that can have a finite number of m-configurations or states (think of this as memory)</li>\n<li>the machine will be provided a <strong>tape</strong>, which is infinite and divided into squares that can hold a single symbol (the equivalent of paper)</li>\n<li>a symbol can be <strong>scanned</strong> from a square or <strong>printed</strong> to a square (the equivalent of reading and writing)</li>\n</ul>\n<p>An <strong>automatic machine</strong> (a-machine) is a machine whose motion at each stage is completely determined by the configuration. When an a-machine prints only two types of symbols, where first type (figures) consists only of <code>0</code> and <code>1</code> and the second type are help symbols, it is called a <strong>computing machine</strong>.</p>\n<p>The <strong>complete configuration</strong> of the machine is completley defined by its current m-configuration, the scanned square&#8217;s number and the <a class=\"zem_slink\" title=\"Complete sequence\" href=\"http://en.wikipedia.org/wiki/Complete_sequence\" target=\"_blank\" rel=\"wikipedia\">complete sequence</a> on the tape. What it does next is called a <strong>move</strong> (m-configuration change, printing, changing the active square).</p>\n<p>A <strong>computable sequence or number</strong> is any sequence produced by a circle-free computing machine. That is, a machine that reaches its end state in a finite amount of time.</p>\n<p>Turing used a table format to define examples of machines where the first column defines the m-configuration, then the other columns specify actions based on the read symbol and finally which m-configuration the machine should transition to.</p>\n<p>Personally I found the graphical notation we used at college easier to follow.</p>\n<img alt=\"Multiplication Turing machine\" src=\"https://draftin.com:443/images/2798?token=WDkh2eoUEicN37PWHEVzwnBVxEuA5xsna_6zykKr1OBl9FbVkfTfwYFP_peLaLS5TZTu-rs1xzPPJqHRigpeFqo\" />\n<p>One interesting convention Turing establishes is only writing solutions on alternative squares called F-squares and the other squares, called E-squares, are used as a sort of scratch pad. We didn&#8217;t use this convention, but it can help you write shorter algorithms.</p>\n<p>The introduction of <strong>m-functions</strong> (machines expressed as functions) is more important since it means you can define a computing machine in terms of other computing machines. He called these &#8220;skeleton tables&#8221; because they were the basis for writing more advanced machines.</p>\n<p>An m-function is defined as a triplet <code>f(q, r, x)</code>, where q is the initial state, r the final state, and x the first symbol to start the function on. These functions can be nested and combined at will, but it is important to always write out <em>exactly</em> what is the machine each function represents.</p>\n<h2>Enumeration of computable sequences</h2>\n<p>To make working with computing machines even easier, Turing proposes they should be enumerated. Describing whole machines as numbers will be particularly useful when we want machines to process other machines as input.</p>\n<p>The first step is standardising notation: m-configurations will be q<sub>i</sub>, with q<sub>1</sub> always being first. Symbols will be S<sub>j</sub>, in particular <em>blank = S<sub>0</sub>, 0 = S<sub>1</sub>, 1 = S<sub>2</sub></em>.</p>\n<p>Each line of the table can then form an expression like q<sub>i</sub>S<sub>j</sub>PS<sub>k</sub>Lq<sub>m</sub>, which reads <em>&#8220;After reading S<sub>j</sub> in state q<sub>1</sub>, print S<sub>k</sub>, move left, and change to state q<sub>m</sub>&#8220;</em>. We can write down all lines of the tables into a single expression where lines are marked with semicolons (q<sub>i</sub>S<sub>j</sub>PS<sub>k</sub>Lq<sub>m</sub>;q<sub>i</sub>S<sub>j</sub>PS<sub>k</sub>Rq<sub>m</sub>;&#8230;)</p>\n<p>If we then agree to codify all q<sub>i</sub> as the letter <em>A</em> repeated <em>i</em> times, and S<sub>j</sub> as <em>D</em> followed by j <em>C</em>&#8216;s, we can write down every machine with a sequence of 5 letters (A, C, D, L, R, N) and semicolon &#8211; the <strong>standard description</strong>.</p>\n<p>We can further replace these with numbers; <em>A</em> is <em>1</em>, <em>C</em> is <em>2</em>, &#8230;, <em>;</em> is 7, to come up with a <strong><a class=\"zem_slink\" title=\"Description number\" href=\"http://en.wikipedia.org/wiki/Description_number\" target=\"_blank\" rel=\"wikipedia\">description number</a></strong> <em>n</em>, which describes a computing machine uniquely. A machine described by <em>n</em> will be called <code>M(n)</code>.</p>\n<p>Since a computable sequence can be described by at least one description number, but a description number can only correspond to one computable sequence, it follows that computable sequences and numbers are enumerable. (can be listed)</p>\n<h2>The universal computing machine</h2>\n<p>The universal machine is a machine that can compute any computable sequence. When given as input some standard description of machine <em>M</em>, the universal machine <em>U(M)</em> will compute the exact same sequence as <em>M</em>.</p>\n<p>Universal machines are a particularly important tool in solving the entscheidungsproblem, because Turing will be able to rely on a single tool to talk about all computable numbers.</p>\n<p>It is somewhat obvious that given a machine <em>M</em> you can construct a machine <em>M&#8217;</em> that would print all of its complete configurations in the standard form on a tape. From that we can assume that there is enough room left on the tape to use the rules of <em>M</em> to perform its computations.</p>\n<p>Turing goes on to fully write down the description table of the universal machine, which I will not do here. Instead let me show you a <a href=\"http://swizec.com/blog/a-turing-machine-in-133-bytes-of-javascript/swizec/3069\">Turing machine I wrote in 133 bytes of Javascript</a>. Another example of such a machine is your browser (which executes web programs) and your computer (which uses a program to execute other programs).</p>\n<p>The important thing to remember is that universal machines are no more powerful as normal computing machines and do not increase the extent of computable numbers. This is obvious when you think of them as simulators of computing machines.</p>\n<h2>Can a machine tell if a machine is circle-free?</h2>\n<p>Turing uses the process of diagonalization to show that we cannot construct a process that will take the standard description of a machine and tell us whether it is circle-free or not. That is to say, whether it ever produces a result.</p>\n<p>This is otherwise known as the halting problem.</p>\n<p>Let&#8217;s say we can construct a process <em>D</em> that will take a standard description and mark it with <em>u</em>, if it represents a circular machine, and with <em>s</em> if the machine is circle-free. If we take <em>D</em> and <em>U</em> (universal machine), we can create a process <em>N</em>, which computes sequence β, whose n-th figure is φ<sub>n</sub>(n).</p>\n<p><em>N</em> first evaluates writes down integers up to <code>N-1</code> and tests them with <em>D</em>. Some have been found to be description numbers of circle-free machines. Then the machine tests the number <em>N</em>. If it is the description number of a circle-free machine then <em>R(N)</em> equals <code>1+R(N-1)</code> and the first <em>R(N)</em> figures of the sequence for <em>N</em> are tested and written down as parts of sequence β. Otherwise the machine goes on to step <code>N+1</code>.</p>\n<p>We can see that <em>N</em> is circle-free &#8211; each section of β is computed in finite steps, because we assumed <em>D</em> is computable in a finite number of steps.</p>\n<p>But let&#8217;s say <em>K</em> is the description number of <em>N</em>. We know <em>K</em> is satisfactory since we assumed <em>N</em> is finite, but for <em>N</em> to verify this it would have to compute the first <em>R(K-1)+1</em> figures, then for the <em>R(K)</em>-th figure it would have to to repeat it all over again.</p>\n<p>Thus it gets stuck in a loop and we reached a paradox. Therefore there can be no such machine <em>D</em>.</p>\n<p>This can further be expanded to show that there can be no such machine that determines whether a given machine will ever print a particular symbol. Turing gives a formal proof, but I will appeal to your intuition: Until the symbol appears, how do you know if the machine is stuck in a loop, or you have to wait a bit longer?</p>\n<h2>Possible processes carried out in computing a number</h2>\n<p>Any proof showing that computable numbers as defined in Turing&#8217;s paper encompass all numbers naturally regarded as computable, would boil down to an appeal to intuition, which isn&#8217;t mathematically interesting, so Turing just assumes this is the case. Computer science has so far been unable to prove this is not, in fact, the case.</p>\n<p>Once you assume this much, one of the more interesting consequences is that if there is a general process to prove that a function in Hilbert calculus is provable, then it can be carried out by a machine. This is what Turing is building towards in this whole paper &#8211; proving the entscheidungsproblem.</p>\n<p>There will be three types of arguments made:</p>\n<ul>\n<li>a) a direct appeal to intuition</li>\n<li>b) a proof of the equivalence of two definitions</li>\n<li>c) giving examples of large classes of computable numbers</li>\n</ul>\n<h3>I [type a]</h3>\n<p>Computation is normally done by writing symbols on paper. We can assume this paper is split up into squares and it is trivial to imagine calculating on one-dimensional instead of two-dimensional paper. It is also trivially to imagine that we can only use a finite number of symbols before running out of space in each individual square.</p>\n<p>Not that that matters much since we can always write down more than one symbol to represent things that don&#8217;t fit on a single square.</p>\n<p>It can further be assumed that at any stage of the calculation the next step is wholly determined by the sequence of symbols on the paper and the computer&#8217;s state of mind. Since we can only make a machine so big, the number of states of mind must be finite, but we can always replace missing states with writing more symbols on the paper.</p>\n<p>Therefore it is possible to simplify any process of computation down to the most basic units that cannot reasonably be torn apart further:</p>\n<ul>\n<li>a) changing the symbol on one of the observed squares</li>\n<li>b) changing one square&#8217;s symbol into a different square&#8217;s symbol</li>\n</ul>\n<p>Either of these can involve changing the state of mind.</p>\n<p>Such a machine can obviously be constructed, and will perform similarly to the computing machines defined earlier.</p>\n<h3>II [type b]</h3>\n<p>If we systematise the notation of Hilbert&#8217;s calculus, we can construct a machine <em>K</em> that will list all provable formulae of the calculus.</p>\n<p>I don&#8217;t fully grasp the proof of equivalence given here, but it boils down to having a sequence <em>a</em>, a function <em>G<sub>a</sub>(x)</em> which means &#8220;The x-th figure of <em>a</em> is 1&#8243; and its negative &#8211; &#8220;The x-th figure of <em>a</em> is 0&#8243;. If we then also have <em>N(x)</em>, which means that x is non-negative, and <em>F(x,y)</em> meaning <em>y=x+1</em>, then we can have a formula <em>U</em>, which defines <em>a</em>.</p>\n<p><em>U</em> must also include the necessary Peano axioms. Essentially <em>U</em> must behave as we expect functions to behave. U(x) equals U(x), if U(x) equals U(y), then x equals y and so on.</p>\n<p>Then for each <em>n</em> either <em>A<sub>n</sub></em> (U&amp;F<sup>(n)</sup> → G<sub>n</sub>(u<sup>(n)</sup>)) or <em>B<sub>n</sub></em> (U&amp;F<sup>n</sup> → ¬G<sub>n</sub>(u<sup>(n)</sup>)) will be provable.</p>\n<p>Where <em>F<sup>(n)</sup></em> stands for *F(u, u&#8217;) &amp; F(u&#8217;, u&#8221;) &amp; ..F(u<sup>(n-1)</sup>, u<sup>(n)</sup>).</p>\n<p>We can then easily construct a machine <em>K<sup>a</sup></em> that will compute <em>a</em>, which can be modified into a more general <em>K</em>.</p>\n<p>Essentially the machine must go through formulae that satisfy <em>U</em> and compare them to <em>A<sub>n</sub></em> and <em>B<sub>n</sub></em> then print either 0 or 1 on the tape accordingly. Eventually the machine will write out the whole sequence <em>a</em>.</p>\n<h2>Examples of large classes of computable numbers</h2>\n<p>Turing begins here with a description of a computable function of integral variables, then lists some theorems of computability and proves two of them. We won&#8217;t go into the proofs, but a rigorous definition of a computable function is useful.</p>\n<p>Let&#8217;s say γ is a computable sequence that prints 0 infinitely often, and <em>n</em> is an integer. Then let&#8217;s define ε(γ, n) to be the number of 1&#8217;s between n-th and (n+1)-th 0 of γ. Then φ(n) is computable if, for all <em>n</em> and some γ, φ(n) = ε(γ, n).</p>\n<p>We can&#8217;t define computable functions of all real numbers, since there is no general way to write down a real number, but a class of computable numbers is, for instance <em>a<sub>n</sub> = tan(π(γ<sub>n</sub> &#8211; 1/2))</em>. As long as γ<sub>n</sub> doesn&#8217;t equal 0 or 1, in which case a<sub>n</sub> will be 0.</p>\n<p>There are 10 theorems of computability.</p>\n<ol>\n<li>a computable function of a computable function is computable</li>\n<li>any function defined recursively in terms of computable functions is computable</li>\n<li>if <em>φ(m, n)</em> is computable function of two integers, then <em>φ(n, n)</em> is computable</li>\n<li>if <em>φ(n)</em> is a computable function whose value is always 0 or 1, then the sequence whose n-th figure is <em>φ(n)</em> is computable</li>\n<li>is a reconstruction of Dedekind&#8217;s theorem using computability instead of real-ness. It states that if <em>G(a)</em> is a propositional function where there exists an α and a β where <em>G(α) &amp; ¬G(β)</em> (G of α and not G of β) and <em>G(α) &amp; (¬G(β)) → (α&lt;β)</em> (if G of α and not G of β, then α is less than β, then there is a computable limit to the section where a computable number falls. This means a computable bounded sequence of computable numbers might not have a computable limit.</li>\n<li>if <em>α &lt; β</em> and <em>φ(α) &lt; 0 &lt; φ(β)</em> where φ is a computable continuous increasing function, then there exists a number that <em>φ(n) = 0</em> and <em>α &lt; n &lt; β</em></li>\n<li>a power series whose coefficients form a computable sequence of computable numbers is computably convergent at all computable points inside its interval of convergence</li>\n<li>the limit of a computably convergent sequence is computable</li>\n<li>the limit of a uniformly computably convergent computable sequence of computable functions is a computable function</li>\n<li>the sum of a power series whose coefficients form a computable sequence is a computable function inside its interval of convergence</li>\n</ol>\n<p>From these theorems we arrive at some interesting results.</p>\n<p>Using 8 we can deduce that π is computable where <em>π = 4(1-1/3+1/5-&#8230;). From *e = 1+1/2!+1/3!+&#8230;</em> we can see that e is computable.</p>\n<p>Using 5 we can show that all real algebraic numbers are computable and with 6 and 10 we can deduce that the real zeros of the Bessel function (a famous differential equation) are computable.</p>\n<h2>Application to the Entscheidungsproblem</h2>\n<p>After constructing all this scaffolding, Turing finally got to the ultimate point of this paper &#8211; answering the entscheidungsproblem.</p>\n<p>He provides the rigorous proof over some three pages, but the basic idea is simple: For each computing machine <em>M</em> we construct a formula <em>Un(M)</em> and show that, if there is a general method for determining whether it is provable, then there is a general method for determining whether <em>M</em> ever prints 0.</p>\n<p>We already know from earlier that there is no such method since we would have to wait infinitely long to make sure.</p>\n<p>Turing then constructs two Lemmas:</p>\n<ol>\n<li>If <em>S<sub>1</sub></em> appears on the tape in some complete configuration of <em>M</em>, then <em>Un(M)</em> is provable.</li>\n<li>If <em>Un(M)</em> is provable, then <em>S<sub>1</sub></em> appears on the tape in some complete configuration of <em>M</em>.</li>\n</ol>\n<p>I don&#8217;t understand the proofs for these two lemmas well enough to provide a summary that doesn&#8217;t introduce errors, so I&#8217;m not going to do that.</p>\n<p>The end result is that the entscheidungsproblem cannot be solved and it is impossible to construct such a machine that would take as input a statement of first-order logic and answer &#8220;Yes&#8221; or &#8220;No&#8221; whether it is universally valid.</p>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" alt=\"Enhanced by Zemanta\" src=\"http://img.zemanta.com/zemified_e.png?x-id=b37ad478-4995-4f24-add0-7f4623ee64d1\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"d0ee2c52-8efc-53ca-bba1-d1a01d14e3bd"}}