{"data":{"wordpressPost":{"title":"Writing a REST client in Haskell","content":"<p>A few days ago I decided to buy some bitcoin. Then I noticed it fluctuates a lot despite a general upwards trend. Hmmm &#8230; if I just bought at the right moment and sold at a different right moment, I could make money fall out of the void!</p>\n<p>I have since lost $5 by playing and gained $30 by leaving it alone. Obviously I suck at this &#8230;</p>\n<p>I know! Let&#8217;s make a bot that does this! A low frequency trading bot, that sounds like fun. And let&#8217;s write it in <a class=\"zem_slink\" title=\"Haskell (programming language)\" href=\"http://haskell.org\" rel=\"homepage\" target=\"_blank\">Haskell</a>, just to keep things interesting. Marrying the strictest of languages with the messiest of resources &#8211; the internet &#8230; what could possibly go wrong?</p>\n<p>First order of business &#8211; a REST client.</p>\n<h2>REST client</h2>\n<p>Before my bot can do any trading and intricate <a class=\"zem_slink\" title=\"Algorithmic trading\" href=\"http://en.wikipedia.org/wiki/Algorithmic_trading\" rel=\"wikipedia\" target=\"_blank\">algorithmic trading</a>, it needs to talk to the marketplace of choice. I picked Bitstamp because they&#8217;re the only ones that let me do this without a US bank account.</p>\n<p>Writing a REST client in most languages is simple. Reading Bitstamp&#8217;s ticker in Python looks like this:</p>\n<pre lang=\"python\">import requests, json\r\n\r\nr = requests.get(\"https://www.bitstamp.net/api/ticker\")\r\nprint json.loads(r.content)\r\n# prints: {u'volume': u'17179.28558844', u'last': u'159.49', u'bid': u'159.49', u'high': u'161.00', u'low': u'139.00', u'ask': u'159.64'}</pre>\n<p>That&#8217;s it. Everything you need for a set of values nicely accessible as a dictionary.</p>\n<p>In Haskell, well in Haskell figuring out how to do that took me all night, then a bit of the morning and finally a helpful tweet from a stranger to tell me just how I was misusing monads.</p>\n<p>First of all, we are going to need a bunch of imports. The ones we <em>really</em> care about are the <em>http-conduit</em> library and the <em>Aeson</em> parser of <a class=\"zem_slink\" title=\"JSON\" href=\"http://json.org/\" rel=\"homepage\" target=\"_blank\">JSON</a> strings. Everything else is there because &#8230; well I&#8217;m not sure actually, but it seems to be necessary, otherwise things don&#8217;t work.</p>\n<pre lang=\"haskell\">{-# LANGUAGE OverloadedStrings #-}\r\n\r\nimport Network.HTTP.Conduit\r\nimport Control.Monad.IO.Class\r\nimport Data.ByteString.Lazy\r\nimport Data.Aeson\r\nimport Data.Attoparsec.Number\r\nimport Control.Applicative\r\nimport Control.Monad.Trans</pre>\n<p>I am not perfectly certain what the OverloadedStrings bit at the top does. It&#8217;s some sort of compiler directive and most haskell libraries I find in the wild tell me I will be a much happier man if I turn it on. Shrug.</p>\n<p>All it takes now is making an <a class=\"zem_slink\" title=\"Hypertext Transfer Protocol\" href=\"http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol\" rel=\"wikipedia\" target=\"_blank\">HTTP request</a> and parsing the response as JSON. Simple, right?</p>\n<p>Well, Haskell is strict and you can&#8217;t just parse things all willy nilly. We need to tell the parser what we expect, what we want to do with the result and what <em>type</em> it&#8217;s going to be. Can&#8217;t just have a bag of stuff! Nope, needs to be a well defined bag of things.</p>\n<pre lang=\"haskell\">data Ticker = Ticker\r\n              { high :: Number,\r\n                last :: Number,\r\n                bid :: Number,\r\n                volume :: Number,\r\n                low :: Number,\r\n                ask :: Number\r\n              } deriving Show</pre>\n<p>Great. We have a <em>Ticker</em> type that has a bunch of numbers and some names. That <em>Show </em>part seems to say that we&#8217;ll be able to print this out to the console. Smashing!</p>\n<p>That&#8217;s not enough though, it is time for some strange hieroglyphics that tell <em>Aeson</em> how exactly parsing works.</p>\n<pre lang=\"haskell\">instance FromJSON Ticker where\r\n  parseJSON (Object v) = Ticker \r\n                         v .: \"high\" \r\n                         v .: \"last\" \r\n                         v .: \"bid\" \r\n                         v .: \"volume\" \r\n                         v .: \"low\" \r\n                         v .: \"ask\"</pre>\n<p>If I understand this correctly, those strange symbols are applicatives. The <em>.: </em>does &#8230; something &#8230; and the <em>&lt;$&gt; </em>and <em>&lt;*&gt; </em>do something else. The whole bit is about defining how to convert a key in the JSON string into a value in the <em>Ticker</em> type. I think.</p>\n<p>Right, let&#8217;s make a function that will talk to the server and return a <em>Ticker </em>object. Maybe. If all goes well.</p>\n<blockquote class=\"twitter-tweet\"><p>@<a href=\"https://twitter.com/swizec\">swizec</a> yes, you actually need to do something like this:ticker = get &#8220;ticker&#8221; &gt;&gt;= return . decode :: MonadIO m =&gt; m (Maybe Ticker)</p>\n<p>— 蓮 (@k0001) <a href=\"https://twitter.com/k0001/status/326972349196926977\">April 24, 2013</a></p></blockquote>\n<pre lang=\"haskell\">\r\nticker::(MonadIO m) => m (Maybe Ticker)\r\nticker = get \"ticker\" >>= return . decode</pre>\n<p>Fairly simple stuff. Take something from the internet carefully wrapped in <em>MonadIO</em>, unwrap it for a bit, feed it into <em>decode</em>, which magically uses all the stuff we defined earlier, and wrap it back into both a <em>MonadIO</em> and a <em>Maybe.</em> Parsing can fail you know.</p>\n<pre lang=\"haskell\">\r\nget::(MonadIO m) => String -> m ByteString\r\nget url = simpleHttp $ \"https://www.bitstamp.net/api/\"++url</pre>\n<p>This is the generalized <em>get</em> function that talks to Bitstamp using the <em>simpleHttp</em> function from <em>http-conduit</em>. It looks simple, but I&#8217;m sure a lot of hairy stuff is going on behind the scenes.</p>\n<p>To make sure everything works, we run it.</p>\n<pre lang=\"haskell\">\r\nmain = do\r\n  ticker >>= print</pre>\n<p>Nothing.</p>\n<p>Yup, the output we get is Nothing. It is at this point you realize <em>someone</em> isn&#8217;t using JSON correctly and all those numbers are actually strings. Strings. Now how the hell do you tell Haskell to automagically transform those into Numbers before putting them in the Ticker object?</p>\n<p>Messy messy internet.</p>\n<p>But hey! Got Haskell to talk to a <a class=\"zem_slink\" title=\"Representational state transfer\" href=\"http://en.wikipedia.org/wiki/Representational_state_transfer\" rel=\"wikipedia\" target=\"_blank\">REST API</a>. How cool is that!?</p>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" src=\"http://img.zemanta.com/zemified_e.png?x-id=5492ac2c-3abf-45a3-9680-dd8c31c07973\" alt=\"Enhanced by Zemanta\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"f8751b41-cafa-53f3-badb-1d91b51a7f8c"}}