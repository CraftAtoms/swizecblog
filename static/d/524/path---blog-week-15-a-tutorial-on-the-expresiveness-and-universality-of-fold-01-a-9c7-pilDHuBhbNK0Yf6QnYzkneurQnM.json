{"data":{"wordpressPost":{"title":"Week 15: A tutorial on the expressiveness and universality of fold","content":"<p><em>[This post is part of an ongoing challenge to understand 52 papers in 52 weeks. You can read previous entries, <a href=\"http://swizec.com/blog/category/52-papers-in-52-weeks\">here</a>, or subscribe to be notified of new posts by <a href=\"http://swiz.ec/52papers-list\">email</a>]</em></p>\n<p>Fold or foldr is a recursion operator with magical properties commonly used in functional programming. Sometimes known as <em>reduce</em>, <em>inject</em>, or <em>compress</em> it turns a list of values into a single value according to a combining function.</p>\n<p>Graham Hutton&#8217;s 1999 <a href=\"https://docs.google.com/viewer?url=http%3A%2F%2Fwww.cs.nott.ac.uk%2F%7Egmh%2Ffold.pdf\"><em>A tutorial on the expressivenes nad universality of fold</em></a> does a great job of explaining just how magical it is. In a language with first-order tuples and functions any function can be expressed as a <em>fold</em>, it lets you prove programs without using induction, and you can even generalise it to work on datatypes other than lists.</p>\n<p>Great magic indeed. But with great power comes great responsibility. Take heed of the lesser programmer and remember that many functions you rewrite as a <em>fold</em>, you will not be able to read in six months.</p>\n<h2 id=\"the-fold-operator\">The fold operator</h2>\n<p>Fold as a central concept in a programming language dates from <a class=\"zem_slink\" title=\"APL (programming language)\" href=\"http://en.wikipedia.org/wiki/APL_%28programming_language%29\" target=\"_blank\" rel=\"wikipedia\">APL</a>&#8216;s reduction operator in 1962 and later <a class=\"zem_slink\" title=\"Functional programming\" href=\"http://en.wikipedia.org/wiki/Functional_programming\" target=\"_blank\" rel=\"wikipedia\">FP</a>&#8216;s insertion operator in 1978. In <a class=\"zem_slink\" title=\"Haskell (programming language)\" href=\"http://haskell.org\" target=\"_blank\" rel=\"homepage\">Haskell</a> it&#8217;s defined like this:</p>\n<div style=\"width: 717px\" class=\"wp-caption alignnone\"><img title=\"Fold in Haskell\" alt=\"Fold in Haskell\" src=\"https://draftin.com:443/images/8825?token=ueE3-kY3VqTJZHvqEo0QAM9gCqNBEcDinyWXRoE1okdPZMsqXwAFXh8ERcM6CndZtqnLMul8XUuRet3HqbiNfh8\" width=\"707\" height=\"114\" /><p class=\"wp-caption-text\">Fold in Haskell</p></div>\n<p>The paper uses Haskell for all its examples so I&#8217;m going to stick to that as well.</p>\n<p>This code tells us that <em>fold</em> takes a function <code>f</code> of type Î± â†’ Î² â†’ Î², a value <code>v</code> of type Î², and processes a list of type [Î±] to return a value of type Î². It does this by replacing the nil constructor [] with <code>v</code>. And every cons operator <code>:</code> with the function <code>f</code>.</p>\n<p>Just think of lists as long chains of cons followed by a nil. You can think of a list <code>[1,2,3]</code> as prepending each value to an existing list &#8211; <code>1:2:3:[]</code>.</p>\n<p>When you apply a &#8216;fold (+) 0&#8217; it becomes &#8216;1+2+3+0&#8217;, which just so happens to be the sum function. But that&#8217;s essentially all that fold does &#8211; it replaces the cons in lists with a supplied function and the nil constructor with a base value.</p>\n<p>There&#8217;s also a <a class=\"zem_slink\" title=\"Fold (higher-order function)\" href=\"http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29\" target=\"_blank\" rel=\"wikipedia\">right fold</a>, <em>foldr</em>, which does the same, but right-to-left. Using foldl vs. foldr changes the associativity of the supplied function:</p>\n<pre lang=\"haskell\">Prelude&gt; foldl (-) 0 [1,2,3] # 0-1-2-3\r\n-6\r\nPrelude&gt; foldr (-) 0 [1,2,3] # 1-(2-(3-0))\r\n2</pre>\n<p>We can implement all the standard functions using fold using more complex functions. Actually we can implement anything, but we&#8217;ll get to that. Here&#8217;s a <em>length</em> example that tells us the length of a list.</p>\n<div style=\"width: 506px\" class=\"wp-caption alignnone\"><img title=\"Length implemented using fold\" alt=\"Length implemented using fold\" src=\"https://draftin.com:443/images/8831?token=fgG1BSxgqqV-4fLGH7PtGJjsSVr7LA8kpYBCzebkD_aab3ZydXIHtaDva2XIAOXC8UiZeKd7l-107qulnI3u4oo\" width=\"496\" height=\"80\" /><p class=\"wp-caption-text\">Length implemented using fold</p></div>\n<p>You see, instead of transforming the string, that lambda function just counts.</p>\n<h2 id=\"the-universal-property-of-fold\">The <a class=\"zem_slink\" title=\"Universal property\" href=\"http://en.wikipedia.org/wiki/Universal_property\" target=\"_blank\" rel=\"wikipedia\">universal property</a> of fold</h2>\n<p>In 1990 Malcolm was the first to systematically use the universal property of fold in his generalisation of lists to arbitrary datatypes. For finite lists it can be stated as an equivalence between two definitions of <code>g</code>.</p>\n<div style=\"width: 718px\" class=\"wp-caption alignnone\"><img title=\"Universal property\" alt=\"Universal property\" src=\"https://draftin.com:443/images/8867?token=Hbtc4HWONkfx_DnNQC0wqi2AYGA7q6-zaWW5Tq5XppW92E7vgrH7eT83GXv1v88cb7IF4IaXaLKdoAh8W7-lq6w\" width=\"708\" height=\"84\" /><p class=\"wp-caption-text\">Universal property</p></div>\n<p>Looking left-to-right, substituting <code>g</code> with <code>g = fold f v</code> gives you the recursive definition of <em>fold</em>, and right-to-left the two equations for <code>g</code> are exactly the assumptions to inductively prove that <em>g</em> equals <em>fold f v</em>.</p>\n<p>The universal property is particularly useful as a <strong>proof principle</strong> because it encapsulates a common pattern of <a class=\"zem_slink\" title=\"Mathematical induction\" href=\"http://en.wikipedia.org/wiki/Mathematical_induction\" target=\"_blank\" rel=\"wikipedia\">inductive proof</a>. Rather than mess about with induction, you can just appeal to the universal property.</p>\n<p>Let&#8217;s prove a simple equivalence:</p>\n<pre lang=\"haskell\">(+1) . sum = fold (+) 1</pre>\n<p>The left function is a composition of <code>+1</code> and <code>sum</code>, which sums a list then increments the result. The right function replaces every cons in a list with a <code>+</code> and the empty list with a <code>1</code>.</p>\n<p>We want to prove they will always give the same result when applied to the same list.</p>\n<p>The equation matches the right-hand side of the universal property of fold, <code>g = fold f v</code>, with <code>g = (+1) . sum</code>, <code>f = (+)</code>, and <code>v = 1</code>. With some simplification, the equation is equivalent to these:</p>\n<pre lang=\"haskell\">sum   []   + 1 = 1\r\nsum (x:xs) + 1 = x + (sum xs + 1)</pre>\n<p>Which can be verified by simple calculation:</p>\n<div style=\"width: 929px\" class=\"wp-caption alignnone\"><img title=\"Proof of sum = fold\" alt=\"Proof of sum = fold\" src=\"https://draftin.com:443/images/8945?token=fz5YXG-q4_QsJfnUq1rnC2A2Cdg0480WK9rZY2XH61YKcMbCvLYfAJ_EUzg0phXmfjCC8Sl5nLIYzfGQVWkXxiM\" width=\"919\" height=\"197\" /><p class=\"wp-caption-text\">Proof of sum = fold</p></div>\n<p>This concludes the proof. Much simpler than explicitly performing induction!</p>\n<p>For a less haskelly example, here&#8217;s what happened:</p>\n<pre lang=\"javascript\">var inc = function (x) { return x+1; }\r\nvar sum = function (x, xs) {\r\n return xs.length &gt; 0 ? x + sum(xs[0], xs.slice(1)) : x;\r\n}\r\n\r\nvar plus = function (a, b) { return a+b; }\r\n\r\n// we try to prove this equivalence, this is NOT something you execute ðŸ™‚\r\nfunction (xs) { return inc(sum(0, xs)); } == function (xs) { return xs.reduce(plus, 1); }\r\n\r\n// and then the same proof applies</pre>\n<p>The <strong>fusion property of fold</strong> allows us to fuse the composition of an arbitrary function and <em>fold</em> into a single <em>fold</em>. This isn&#8217;t true in general, so we use the universal property to calculate the conditions.</p>\n<pre lang=\"haskell\">h . fold g w = fold f v</pre>\n<p>Using the same process as above, we expand this equation into two equations.</p>\n<pre lang=\"haskell\">h (fold g w   [])   = v\r\nh (fold g w (x:xs)) = f x (h (fold g w xs))</pre>\n<p>Which we simplify with two calculations:</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8947?token=ZrDBOQ8GUKrY3HdpQ2bJrU_gjCstFMC2BYI-cXgBaI1FCd9nqh8UR7ITKktd3uMOIQlDMAnjxbjxlM7IBg8bJL4\" width=\"811\" height=\"386\" />\n<p>To get:</p>\n<div style=\"width: 885px\" class=\"wp-caption alignnone\"><img title=\"Conditions for equivalence\" alt=\"Conditions for equivalence\" src=\"https://draftin.com:443/images/8948?token=5fi6AJwxmmeAFlmwSvM8Me5A91YzPsKp-YwoqimSahQIpGuCjYlHwiYZH4z3RJbYtJFXx77wBCdHjAWwLVTdH6U\" width=\"875\" height=\"83\" /><p class=\"wp-caption-text\">Conditions for equivalence</p></div>\n<p>Which basically says that, if the conditions on the left are met, then our composition of an arbitrary function and fold behaves exactly as a fold would.</p>\n<p>Now we can greatly simplify our proof of the sum equation:</p>\n<pre lang=\"haskell\">(+1) . sum = fold (+) 1 \r\n=&gt;\r\n(+1) . fold (+) 0 = fold (+) 1</pre>\n<p>Which matches the fusion property and we&#8217;re done. Simple ðŸ™‚</p>\n<p>We can also use universality as a <strong>definition principle</strong> to help us transform explicit recursion into folds.</p>\n<p>Let&#8217;s take a recursively defined sum:</p>\n<div style=\"width: 453px\" class=\"wp-caption alignnone\"><img title=\"Recursively defined sum\" alt=\"Recursively defined sum\" src=\"https://draftin.com:443/images/8950?token=yD7C6UfpP4x4Kj632YMQ11KhD8SqQuia7T0JXuQqqiKsiolR9SuXr3x0j0bqIjli0bqVjQsd6V-Z3kZopIL2PAc\" width=\"443\" height=\"106\" /><p class=\"wp-caption-text\">Recursively defined sum</p></div>\n<p>We want to rewrite this into a <em>fold</em>. That is, we&#8217;re going to solve the equation <code>sum = fold f v</code> for function <code>f</code> and value <code>v</code>. Because it matches the right-hand side of the universal property, we turn it into two equations:</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8951?token=M143GtAIQxZrr_cy4STf3W266OIpvftmvkLGjgStSBy4ocbapzPI0njwiMconvl0kxZwpynQdsC3oqccm-Nla8c\" width=\"451\" height=\"77\" />\n<p>We can see from the first equation that <code>v = 0</code>. From the second equation we calculate a definition for <code>f</code>.</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8952?token=LYpy5Mmxjx7T9wq4GxVNeV9ufPPD_1USOX-TJWLwHKp2U8FofvxnrBhW9rdrhLp2LbFHQq_vMx7OrQP6p2GFUww\" width=\"556\" height=\"265\" />\n<p>We calculated that <code>f = (+)</code> and <code>sum = fold (+) 0</code>, which is a contrived example because the definition using fold is obvious, but does a good job of showing the idea behind what we&#8217;re doing.</p>\n<p>The key step (â€ ) above is the generalisation of <code>sum xs</code> to a fresh variable <code>y</code>. This step will feature in most such calculations and isn&#8217;t specific to <em>sum</em>.</p>\n<p>Using this process, you can even write <em>map</em> as a <em>fold</em>:</p>\n<pre lang=\"haskell\">map f = fold (Î»x ys â†’ f x : ys) []</pre>\n<h2 id=\"increasing-the-power-of-fold-with-tuples\">Increasing the power of fold with tuples</h2>\n<p>We can make <em>fold</em> even more powerful by using it to generate tuples. Say you want a sumlength function that returns a list&#8217;s length as well as its sum:</p>\n<pre lang=\"haskell\">sumlength   :: [Int] â†’ (Int, Int)\r\nsumlength xs = (sum xs, length xs)</pre>\n<p>Turning this function into a single <em>fold</em> is more efficient because it only makes a single pass over the list.</p>\n<pre lang=\"haskell\">sumlength = fold (Î»n (x, y) â†’ (n+x, 1+y)) (0, 0)</pre>\n<p>In fact, any pair of applications of fold to the same list can be rewritten as a single fold. Even a function such as <em>dropWhile</em>, which drops elements from a list as long as a predicate holds true.</p>\n<p>First we need a sister function, <em>dropWhile&#8217;</em>, that pairs the argument list together with the result:</p>\n<div style=\"width: 729px\" class=\"wp-caption alignnone\"><img title=\"dropWhile'\" alt=\"dropWhile'\" src=\"https://draftin.com:443/images/8954?token=CQ_xqJCbCtBjQNwiJIRE_cD7dbNq1454Y2K0akvb0Llf1fWNvYBBsqKi26Ngiud99mel3Ce3Dj78IuprWokJCoc\" width=\"719\" height=\"91\" /><p class=\"wp-caption-text\">dropWhile&#8217;</p></div>\n<p>Which, as usual, we decide is equivalent to these two equations according to the universal property:</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8955?token=CM5q3AVwRODNtzvLQ_FgdTlB7MQHCKOZ7FMJLb3hjHSqDkg7OO98BOwkjZlEe_FnsUaFsCUJAbKfb_NHSVIrlsM\" width=\"656\" height=\"86\" />\n<p>It&#8217;s obvious from the first equation that <code>v = ([], [])</code>. We get the definition for <code>f</code> from a calculation like this:</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8956?token=yEMWj1PYCcW5_Hv-xzJIZ3127aNXCViMS5lwoV-hpsr_TzzoqBqRMZ52OHIVyHACsqkhVx9eAhehkqIqhjLsX3Q\" width=\"834\" height=\"301\" />\n<p>And finally our <code>dropWhile'</code> function looks like this:</p>\n<div style=\"width: 759px\" class=\"wp-caption alignnone\"><img title=\"Definition of dropWhile'\" alt=\"Definition of dropWhile'\" src=\"https://draftin.com:443/images/8958?token=PIWoSInFr6DW4Jeek7SdG3eBtc7gS2gPlz23w3-nLcFLv0rG6PVKVccwVD0esG9aCk4I1BW1A2M0khKocDYh-lg\" width=\"749\" height=\"156\" /><p class=\"wp-caption-text\">Definition of dropWhile&#8217;</p></div>\n<p>Composing this with <code>fst</code> gives us the normal <em>dropWhile</em> because the changed list ends up in the first part of the resulting tuple. <code>dropWhile p = fst . dropWhile' p</code></p>\n<p>This tupling technique is so powerful, we can redefine any <strong>primitive recursion</strong> function in terms of fold. The approach is usually to make a sister function that tuples the result together with the original list and work on that.</p>\n<p>As far as I understand it, the idea is to essentially carry an extra argument into the fold so things are easier to work with. Which makes me wonder whether there&#8217;s a monadic solution to this that produces cleaner code.</p>\n<p>The paper says that if you have a function like this:</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8959?token=2eINObVZSoVMCsoer-jNbEZXd8RZHx0CtCIIPcxIRBo0QBNxh0Cx4M6f_jO0uSkbql-fr-kGA4OXyTMAaSIOYKc\" width=\"374\" height=\"84\" />\n<p>You can <em>fold</em> this, by first introducing an extra argument, <code>y</code>, that is processed by a new function <code>f</code> in the base case, but generally passed through without change. Then you redefine <code>h y</code> with fold and introduce <code>xs</code> as an extra argument to <code>g</code>.</p>\n<div style=\"width: 518px\" class=\"wp-caption alignnone\"><img title=\"Primitive recursion\" alt=\"Primitive recursion\" src=\"https://draftin.com:443/images/8960?token=9-o16lwHpwLaMbbedtMqpsNFm2TzqQQctv-aroKpf3YwFGKKd-0ePT4OVVgaQG2V8trN8n0a3cHk4YvFrF9CcG0\" width=\"508\" height=\"83\" /><p class=\"wp-caption-text\">Primitive recursion</p></div>\n<p>This gives you primitive recursion, which isn&#8217;t foldable unless you use the tupling technique.</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8961?token=tuhKeIllbMu88WButTCqN7CCUpNUGoNW3pdf3SSzcA17nw-PjhJ37QXJxUSPQHvUInx4veq9Mt8lIdSokLzTxjA\" width=\"360\" height=\"44\" />\n<p>And after the same sort of shenanigans as before, our function turns into a fold:</p>\n<div style=\"width: 662px\" class=\"wp-caption alignnone\"><img title=\"Folded recursion\" alt=\"Folded recursion\" src=\"https://draftin.com:443/images/8962?token=uV-N5yiuyc4z_Ikh1EaMbbp4K_fEoPktedd73zjmbcygdFwKeVBeo0ZSTwW_b7iICVa77ovQ899vh_gs3VuqQIE\" width=\"652\" height=\"160\" /><p class=\"wp-caption-text\">Folded recursion</p></div>\n<p>Which lets us say that <code>h y = fst . k y</code>, which is supposedly better than the definition we had before. I guess it is because we wanted to use <em>fold</em> and now we are.</p>\n<h2 id=\"using-fold-to-generate-functions\">Using fold to generate functions</h2>\n<p>Using a language with first-order functions lets us take the power of fold further still &#8211; we can generate functions. Similar to how you&#8217;d normally replace conses with functions, you can replace them with compositions.</p>\n<div style=\"width: 462px\" class=\"wp-caption alignnone\"><img title=\"Compose as a fold\" alt=\"Compose as a fold\" src=\"https://draftin.com:443/images/8963?token=XWOpuOr75CLiNqNWDzjWIwrJ7y-jXpSlhjWY8LzdZ0--89eoO9LRcVL4toMYbkfo3HeboANh6zwV2YOKH10yfFE\" width=\"452\" height=\"67\" /><p class=\"wp-caption-text\">Compose as a fold</p></div>\n<p>But that&#8217;s not very interesting. I&#8217;m going to skip over the paper&#8217;s definitions of various <em>suml</em> and <em>foldl</em> and such functions and go straight to the interesting example &#8211; Ackermann&#8217;s function.</p>\n<p>Ackermann&#8217;s function is the first known example of a function that is computable, but isn&#8217;t primitively recursive.</p>\n<div style=\"width: 682px\" class=\"wp-caption alignnone\"><img title=\"Ackermann's function\" alt=\"Ackermann's function\" src=\"https://draftin.com:443/images/8964?token=CP41oWy3xwbLFbdTjDiZ_nEfHQV9yX9UP4cueedRlMA60M4rljjLI2FKB-lZjQfEucJktBv_E4xV0p6H_k6TvDg\" width=\"672\" height=\"151\" /><p class=\"wp-caption-text\">Ackermann&#8217;s function</p></div>\n<p>It&#8217;s been converted to operate on lists rather than natural numbers so that <em>n</em> is represented as a list of <em>n</em> elements. The only reason we can do this, is that we&#8217;re working with a higher order language.</p>\n<p>By appealing to the universal property, we find that <code>ack = fold f v</code> is equivalent to these two equations:</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8966?token=fSxoIt4SMm297nLdiAGxRko_mVivdYxDxKD3ilHfOdrrSlbvR2Ov41NVX_-ZH8J9VNqXj4ELuNWxzQTdbontFhQ\" width=\"428\" height=\"80\" />\n<p>A simple calculation tells us that <code>v = (1:)</code>, but we can&#8217;t use the second equation the same way as before. We must first tackle <code>ack (x:xs)</code> on the left-hand side.</p>\n<div style=\"width: 635px\" class=\"wp-caption alignnone\"><img title=\"ack (x:xs)\" alt=\"ack (x:xs)\" src=\"https://draftin.com:443/images/8967?token=yfxwzBKB5Vz5Mr_ruObHqYV0IguQa3RUQlFBzHu9nOKtuOLHo55qeju_RAZxAhuXgw3XIh6kOtIW-EewJK7SWOQ\" width=\"625\" height=\"85\" /><p class=\"wp-caption-text\">ack (x:xs)</p></div>\n<p>Now the first equation tells us that <code>w = ack xs</code> and we normally apply the universal property on the second equation to get this:</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8968?token=Rsuh_zSY_OAuBx_yuuY2s0du9k52nxoeiTCQbFWB_1UnFSe5EmwpIePSdmgsQa7i02EF-IS4Ng96NoFxWyE-Je4\" width=\"674\" height=\"48\" />\n<p>We can now calculate the definition of <code>f</code>, which gives us the final folded ackerman&#8217;s function:</p>\n<img alt=\"\" src=\"https://draftin.com:443/images/8969?token=P6BCQ3xeWyT98mUqxIxJt-P-7Lvvzso7BxWi8FraYxHzYL1JQa8sSEnHotl1F9fSdgJ1h_WkhSuaLh8MAS4t1CA\" width=\"668\" height=\"48\" />\n<p>It took using the universal property <em>twice</em>, but we did it. We defined ackerman&#8217;s function as a fold.</p>\n<h2 id=\"fin\">Fin</h2>\n<p>The paper finishes with a survey of references for even more magical things you can do with folds. Using them for datatypes other than lists, performing monadic folds, redefining fold on relations, and how helpful fold can be in automatic program transformation.</p>\n<p>But all of that are topics for another day, today let&#8217;s just agree that <em>fold</em> is awesome and we should all be using it much more.</p>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" alt=\"Enhanced by Zemanta\" src=\"http://img.zemanta.com/zemified_e.png?x-id=cf076e67-d2c7-42cf-90b4-36d260742cba\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"a9dac1a9-5a88-58da-a776-e5a4df1458d4"}}