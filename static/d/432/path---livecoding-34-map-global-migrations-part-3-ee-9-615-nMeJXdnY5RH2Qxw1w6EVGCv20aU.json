{"data":{"wordpressPost":{"title":"Livecoding #34: A Map of Global Migrations, Part 3","content":"<p><em>This is a Livecoding Recap â€“ an almost-weekly post about interesting things discovered while livecoding ?. Always under 500 words and with pictures. You can follow my channel, <a href=\"https://liveedu.tv/swizec\">here</a>. New content almost <strong>every Sunday at 2pm PDT</strong>. Thereâ€™s live chat, come say hai ?</em></p>\n<p><iframe src=\"https://www.liveedu.tv/swizec/videos/8v3yz/embed\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"true\" scrolling=\"no\"></iframe></p>\n<p>This Sunday, we built a zoomable pannable map with React and D3. We also added animation to our migration curves. Now people can see what they mean.</p>\n<div id=\"attachment_7454\" style=\"width: 1301px\" class=\"wp-caption alignnone\"><a href=\"https://swizec.github.io/migrations-map/\"><img class=\"wp-image-7454 size-full\" src=\"http://swizec.com/blog/wp-content/uploads/2017/02/uk-migrations.gif\" alt=\"Click on the map to see a live example\" width=\"1291\" height=\"564\" /></a><p class=\"wp-caption-text\">Click on the map to see a live example</p></div>\n<p>See? It zooms and it pans and the circles follow their curves. Just like the color, the amount of circles on each line signifies migration intensity. ?</p>\n<p>Here&#39;s how it works ?</p>\n<h2>Animate SVG element to follow a curve</h2>\n<p>Moving an element along a line is one of those things you think you can figure out on your own but you can&#39;t. Then you see how it&#39;s done and you think, <em>&quot;I&#39;m dumb&quot;</em>.</p>\n<p>But you&#39;re not dumb. It&#39;s totally un-obvious.</p>\n<p>We used Bostock&#39;s <a href=\"https://bl.ocks.org/mbostock/1705868\">Point-Along-Line Interpolation</a> example as our model. It creates a custom tween that we apply to each circle as an <code>attrTween</code> transition.</p>\n<pre lang=\"javascript\">\nfunction translateAlong(path) {\n    var l = path.getTotalLength();\n    return function(d, i, a) {\n        return function(t) {\n            var p = path.getPointAtLength(t * l);\n            return \"translate(\" + p.x + \",\" + p.y + \")\";\n        };\n    };\n}\n</pre>\n<p>That&#39;s the custom tween. I&#39;d love to explain how it works, butâ€¦ well, we have a <code>getPointAtLength</code> function that SVG gives us by default on every <code>&lt;path&gt;</code> element. We use it to generate <code>translate(x, y)</code> strings that we feed into the <code>transform</code> attribute of a <code>&lt;circle&gt;</code> element. That part is obvious.</p>\n<p>The part I don&#39;t get is the 3-deep function nesting for currying. The top function returns a tween, I assume. It&#39;s a function that takes <code>d, i, a</code> as arguments and never uses them. Instead, it returns a time-parametrized function that returns a <code>translate(x, y)</code> string for each <code>t</code>.</p>\n<p>We know from D3 conventions that <code>t</code> runs in the <code>[0, 1]</code> interval, so we can assume the tween gives a <em>&quot;point at t percent of full length of path&quot;</em> coordinates.</p>\n<p>Great.</p>\n<p>We apply it in our <code>MigrationLine</code> component like this:</p>\n<pre lang=\"javascript\">\n// inside MigrationLine\n    _transform(circle, delay) {\n        const { start } = this.props,\n              [ x1, y1 ] = start;\n\n        d3.select(circle)\n          .attr(\"transform\", `translate(${x1}, ${y1})`)\n          .transition()\n          .delay(delay)\n          .duration(this.duration)\n          .attrTween(\"transform\", translateAlong(this.refs.path))\n          .on(\"end\", () => {\n              if (this.state.keepAnimating) {\n                  this._transform(circle, 0);\n              }\n          });\n    }\n    \n    componentDidMount() {\n        const { Ncircles } = this.props;\n\n        this.setState({\n            keepAnimating: true\n        });\n\n        const delayDither = this.duration*Math.random(),\n              spread = this.duration/Ncircles;\n\n        d3.range(delayDither, this.duration+delayDither, spread)\n          .forEach((delay, i) =>\n              this._transform(this.refs[`circles-${i}`], delay)\n          );\n    }\n</pre>\n<p>We call <code>_transform</code> on every circle in our component. Each gets a different <code>delay</code> so that we get a roughly uniform distribution of circles on the line. Without this, they come in bursts, and it looks weird.</p>\n<p><code>delayDither</code> ensures the circles for each line start with a random offset, which also helps fight the burstiness. Here&#39;s what the map looks like without <code>delayDither</code> and with a constant delay between circles regardless how many there are.</p>\n<img class=\"alignnone size-full wp-image-7452\" src=\"https://swizec.com/blog/wp-content/uploads/2017/02/bursty-map-1.gif\" width=\"1291\" height=\"564\" />\n<p>See? No good.</p>\n<p>You can see the <a href=\"https://github.com/Swizec/migrations-map/blob/de8800aecca4484f8c5827a82c8a746127264143/src/MigrationLine.js\">full MigrationLine code on Github</a>.</p>\n<h2>Zoom and pan a map</h2>\n<p>This part was both harder and easier than I thought.</p>\n<p>You see, D3 comes with something called <a href=\"https://github.com/d3/d3-zoom\">d3.zoom</a>. It does zooming <em>and</em> panning.</p>\n<p>Cool, right? Should be easy to implement. And it isâ€¦ if you don&#39;t fall down a rabbit hole.</p>\n<p>In the old days, the standard approach was to <code>.call()</code> zoom on an <code>&lt;svg&gt;</code> element, listen for <code>zoom</code> events, and adjust your scales. Zoom callback would tell you how to change zoominess and where to move, and you&#39;d adjust your scales and re-render the visualization.</p>\n<p>We tried that approach with hilarious results:</p>\n<img class=\"alignnone size-full wp-image-7451\" src=\"https://swizec.com/blog/wp-content/uploads/2017/02/drag-1.gif\" width=\"921\" height=\"516\" />\n<p>First, it was moving in the wrong direction, then it was jumping around. Changing the geo projection to achieve zoom and pan was <em>not</em> the answer. Something was amiss.</p>\n<p>Turns out in D3v4, the zoom callback gets info to build an SVG transform. A <code>translate()</code> followed by a <code>scale()</code>.</p>\n<p>Apply those on the visualization and you get working zooming and panning! Of anything ðŸ˜€</p>\n<pre lang=\"javascript\">\n// in SVG rendering component\n    onZoom() {\n        this.setState({\n            transform: d3.event.transform\n        });\n    }\n\n    get transform() {\n        if (this.state.transform) {\n            const { x, y, k } = this.state.transform;\n            return `translate(${x}, ${y}) scale(${k})`;\n        }else{\n            return null;\n        }\n    }\n    // ...\n    render() {\n        return (\n            <svg width={width} height={height} ref=\"svg\">\n                <g transform={this.transform}>\n                // ...\n    }\n</pre>\n<p>Get <code>d3.event.transform</code>, save it in <code>state</code> or a data store of some sort, re-render, use it on a <code>&lt;g&gt;</code> element that wraps everything.</p>\n<p>Voila, zooming and panning. ?</p>\n<div id=\"attachment_7454\" style=\"width: 1301px\" class=\"wp-caption alignnone\"><a href=\"https://swizec.github.io/migrations-map/\"><img class=\"wp-image-7454 size-full\" src=\"http://swizec.com/blog/wp-content/uploads/2017/02/uk-migrations.gif\" alt=\"Click on the map to see a live example\" width=\"1291\" height=\"564\" /></a><p class=\"wp-caption-text\">Click on the map to see a live example</p></div>\n<p>You can see the <a href=\"https://github.com/Swizec/migrations-map/blob/de8800aecca4484f8c5827a82c8a746127264143/src/Maps.js#L69\">full <code>World</code> component on Github</a>.</p>\n<p>Happy hacking! ?</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"521b2092-f2a0-5091-a46d-434281c1d809"}}