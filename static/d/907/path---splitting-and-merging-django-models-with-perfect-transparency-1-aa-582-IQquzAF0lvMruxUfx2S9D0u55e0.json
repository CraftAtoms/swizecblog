{"data":{"wordpressPost":{"title":"Splitting and merging django models with perfect transparency","content":"<p>This is a howto that might come in handy to some people, but mostly I just want to document how I poked around some very angry django dragons and created something marvelous. There are also people on twitter who were wondering what the fuck I was doing.</p>\n<p>So let&#8217;s start by describing the problem. We have a base user model named <em>pUser</em> (yes stupid naming convention) that is tied to a cookie, which holds an id. These users are then tied to a number of different API accounts. In my case it is Delicious, Twitter and Facebook. The <em>user_id</em> is also used to tie a bunch of meta data in different other models to them.</p>\n<p>The problem is that we do not want to trouble users with a special login for our service. But they are using different computers and browsers, so the same physical user can have multiple user id&#8217;s.</p>\n<p>However through their Delicious et al. credentials we can tie them back together into a single entity. But we do not want to trouble the rest of the code with this detail, it should just work seamlessly because otherwise we&#8217;d be forced to introduce checking for this stuff at about 50 different places in the project.</p>\n<p>My approach to solving this goes as follows; at the end will be the three tests that indicate that the solution is valid. A hardcore test through the actual UI also confirmed that everything works.</p>\n<h2>Funky geek stuff follows, you have been warned</h2>\n<p>First we introduce a model that connects different user id&#8217;s to the main user (i.e. the first id said user was given)</p>\n<pre lang=\"python\">class UserNormalisation(models.Model):\r\n\tmain_id = models.IntegerField()\r\n\tsub_id = models.IntegerField()\r\n\r\n\tclass Meta:\r\n\t\tunique_together = (\"main_id\", \"sub_id\")</pre>\n<p>Then we give our Delicious model a ModelManager that will perform duplicity checking and tie different users together as needed.</p>\n<pre lang=\"python\">class DeliciousManager(models.Manager):\r\n\tdef create(self, **kwargs):\r\n\t\ttry:\r\n\t\t\told = Delicious.objects.get(username=kwargs['username'])\r\n\t\t\tnew = super(DeliciousManager, self).create(**kwargs)\r\n\t\t\ttry:\r\n\t\t\t\tUserNormalisation(main_id = old.user.id,\r\n\t\t\t\t\t\t  sub_id = new.user.id).save()\r\n\t\t\texcept IntegrityError:\r\n\t\t\t\tpass\r\n\t\t\tnew.delete()\r\n\t\t\treturn old\r\n\t\texcept Delicious.DoesNotExist:\r\n\t\t\treturn super(DeliciousManager, self).create(**kwargs)\r\n\r\nclass Delicious(models.Model):\r\n\tuser = models.ForeignKey( pUser )\r\n\tusername = models.CharField( max_length=255 )\r\n\tpassword = models.CharField( max_length=255 )\r\n\tisScrobbled = models.BooleanField( default=False )\r\n\r\n\tobjects = DeliciousManager()</pre>\n<p>Basically when the <em>create</em>function is called it checks whether a Delicious model with the same username already exists and if it does, then a row is added to the UserNormalisation table to tie the two user id&#8217;s together.</p>\n<p>And here&#8217;s the real magic, the changes we did to the pUser model.</p>\n<pre lang=\"python\">class pUserManager(models.Manager):\r\n\tdef get(self, **kwargs):\r\n\t\tuser = super(pUserManager, self).get(**kwargs)\r\n\t\ttry:\r\n\t\t\tid = UserNormalisation.objects.get(sub_id=user.id).main_id\r\n\t\t\tuser = super(pUserManager, self).get(id=id)\r\n\t\texcept UserNormalisation.DoesNotExist:\r\n\t\t\tpass\r\n\t\treturn user\r\n\r\nclass pUser(models.Model):\r\n\tusername = models.CharField( max_length=50 )\r\n\tpassword = models.CharField( max_length=255 )\r\n\tcreation = models.DateTimeField( auto_now=True )\r\n\r\n\tobjects = pUserManager()\r\n\r\n\tdef __init__(self, *args, **kwargs):\r\n\t\tsuper(pUser, self).__init__(*args, **kwargs)\r\n\t\ttry:\r\n\t\t\tid = UserNormalisation.objects.get(sub_id=self.id).main_id\r\n\t\t\tself.id = id\r\n\r\n\t\texcept UserNormalisation.DoesNotExist:\r\n\t\t\tpass</pre>\n<p>The pUserManager should have a few more functions that do essentially the same thing for other operations (filter comes to mind). Essentially whenever a pUser is fetched from the db the manager will return the real user as per the UserNormalisation model.</p>\n<p>Another trick that makes this work seamlessly even when used as a connecting model (primary key for instance) in a different table is that __init__ function. What I&#8217;ve discovered is that there it&#8217;s enough to just change the user&#8217;s id in place and everything will work.</p>\n<p>Here are the tests that confirm all of this funky stuff actually performs as expected</p>\n<pre lang=\"python\">\r\n\tdef test_normalisation(self):\r\n\t\tuser = pUser(username=\"test\", password=\"test\")\r\n\t\tuser.save()\r\n\r\n\t\tuser2 = pUser(username=\"test2\", password=\"test\")\r\n\t\tuser2.save()\r\n\r\n\t\tnorm = UserNormalisation(main_id=user.id, sub_id=user2.id)\r\n\t\tnorm.save()\r\n\r\n\t\tfixture = pUser.objects.get(id=user2.id)\r\n\t\tself.assertEquals( fixture.id, user.id )\r\n\r\n\tdef test_normalisation2(self):\r\n\t\tuser = pUser()\r\n\t\tuser.save()\r\n\t\tuser2 = pUser()\r\n\t\tuser2.save()\r\n\r\n\t\tuser.delicious_set.create(username=\"test\", password=\"test\")\r\n\t\tfixture = user2.delicious_set.create(username=\"test\", password=\"test\")\r\n\r\n\t\tself.assertEquals( fixture.user.id, user.id )\r\n\t\tself.assertEquals( UserNormalisation.objects.get(sub_id=user2.id).main_id, user.id )\r\n\t\tself.assertEquals( fixture.user, user )\r\n\r\n\tdef test_normalisation3(self):\r\n\t\tuser = pUser()\r\n\t\tuser.save()\r\n\t\tuser2 = pUser()\r\n\t\tuser2.save()\r\n\r\n\t\tuser.delicious_set.create(username=\"test\", password=\"test\")\r\n\t\tfixture = user2.delicious_set.create(username=\"test\", password=\"test\")\r\n\t\t\r\n\t\tnorm = UserNormalisation.objects.all()\r\n\r\n\t\tConcepts.relate(user=user2, concept1=\"tag1\", concept2=\"tag2\")\r\n\t\trelation = ConceptRelation.objects.filter(user=user2, concept1=\"tag1\")[0]\r\n\t\tself.assertEquals( relation.user.id, user.id )\r\n\t\tself.assertEquals( relation.user, user )</pre>\n<p>Take special note to the latter two examples. In test_normalisation2 you can see that when a delicious_set is created for user2, the two users become the same thing because both we&#8217;re using the same delicious username both times. Something similar happens in test_normalisation3, but there we see that creating a ConceptRelation for user2 actually creates it for the first user because they both behave as if they were the original user.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"14a58392-dca5-54de-98b1-3b7af1e741bb"}}