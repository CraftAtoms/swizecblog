{"data":{"wordpressPost":{"title":"Learning WebRTC peer-to-peer communication, part 2 â€“ connecting 2 browsers on different devices","content":"<p><em>This is a Livecoding Recap â€“ an almost-weekly post about interesting things discovered while livecoding. Usually shorter than 500 words. Often with pictures. Livecoding happens almost <strong>every Sunday at 2pm PDT</strong> on multiple channels. You should subscribe to ï¿¼<a href=\"https://www.youtube.com/user/TheSwizec\">my Youtubeï¿¼ channel</a> to catch me live.</em></p>\n<p>It worked! We got two browsers on different machines talking to each other without a server.</p>\n<p>Wellâ€¦ after the initial handshake. You still need a server for that.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">OMG IT WORKS! I got two browsers to talk to each other without a server</p>\n<p>Well &#8230; a server is used for the initial handshake. BUT THEN NO SERVER <a href=\"https://twitter.com/hashtag/WebRTC?src=hash&amp;ref_src=twsrc%5Etfw\">#WebRTC</a></p>\n<p>Article coming soon <a href=\"https://t.co/LRWVt4BhV8\">pic.twitter.com/LRWVt4BhV8</a></p>\n<p>&mdash; Swizec @ WeAreDevs ðŸ‡¦ðŸ‡¹ (@Swizec) <a href=\"https://twitter.com/Swizec/status/995933206187728896?ref_src=twsrc%5Etfw\">May 14, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>That was a fun weekend. Two livecoding sessions. Finally got it working late at night when the cameras weren&#8217;t rolling. I am nowhere near having it working in time for a true blockchain demo for my WeAreDevelopers talk this Friday. ðŸ˜…</p>\n<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/8TFj_U5CyWQ?feature=oembed\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe></p>\n<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/L8bsztuOEeQ?feature=oembed\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe></p>\n<p>You can <a href=\"https://swizec.github.io/webrtc-sample/\">try it out here</a>. Open that link in two browsers, possibly on different machines.</p>\n<p>You might have to try a couple of times, it&#8217;s a little finicky. ðŸ¤¨</p>\n<p>Here&#8217;s how it works ðŸ‘‡</p>\n<h2>How to use WebRTC to connect browsers on different devices</h2>\n<img class=\"alignnone size-full wp-image-8380\" src=\"https://swizec.com/blog/wp-content/uploads/2018/05/photo_may_16_1_09_35_pm.jpg\" width=\"1551\" height=\"1405\" srcset=\"https://swizec.com/blog/wp-content/uploads/2018/05/photo_may_16_1_09_35_pm.jpg 1551w, https://swizec.com/blog/wp-content/uploads/2018/05/photo_may_16_1_09_35_pm-300x272.jpg 300w, https://swizec.com/blog/wp-content/uploads/2018/05/photo_may_16_1_09_35_pm-768x696.jpg 768w, https://swizec.com/blog/wp-content/uploads/2018/05/photo_may_16_1_09_35_pm-1024x928.jpg 1024w\" sizes=\"(max-width: 1551px) 100vw, 1551px\" />\n<p>You can use WebRTC to make browsers talk to each other directly without a server. But because there&#8217;s no service discovery, you need a signaling server so browsers can find each other.</p>\n<p>The flow goes like this:</p>\n<ol>\n<li>Client 1 says hi to the server and registers</li>\n<li>Client 2 says hi to the server and registers</li>\n<li>Server holds list of identifiers (usernames)</li>\n<li>Client 1 tells server to call Client 2</li>\n<li>Server tells Client 2 there&#8217;s a call</li>\n<li>Client 2 answers the call</li>\n<li>Client 1 and Client 2 are now talking directly</li>\n</ol>\n<p>We followed <a href=\"https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat\">this WebRTC chat example from MDN</a> to model our code.</p>\n<h3>Signaling WebSocket server</h3>\n<p>Signaling is the handshake process between two browsers. Our implementation uses WebSockets to do that.</p>\n<p>The <a href=\"https://github.com/Swizec/webrtc-sample/blob/master/signaling-server.js\">server part is the same</a> as the MDN example. Pure copy pasta.</p>\n<p>We made some changes to make it work with <a href=\"https://zeit.co\">now.sh</a>. Namely, we removed all SSL stuff. Zeit wraps our servers in a secure SSL server that then talks to our actual server via an unencrypted connection.</p>\n<p>That was a painful gotcha to learn.</p>\n<p>WebSockets don&#8217;t work in modern browsers without SSL. And they don&#8217;t work with self-signed certificates unless you&#8217;re running localhost. If you want browsers that are not on your machine to talk, you&#8217;re gonna have to ensure a real SSL cert.</p>\n<p>Easiest way is to deploy on <code>now</code>.</p>\n<h3>Connecting to the signaling server</h3>\n<p>Talking to the server happens via WebSockets with <a href=\"https://github.com/Swizec/webrtc-sample/blob/master/src/SignalingConnection.js\">a 40 line helper class</a>. Instantiate the class, make a connection, listen for messages.</p>\n<img class=\"alignnone size-full wp-image-8381\" src=\"https://swizec.com/blog/wp-content/uploads/2018/05/signalconnection.png\" width=\"1582\" height=\"1966\" srcset=\"https://swizec.com/blog/wp-content/uploads/2018/05/signalconnection.png 1582w, https://swizec.com/blog/wp-content/uploads/2018/05/signalconnection-241x300.png 241w, https://swizec.com/blog/wp-content/uploads/2018/05/signalconnection-768x954.png 768w, https://swizec.com/blog/wp-content/uploads/2018/05/signalconnection-824x1024.png 824w\" sizes=\"(max-width: 1582px) 100vw, 1582px\" />\n<p>We create a <code>new WebSocket</code> in <code>connectToSocket</code>, add some callbacks, and hope for the best. The <code>onmessage</code> listener allows us to add additional message listeners later via the <code>messageListeners</code> array.</p>\n<p><code>sendToServer</code> lets us send a JSON object to our server, and <code>addMsgListener</code> lets us add a new message listener. We&#8217;ll use this to wire up our <code>PeerConnection</code> helper to our server.</p>\n<h3>Establishing a peer connection</h3>\n<p>Learning our lesson from <a href=\"https://swizec.com/blog/learning-webrtc-peer-peer-communication-part-1/swizec/8359\">WebRTC part 1</a>, we split our RTCPeerConnection stuff into <a href=\"https://github.com/Swizec/webrtc-sample/blob/master/src/PeerConnection.js\">a helper class</a>.</p>\n<p>It&#8217;s about 148 lines and handles the whole lifecycle. We <a href=\"https://swizec.com/blog/learning-webrtc-peer-peer-communication-part-1/swizec/8359\">talked about the code before</a>, so here&#8217;s a recap ðŸ‘‡</p>\n<img class=\"alignnone size-full wp-image-8382\" src=\"https://swizec.com/blog/wp-content/uploads/2018/05/peerconnection.png\" width=\"1768\" height=\"2542\" srcset=\"https://swizec.com/blog/wp-content/uploads/2018/05/peerconnection.png 1768w, https://swizec.com/blog/wp-content/uploads/2018/05/peerconnection-209x300.png 209w, https://swizec.com/blog/wp-content/uploads/2018/05/peerconnection-768x1104.png 768w, https://swizec.com/blog/wp-content/uploads/2018/05/peerconnection-712x1024.png 712w\" sizes=\"(max-width: 1768px) 100vw, 1768px\" />\n<p><code>constructor</code> sets a bunch of instance vars, sets up a new <code>RTCPeerConnection</code> object, tells it which <code>iceServers</code> to use, connects local event listeners, starts listening for messages on our signaling server, and adds our media stream to the <code>peerConnection</code>.</p>\n<p>The next step is <code>handleICECandidate</code>, interactive connectivity establishment, which triggers when a new connection is attempted. It pings our signaling server and says <em>&#8220;Yo, new ice candidate here&#8221;</em>.</p>\n<pre lang=\"javascript\">\n    handleICECandidateEvent = event => {\n        if (event.candidate) {\n            this.signalingConnection.sendToServer({\n                type: \"new-ice-candidate\",\n                target: this.targetUsername,\n                candidate: event.candidate\n            });\n        }\n    };\n</pre>\n<p>After that, weâ€™ve got the <code>handleNegotiationNeededEvent</code>, which is called when <code>RTCPeerConnection</code> says some negotiation needs to happen. I don&#8217;t know what makes it say that.</p>\n<p>But the function creates a new connection offer, updates the local SDP description, and tells our signaling server that we&#8217;re trying to call someone.</p>\n<pre lang=\"javascript\">\n   handleNegotiationNeededEvent = () => {\n        const {\n            username,\n            targetUsername\n        } = this;\n        this.peerConnection\n            .createOffer()\n            .then(offer => this.peerConnection.setLocalDescription(offer))\n            .then(() =>\n                this.signalingConnection.sendToServer({\n                    name: username,\n                    target: targetUsername,\n                    type: \"video-offer\",\n                    sdp: this.peerConnection.localDescription\n                })\n            )\n            .catch(console.error);\n    };\n</pre>\n<h4>Handling signaling messages</h4>\n<p>Then we have the fun stuff: handling messages from our signaling server.</p>\n<pre lang=\"javascript\">\n    onSignalingMessage = (msg) => {\n        switch (msg.type) {\n            case \"video-answer\": // Callee has answered our offer\n                this.videoAnswer(msg);\n                break;\n\n            case \"new-ice-candidate\": // A new ICE candidate has been received\n                this.newICECandidate(msg)\n                break;\n\n            case \"hang-up\": // The other peer has hung up the call\n                this.close()\n                break;\n        }\n    }\n</pre>\n<p>When a message comes in, we can do a couple different things. Set ourselves up as the answer party, add a new candidate to our connection, or close.</p>\n<p>Those functions are thin wrappers over WebRTC APIs.</p>\n<pre lang=\"javascript\">\n    videoAnswer = ({\n        sdp\n    }) => {\n        this.peerConnection\n            .setRemoteDescription(new RTCSessionDescription(sdp))\n            .catch(console.error);\n    }\n\n    newICECandidate = ({\n        candidate\n    }) => {\n        this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));\n    }\n    \n   close = () => {\n        this.peerConnection.close();\n        this.peerConnection = null;\n\n        this.onClose()\n    }\n</pre>\n<p>That&#8217;s our PeerConnection object. In theory, we could instantiate many of them to connect to multiple remote machines at the same time.</p>\n<p>That will be a fun experiment.</p>\n<img src=\"https://media.giphy.com/media/3o7TKT0XDElcmlCeNa/giphy.gif\" />\n<h3>Putting it all together</h3>\n<p>Holding it all together is our <code>WebRTCPeerConnectionWithServer</code> React component. It renders the UI, instantiates both helper classes from above, and handles the user clicking on buttons to drive the process.</p>\n<p>You can see <a href=\"https://github.com/Swizec/webrtc-sample/blob/master/src/WebRTCPeerConnectionWithServer.js\">the whole file on GitHub</a>.</p>\n<p>Here are the salient parts. ðŸ‘‡</p>\n<pre lang=\"javascript\">\n    call = user => {\n        this.setState({\n            targetUsername: user\n        });\n        this.createPeerConnection();\n    };\n\n    hangUp = () => {\n        this.signalingConnection.sendToServer({\n            name: this.state.username,\n            target: this.state.targetUsername,\n            type: \"hang-up\"\n        });\n        this.peerConnection.close();\n    };\n\n    createPeerConnection = () => {\n        if (this.peerConnection) return;\n\n        this.peerConnection = new PeerConnection({\n            gotRemoteStream: this.gotRemoteStream,\n            gotRemoteTrack: this.gotRemoteTrack,\n            signalingConnection: this.signalingConnection,\n            onClose: this.closeVideoCall,\n            localStream: this.state.localStream,\n            username: this.state.username,\n            targetUsername: this.state.targetUsername\n        });\n    };\n\n    closeVideoCall = () => {\n        this.remoteVideoRef.current.srcObject &&\n            this.remoteVideoRef.current.srcObject\n                .getTracks()\n                .forEach(track => track.stop());\n        this.remoteVideoRef.current.src = null;\n\n        this.setState({\n            targetUsername: null,\n            callDisabled: false\n        });\n    };\n</pre>\n<p><code>call</code> is where the fun starts. Saves whom we&#8217;re calling to state and creates a peer connection.</p>\n<p><code>createPeerConnection</code> passes all the things into our <code>PeerConnection</code> class.</p>\n<p><code>hangUp</code> and <code>closeVideoCall</code> work together to finish our call. We need both because one is user-driven and the other is called when hangup comes from the other side.</p>\n<h3>One last thing</h3>\n<p>There&#8217;s one message from the signaling server we have to handle in the glue area: An offer for a call.</p>\n<pre lang=\"javascript\">\n    case \"video-offer\": // Invitation and offer to chat\n        this.createPeerConnection();\n        this.peerConnection.videoOffer(msg);\n        break;\n</pre>\n<p>When the server tells us someone wants to connect, we have to create a new <code>PeerConnection</code> object on our client and handle the offer. Handling the offer means setting a remote SDP description and sending an answer.</p>\n<pre lang=\"javascript\">\n   videoOffer = ({\n        sdp\n    }) => {\n        const {\n            username,\n            targetUsername\n        } = this;\n\n        this.peerConnection\n            .setRemoteDescription(new RTCSessionDescription(sdp))\n            .then(() => this.peerConnection.createAnswer())\n            .then(answer => {\n                return this.peerConnection.setLocalDescription(answer);\n            })\n            .then(() => {\n                this.signalingConnection.sendToServer({\n                    name: username,\n                    targetUsername: targetUsername,\n                    type: \"video-answer\",\n                    sdp: this.peerConnection.localDescription\n                });\n            })\n            .catch(console.error);\n    }\n</pre>\n<p>ðŸ‘Œ</p>\n<h2>And then it works ðŸ¤ž</h2>\n<p>If all the stars align, you can now have a call between 2 browsers on different machines without talking to the server again.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">OMG IT WORKS! I got two browsers to talk to each other without a server</p>\n<p>Well &#8230; a server is used for the initial handshake. BUT THEN NO SERVER <a href=\"https://twitter.com/hashtag/WebRTC?src=hash&amp;ref_src=twsrc%5Etfw\">#WebRTC</a></p>\n<p>Article coming soon <a href=\"https://t.co/LRWVt4BhV8\">pic.twitter.com/LRWVt4BhV8</a></p>\n<p>&mdash; Swizec @ WeAreDevs ðŸ‡¦ðŸ‡¹ (@Swizec) <a href=\"https://twitter.com/Swizec/status/995933206187728896?ref_src=twsrc%5Etfw\">May 14, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"6a2852ab-50ab-532a-8db7-792c8f7d91a3"}}