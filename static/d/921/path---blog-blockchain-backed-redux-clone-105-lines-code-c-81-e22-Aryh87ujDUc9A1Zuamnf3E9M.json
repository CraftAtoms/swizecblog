{"data":{"wordpressPost":{"title":"A blockchain-backed Redux clone in 105 lines of code","content":"<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/kVLrT92US4U?feature=oembed\" frameborder=\"0\" gesture=\"media\" allow=\"encrypted-media\" allowfullscreen></iframe></p>\n<p><em><strong>Big fat disclaimer: This is Part 1 of an experiment. It is not yet secure, it does not yet share the blockchain between nodes, it still needs a proof-of-work or proof-of-stake algorithm.</strong></em></p>\n<p>With that out of the way, let us begin.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\">\n<p lang=\"en\" dir=\"ltr\">Redux is great because it does immutability right?</p>\n<p>Now imagjne this: Blockchain backed Redux. Every state change gets recorded to the blockchain. Immutable forever. Pure as dew ðŸ‘Œ</p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/938983218975449088?ref_src=twsrc%5Etfw\">December 8, 2017</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>Redux is great because it keeps a chain of immutable data forever. What if we backed that chain with a blockchain? What would happen? ðŸ¤”</p>\n<div id=\"attachment_7979\" style=\"width: 1414px\" class=\"wp-caption alignnone\"><img class=\"alignnone size-full wp-image-7979\" src=\"https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain.png\" alt=\"Blockchain in a nutshell\" width=\"1404\" height=\"1124\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain.png 1404w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain-300x240.png 300w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain-768x615.png 768w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain-1024x820.png 1024w\" sizes=\"(max-width: 1404px) 100vw, 1404px\" /><p class=\"wp-caption-text\">Blockchain in a nutshell</p></div>\n<p>So I fired up <a href=\"https://medium.com/@lhartikk/a-blockchain-in-200-lines-of-code-963cc1cc0e54\">this amazing Medium post</a> on building a blockchain in 200 lines of code and built a blockchain-backed Redux clone in about 2 hours.</p>\n<p>Mine is just 105 lines tho ðŸ˜›</p>\n<p>You can see the <a href=\"https://github.com/Swizec/blockchain-redux\">code on Github</a>. It&#8217;s not quite useful yet. The blockchain doesn&#8217;t get shared between nodes, and there&#8217;s no proof-of-stake or proof-of-work algorithm.</p>\n<p>That&#8217;s all coming soon. First, I wanted to make sure I understood both <a href=\"https://en.wikipedia.org/wiki/Blockchain\">blockchains</a> and Redux enough to make this work.</p>\n<h2>Blockchain</h2>\n<p>Turns out blockchains are pretty simple. It&#8217;s just a reversed linked list where every node holds some data, a hash, and points to the previous node.</p>\n<img src=\"https://cdn-images-1.medium.com/max/1600/1*pbyFH4U5sO27UE1EjnImoA.png\" alt=\"Image borrowed from Lauri Hartikka's post\" />\n<p>We use the hashes to verify our chain. Verification is important when we start sharing chains between nodes.</p>\n<p>Our blocks are JavaScript objects.</p>\n<pre lang=\"javascript\">\nclass Block {\n    constructor({ previousBlock, data }) {\n        this.index = previousBlock.index + 1;\n        this.previousHash = previousBlock.hash.toString();\n        this.timestamp = new Date().getTime() / 1000;\n        this.data = data;\n\n        this.hash = Block.calculateHash(this);\n    }\n\n    set data(data) {\n        this._data = JSON.stringify(data);\n    }\n\n    get data() {\n        return JSON.parse(this._data);\n    }\n\n    // this is where a Proof-of-Work or Proof-of-Stake algo comes in, I think\n    static calculateHash(block) {\n        return CryptoJS.SHA256(\n            block.index + block.previousHash + block.timestamp + block._data\n        ).toString();\n    }\n}\n</pre>\n<p>The <code>constructor</code> doubles as our block generator. It takes the <code>previousBlock</code> and some <code>data</code>, adds some metadata, and calculates a <code>hash</code>.</p>\n<p>A <code>data</code> setter and getter help us JSONify data transparently. Users can pass simple objects as data, and the blockchain will handle it.</p>\n<p>The <code>calculateHash</code> function right now just uses SHA256, but I think this is where a <a href=\"https://en.wikipedia.org/wiki/Proof-of-work_system\">proof of work</a> or a <a href=\"https://en.wikipedia.org/wiki/Proof-of-stake\">proof of stake</a> algorithm would come into play in a real blockchain. Haven&#8217;t figured that part out yet ðŸ™‚</p>\n<p>Kind of surprisingly, that&#8217;s all we need to build a blockchain. You could build it like this <code>new Block({ previousBlock: new Block({ previousBlock: genesisBlock, data: {hai: \"world\"}}), data: {hai2: \"world2\"}})</code></p>\n<p>But that&#8217;s cumbersome, so let&#8217;s add a Redux.</p>\n<h2>Redux</h2>\n<p>Redux, if you don&#8217;t know, is a state management approach based on the functional concept of a <code>reducer</code>. At each change, we take the current state and a change descriptor, and produce the next state.</p>\n<p>A tiny Redux implementation that maintains history would look something like this ðŸ‘‡</p>\n<pre lang=\"javascript\">\nfunction createStore(initialState, reducer) {\n    let state = [initialState];\n \n    function getState() {\n        return state[state.length-1];\n    }\n \n    function dispatch(action) {\n        state.push(reducer(getState(), action));\n    }\n \n    return {\n        getState: getState,\n        dispatch: dispatch\n    }\n}\n</pre>\n<p>ðŸ‘† That&#8217;s Redux in a nutshell. Unlike the real Redux, this one maintains history. We&#8217;ll expand that into a blockchain.</p>\n<p><code>getState</code> returns the latest state and <code>dispatch</code> takes an <code>action</code> and calculates the new state using the <code>reducer</code> function.</p>\n<p>Using this Redux to implement a counter looks like this ðŸ‘‡</p>\n<pre lang=\"javascript\">\nconst store = createStore({ counter: 0 }, rootReducer);\n\nfunction rootReducer(state, action) {\n    switch (action.type) {\n        case \"inc\":\n            return { counter: state.counter + 1 };\n        case \"dec\":\n            return { counter: state.counter - 1 };\n        default:\n            return state;\n    }\n}\n</pre>\n<p>We can use this to verify that it works. Using tape in this case because <a href=\"https://twitter.com/lukeed05\">LukeEd05</a> on the livestream suggested it.</p>\n<pre lang=\"javascript\">\ntest(\"count to 5\", t => {\n    for (let i = 0; i < 5; i++) {\n        store.dispatch({ type: \"inc\" });\n    }\n\n    t.equal(store.getState().counter, 5);\n    t.end();\n});\n</pre>\n<p>Works ðŸ‘Œ</p>\n<h2>blockchain-redux</h2>\n<p>Now, how do we add the blockchain? ðŸ¤”</p>\n<p>Well, instead of putting <code>initialState</code> directly into our state, we put a genesis Block with that state. And instead of pushing new state calculations directly, we add blocks.</p>\n<pre lang=\"javascript\">\nfunction createStore(initialState, reducer) {\n    let blockchain = [\n        new Block({ \n            previousBlock: {\n                index: 0,\n                hash: \"0\",\n                timestamp: new Date().getTime()\n            },\n            data: initialState\n        })\n    ];\n\n    function getLastBlock() {\n        return blockchain[blockchain.length - 1];\n    }\n\n    function dispatch(action) {\n        const lastBlock = getLastBlock();\n        const nextData = reducer(lastBlock.data, action);\n\n        addBlock(new Block({ previousBlock: lastBlock, data: nextData }));\n    }\n\n    function addBlock(newBlock) {\n        if (isValidNewBlock(newBlock, getLastBlock())) {\n            blockchain.push(newBlock);\n        }\n    }\n\n    function isValidNewBlock(newBlock, previousBlock) {\n        if (previousBlock.index + 1 !== newBlock.index) {\n            console.log(\"invalid index\");\n            return false;\n        } else if (previousBlock.hash !== newBlock.previousHash) {\n            console.log(\"invalid previoushash\");\n            return false;\n        } else if (Block.calculateHash(newBlock) !== newBlock.hash) {\n            console.log(\n                \"invalid hash: \",\n                Block.calculateHash(newBlock),\n                newBlock.hash\n            );\n            return false;\n        }\n        return true;\n    }\n\n    function isValidChain(blockchain) {\n        for (let i = 0; i < blockchain.length - 1; i++) {\n            if (!isValidNewBlock(blockchain[i + 1], blockchain[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function replaceChain(newBlocks) {\n        if (isValidChain(newBlocks) &#038;&#038; newBlocks.length > blockchain.length) {\n            blockchain = newBlocks;\n            // tell others here\n        }\n    }\n\n    return {\n        getState: () => getLastBlock().data,\n        getLastBlock: getLastBlock,\n        dispatch: dispatch,\n        addBlock: addBlock,\n        replaceChain: replaceChain, // primarily used when starting up to take latest available blockchain\n        _blockchain: blockchain\n    };\n}\n</pre>\n<p>Okay that's plenty of code to spring on you. Let's go through it function by function.</p>\n<h3>getState</h3>\n<pre lang=\"javascript\">\n    function getLastBlock() {\n        return blockchain[blockchain.length - 1];\n    }\n</pre>\n<p>Takes last block from the blockchain and returns it. That's our current state. We export a helper <code>getState</code> that does <code>getLastBlock().data</code> to avoid changing external APIs.</p>\n<h3>Dispatch</h3>\n<pre lang=\"javascript\">\n    function dispatch(action) {\n        const lastBlock = getLastBlock();\n        const nextData = reducer(lastBlock.data, action);\n\n        addBlock(new Block({ previousBlock: lastBlock, data: nextData }));\n    }\n</pre>\n<p>Same as <code>dispatch</code> before. Takes current state and builds new state with the <code>reducer</code>. Then it uses <code>addBlock</code> to insert a newly generated block into the chain.</p>\n<h3>isValidNewBlock</h3>\n<pre lang=\"javascript\">\n    function isValidNewBlock(newBlock, previousBlock) {\n        if (previousBlock.index + 1 !== newBlock.index) {\n            console.log(\"invalid index\");\n            return false;\n        } else if (previousBlock.hash !== newBlock.previousHash) {\n            console.log(\"invalid previoushash\");\n            return false;\n        } else if (Block.calculateHash(newBlock) !== newBlock.hash) {\n            console.log(\n                \"invalid hash: \",\n                Block.calculateHash(newBlock),\n                newBlock.hash\n            );\n            return false;\n        }\n        return true;\n    }\n</pre>\n<p>Every new block has to be validated. Especially because they can come from other nodes.</p>\n<p>This checks that indexes and hashes all match up so we can avoid conflicts.</p>\n<h3>isValidChain</h3>\n<pre lang=\"javascript\">\n   function isValidChain(blockchain) {\n        for (let i = 0; i < blockchain.length - 1; i++) {\n            if (!isValidNewBlock(blockchain[i + 1], blockchain[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n</pre>\n<p>This will be used later on in conflict resolution. It goes through an entire proposed chain and validates every block.</p>\n<h3>replaceChain</h3>\n<pre lang=\"javascript\">\n    function replaceChain(newBlocks) {\n        if (isValidChain(newBlocks) && newBlocks.length > blockchain.length) {\n            blockchain = newBlocks;\n            // tell others here\n        }\n    }\n</pre>\n<p>Another part of conflict resolution and node communication is replacing the whole chain. If a new valid chain comes in that's longer than what we already have, we replace our internal state with the new chain.</p>\n<p>This will be particularly useful when we boot up a new client and it needs to get the whole chain.</p>\n<h2>Fin</h2>\n<p>That's pretty much it. A naive blockchain implementation that gives you a Redux-like API to store and manipulate data.</p>\n<p>Next I'm going to add communication between nodes, probably through Firebase, and a proof-of-stake algorithm. Then we can start building something interesting.</p>\n<p>And maybe you now understand blockchains a little better ðŸ¤“</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"8d62cb6f-4351-52df-82b0-c2a984eea467"}}