{"data":{"wordpressPost":{"title":"Week 10, The myriad virtues of Wavelet Trees","content":"<p><em>[This post is part of an ongoing challenge to understand 52 papers in 52 weeks. You can read previous entries, <a href=\"http://swizec.com/blog/category/52-papers-in-52-weeks\">here</a>, or subscribe to be notified of new posts by <a href=\"http://swiz.ec/52papers-list\">email</a>]</em></p>\n<p><a href=\"http://www.sciencedirect.com/science/article/pii/S0890540108001594\">The Myriad Virtues of Wavelet Trees</a> is a 2009 CS paper written by Ferragina, Giancarlo, and Manzini. The holiday cheer the past few days made this one hard to understand and write about &#8230; something about focus.</p>\n<p>It talks about using Wavelet Trees as a stand-alone <a class=\"zem_slink\" title=\"Data compression\" href=\"http://en.wikipedia.org/wiki/Data_compression\" target=\"_blank\" rel=\"wikipedia\">compression algorithm</a> and as on top of some popular string encodings like run-length encoding, <a class=\"zem_slink\" title=\"Move-to-front transform\" href=\"http://en.wikipedia.org/wiki/Move-to-front_transform\" target=\"_blank\" rel=\"wikipedia\">move-to-front transform</a> and the <a class=\"zem_slink\" title=\"Burrows–Wheeler transform\" href=\"http://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform\" target=\"_blank\" rel=\"wikipedia\">Burrows-Wheeler transform</a>. The results are pretty cool, but not revolutionary. The authors just improved some additive terms in lower and upper bounds of achievable compression.</p>\n<h2 id=\"background-knowledge\">Background knowledge</h2>\n<p>Before we can get into the meat of this paper, you&#8217;ll need to know about Wavelet Trees and run-length encoding and Burrows-Wheeler and stuff. On my first run-through I didn&#8217;t pay attention in this section and spent the rest of the paper very confused.</p>\n<p><strong>Wavelet Trees</strong> recursively partition the source alphabet into pairs of subsets, then mark which branch of the tree a particular symbol goes into. To reconstruct elements at you just walk the tree until you find the leaf and voila, done.</p>\n<div style=\"width: 636px\" class=\"wp-caption alignnone\"><img title=\"Wavelet tree for the string &quot;abracadabra&quot;\" alt=\"Wavelet tree for the string &quot;abracadabra&quot;\" src=\"https://draftin.com:443/images/6200?token=YqJ09XgMHdRlEk_RteXA-5_JwQAAAi_s2AuaUugDwbzSuaK4iQcY7_BdTCXylnzuBjiY2dih3DB-KX250lWl-uw\" width=\"626\" height=\"494\" /><p class=\"wp-caption-text\">Wavelet tree for the string &#8220;abracadabra&#8221;</p></div>\n<p>Phew, that was simple. Now we just need the transforms.</p>\n<p>We can do to lower the <a class=\"zem_slink\" title=\"Entropy\" href=\"http://en.wikipedia.org/wiki/Entropy\" target=\"_blank\" rel=\"wikipedia\">entropy</a> of a string to make it easier to compress. Entropy is a measure of how disorganised our string is. You can also think of it as information density.</p>\n<p>The paper references two transforms whose aim is to turn a fuzzy string into a string with many runs of the same character: move to front and Burrows-Wheeler transform.</p>\n<p><strong>Move to front transform</strong> encodes strings into numbers with the help of an indexed alphabet. Every time you replace a character with its index, you move it to the front and re-index. Given a 25-letter English alphabet indexed from <code>0</code> to <code>25</code> the string <code>bananaaa</code> becomes <code>1,1,13,1,1,1,0,0</code>.</p>\n<p>To reverse the encoding you just re-do the same algorithm again, except replacing indexes with characters.</p>\n<p>The <strong>Burrows-Wheeler transform</strong> is a bit more complicated. This one uses sorted rotations of a string. Basically, take all permutations, sort them alphabetically, take the last column.</p>\n<div style=\"width: 620px\" class=\"wp-caption alignnone\"><img title=\"BANANA Burrows-Wheeler transform\" alt=\"BANANA Burrows-Wheeler transform\" src=\"https://draftin.com:443/images/6213?token=VHv7TtaKmtbeCyLz4HAMzCgCQp9lBQuPXHM47U_eaA0adrbJGrDdEiifgsX0iHcKR7NOxkp2OZTjDCIgJx6UAjk\" width=\"610\" height=\"260\" /><p class=\"wp-caption-text\">BANANA Burrows-Wheeler transform</p></div>\n<p>Reversing a transformed string is simple as well &#8211; take the transformed string and sort it. Now you have two columns. Take these pairs of characters and sort them to create more columns. Repeat until you have all the permutations of the original string and take the one where the end-of-file character is last. Voila.</p>\n<p>After you have a string transformed into a form with less entropy there are a number of things you can do to compress it. For instance, <strong>run-length encoding</strong> where runs of successive characters are replaced with a count of repetitions and the character. It&#8217;s not used much on its own anymore, but made a killing compressing simple black&amp;white images back in the day.</p>\n<h2 id=\"what-we're-looking-to-achieve\">What we&#8217;re looking to achieve</h2>\n<p>So how can wavelet trees help make all this better?</p>\n<p>The authors analyse Wavelet Trees as stand-alone compressors and as compressors of run-length encoded strings &#8211; <a class=\"zem_slink\" title=\"Run-length encoding\" href=\"http://en.wikipedia.org/wiki/Run-length_encoding\" target=\"_blank\" rel=\"wikipedia\">RLE</a> Wavelet Trees &#8211; and gap encoded string &#8211; GE Wavelet Trees. They also show a theoretical justification for Wavelet Trees being better in practice than move-to-front coding.</p>\n<p>The meat of the article is using Wavelet Trees to compress the output of the Burrows-Wheeler transform and introducing the concept of Generalised Wavelet Trees, which can reach compression almost on the level of theoretical bound for optimal coding even for mixed strings.</p>\n<p>Ultimately, we&#8217;re going to beat the theoretical compression limit <em>H<sub>0</sub> = -Σ<sub>i=1</sub><sup>h</sup>(n<sub>i</sub>/|s|) log (n<sub>i</sub>/|s|)</em> for fixed codewords. Otherwise known as 0-th order entropy. This is the most we can compress a string by always replacing the same symbol with the same codeword.</p>\n<p>For highly compressible strings this bound doesn&#8217;t make much sense, so the authors found a better one, <em>H<sub>0</sub></em>*:</p>\n<div style=\"width: 734px\" class=\"wp-caption alignnone\"><img title=\"0-th order entropy for highly compressible strings\" alt=\"0-th order entropy for highly compressible strings\" src=\"https://draftin.com:443/images/6217?token=pkPWKi3v7XY9yl_KO-YjTRzp3lrhxZfOH57AnLZrTlvBhcd_XUs49grW8g_8ts6xkJVF73hRzvFREvFK3DXcctk\" width=\"724\" height=\"132\" /><p class=\"wp-caption-text\">0-th order entropy for highly compressible strings</p></div>\n<p>Our approach is going to beat this by having symbol codewords depend on <em>k</em> preceding symbols, giving us k-th order entropy of <em>H<sub>k</sub></em>(s)* &#8211; the maximum achievable compression by looking at <em>no more than k</em> preceding symbols.</p>\n<h2 id=\"achieving-0-th-order-entropy\">Achieving 0-th order entropy</h2>\n<p>Let <em>C<sub>PF</sub></em> denote a prefix-free encoding with a logarithmic cost of <em>a log n + b</em> for <em>n ≥ 1</em>. Codes where <em>a</em> is higher than 2 wouldn&#8217;t be very efficient for reasons the paper assumes we understand, so we&#8217;re only looking at those where <em>a ≤ 2</em>. This means that <em>b ≥ 1</em>; for the rest of our discussion we can assume that <em>a ≤ 2b</em> and <em>a ≤ b+1</em>.</p>\n<p>To combine wavelet trees and run length encoding for a string we first define a compressor <em>C<sub>RLE</sub>(s) = a<sub>1</sub>C<sub>PF</sub>(l<sub>1</sub>)C<sub>PF</sub>(l<sub>2</sub>)&#8230;</em>. Which is a fancy way of saying we prefix-encode runs of symbols, but store the first symbol in full.</p>\n<p>This has a lower bound with a glorious equation, essentially saying that the length of a <em>C<sub>RLE</sub>(s)</em> string is the sum of its parts and is shorter than twice the length of <em>s</em> multiplied by <em>H<sub>0</sub></em>(s)* and <em>b+1</em>.</p>\n<div style=\"width: 804px\" class=\"wp-caption alignnone\"><img title=\"Length of C&lt;sub&gt;RLE&lt;/sub&gt;\" alt=\"Length of C&lt;sub&gt;RLE&lt;/sub&gt;\" src=\"https://draftin.com:443/images/6221?token=nFw2NehyCQtltjfwCPk_tlBpPszjXk8pINAjyDSDWUPz1tvuNjEs3ZYQyW0hTbubpCsdOqXR8uEeSO9vmIXEBsg\" width=\"794\" height=\"44\" /><p class=\"wp-caption-text\">Length of C<sub>RLE</sub></p></div>\n<p>Now we can combine wavelet trees and run length encoding into &#8216;rle_wt&#8217;, or <strong>RLE Wavelet Trees</strong>, which first encodes the string with <em>C<sub>PF</sub></em> to make a <a class=\"zem_slink\" title=\"Wavelet Tree\" href=\"http://en.wikipedia.org/wiki/Wavelet_Tree\" target=\"_blank\" rel=\"wikipedia\">Wavelet Tree</a>, then compresses its internal nodes with <em>C<sub>RLE</sub></em>. This produces shorter strings than just <em>C<sub>RLE</sub></em> with a bound of:</p>\n<div style=\"width: 810px\" class=\"wp-caption alignnone\"><img title=\"New bound\" alt=\"New bound\" src=\"https://draftin.com:443/images/6222?token=1LjM9AACdCZJhzUQVgqM_Zj1-Ja4unYg-A_iS9-JRdmcMDVn6kk4klpDOXPuRQ19MTVTpbUC1vRv9J9R_LeL0KA\" width=\"800\" height=\"46\" /><p class=\"wp-caption-text\">New bound</p></div>\n<p>I&#8217;m not entirely certain I understand why this equation says the bound is lower than before, so let&#8217;s just believe the authors. This produces better compressed strings.</p>\n<p>For string &#8216;dabbdabc&#8217; our algorithm would produce a skewed Wavelet Tree, with &#8216;b&#8217; in the left-most leaf since it appears the most.</p>\n<div style=\"width: 504px\" class=\"wp-caption alignnone\"><img title=\"Skewed Wavelet Tree\" alt=\"Skewed Wavelet Tree\" src=\"https://draftin.com:443/images/6223?token=Kkaf04BgYUvb22bbAOhA5Ia9coLyFOfx-MSPee4PNOGTiZ4P2BO66OgNltzSXJoo1D317oa5sy9SPWlk85U5dGg\" width=\"494\" height=\"293\" /><p class=\"wp-caption-text\">Skewed Wavelet Tree</p></div>\n<p>To get GE Wavelet Trees, &#8216;ge_wt&#8217;, we first define a gap encoding called <em>C<sub>Gap</sub></em>, which encodes binary strings by noting where 1&#8217;s are located in the string. This creates a lower bound for compression of:</p>\n<div style=\"width: 778px\" class=\"wp-caption alignnone\"><img title=\"C&lt;sub&gt;Gap&lt;/sub&gt; bound\" alt=\"C&lt;sub&gt;Gap&lt;/sub&gt; bound\" src=\"https://draftin.com:443/images/6224?token=bcbtj7iGc6jUZPdZ2jHwMa-1GUW8DCp62bAva3PYzxO9ObdOwRkJd-mN0a5o-FurqFMahUV5CXB2MrUWQKZu7Tg\" width=\"768\" height=\"49\" /><p class=\"wp-caption-text\">C<sub>Gap</sub> bound</p></div>\n<p>As with <em>C<sub>RLE</sub></em> before, we make a Wavelet Tree from our string then use <em>C<sub>Gap</sub></em> to encode the internal nodes. Because we&#8217;re just encoding the number of occurrences of a substring between boundaries, we can compress strings very well.</p>\n<div style=\"width: 803px\" class=\"wp-caption alignnone\"><img title=\"ge_wt bound\" alt=\"ge_wt bound\" src=\"https://draftin.com:443/images/6225?token=TZ7kuPwL9H-l4VXc84cnWRpM9a7ctaSji1zytRysVPJQnoI_UZ8cC6_ridXrzOx5Kazrg9tyShyfkb2M-jQIR0U\" width=\"793\" height=\"42\" /><p class=\"wp-caption-text\">ge_wt bound</p></div>\n<h2 id=\"rle-wavelet-trees-and-bwt\">RLE wavelet trees and bwt</h2>\n<p>It turns out that using RLE Wavelet Trees as a post-processor for the Burrows-Wheeler transform, we can achieve that mythical <em>H<sub>k</sub></em>* compression. But it doesn&#8217;t work at all with GE Wavelet Trees.</p>\n<p>The key is to remember that &#8216;bwt&#8217; is a tool for achieving <em>H<sub>k</sub></em>* as long as we can achieve <em>H<sub>0</sub></em>* for every partition. But apparently if we slice the Wavelet Tree according to &#8216;bwt&#8217; partitions we get something called a full Wavelet Tree, which doesn&#8217;t actually improve compression.</p>\n<p>Instead we have to use pruned Wavelet Trees, which the authors don&#8217;t really explain. They give a proof that adding Wavelet Trees on top of &#8216;bwt&#8217; is beneficial, which I won&#8217;t try to reproduce here since a large part of it is skipped and put in &#8220;the full version&#8221;.</p>\n<p>Their final conclusion is that Wavelet Trees act as a sort of compression booster for the Burrows-Wheeler transform, but impose a run-time cost that is non-negligible.</p>\n<p>Finally, they conclude that GE Wavelet Trees don&#8217;t work together with &#8216;bwt&#8217; because global choices need to be made about things like tree shape and the role of 1&#8217;s and 0&#8217;s in nodes. Bummer.</p>\n<h2 id=\"generalised-wavelet-trees\">Generalised wavelet trees</h2>\n<p>Three things affect a Wavelet Tree&#8217;s cost: its binary shape, the assignment of alphabet symbols to leaves, and the possibility of using non-binary compressors for nodes. To address these issues, the authors introduce so called Generalised Wavelet Trees.</p>\n<p>Let&#8217;s use two compressors &#8211; <em>C<sub>01</sub></em> is specialised for binary strings (RLE for instance), and <em>C<sub>Σ</sub></em> is generic (Huffman coding for instance). We&#8217;re going to assume they satisfy three properties:</p>\n<p>a) <em>|C<sub>01</sub>(x)| ≤ α|x|H<sub>0</sub></em>(x) + β* bits for a binary <em>x</em>, where α and β are constants. b) <em>|C<sub>Σ</sub>(y)| ≤ |y|H<sub>0</sub>(y) + η|y| + µ</em> bits for a generic <em>y</em>, where η and µ are constants. c) the running time of <em>C<sub>01</sub></em> and <em>C<sub>Σ</sub></em> is a convex function and their working space is non-decreasing</p>\n<p>Basically we&#8217;ve defined the limit of the longest strings produced by our compressors and decided that we should be able to use them in practice.</p>\n<p>Now we define a leaf cover, <em>L</em>, as a subset of nodes in a tree <em>W<sub>p</sub>(s)</em>, if every leaf has a unique ancestor in <em>L</em>. Then <em>W<sub>p</sub><sup>L</sup>(s)</em> is the tree with all nodes in <em>L</em> removed. We colour <em>W<sub>p</sub><sup>L</sup></em> with red and black so that leaves are black and all remaining nodes are red.</p>\n<p>Then we use the binary compressor for all binary strings in <em>W<sub>p</sub><sup>L</sup></em> and red stuff, and the generic compressor for non-binary strings and black. As usual we ignore the leaves. Our new cost is the number of bits produced &#8211; <em>|C<sub>01</sub>(s<sup>01</sup>(u))|</em> from red nodes and <em>|C<sub>Σ</sub>(s(u))|</em> for black nodes.</p>\n<p>According to the authors, coming up with a way to decode this encoding is trivial, and the whole thing is somehow &#8220;better&#8221;. I don&#8217;t quite <em>get</em> why it&#8217;s better, but I&#8217;m probably missing something.</p>\n<p>There are, however, two optimisation problems with this approach: finding the minimal leaf cover that minimizes the cost function <em>C</em>(W<sub>p</sub><sup>L</sup>(s))*, and finding the optimal combination of Wavelet Tree shape and and assignment of binary and generic compressors to nodes to produce the shortest string possible.</p>\n<p>They&#8217;ve provided a sketch of the algorithm to solve these, but ultimately a sketch does not a solution make.</p>\n<h2 id=\"fin\">Fin</h2>\n<p>So there you have it, Wavelet Trees used for compressing strings after applying the Burrows-Wheeler transform to make it easier. I&#8217;m not sure whether this is used anywhere in the real world, but it looks interesting.</p>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" alt=\"Enhanced by Zemanta\" src=\"http://img.zemanta.com/zemified_e.png?x-id=ff41ba4a-6ab1-4920-9eb4-03ac9fad006c\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"ff68dc5a-a188-5a0f-aaf5-cadcc7711cfd"}}