{"data":{"wordpressPost":{"title":"How you can translate any random D3 example to React","content":"<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/pzMTVChKvjo?feature=oembed\" frameborder=\"0\" allowfullscreen></iframe></p>\n<p>You and I both know that when it&#8217;s time to code some D3, the easiest approach is to find an example that does something similar, copy its code, and tweak it a bit.</p>\n<p>But a lot of those examples are in old versions of D3, and what if you&#8217;re using React or something and can&#8217;t just plop code into your project like nobody&#8217;s business? Here&#8217;s what you do:</p>\n<ol>\n<li>Find the example</li>\n<li>Split it up into styling, data calc, and rendering</li>\n<li>Put those in the appropriate place for your environment</li>\n</ol>\n<p>Let&#8217;s do that for this example of <a href=\"https://bl.ocks.org/mbostock/4657115\">113th Congressional District</a> from March 2016.</p>\n<img src=\"https://swizec.com/blog/wp-content/uploads/2017/08/2017-08-31-at-3.17-PM.png\" alt=\"\" class=\"alignnone size-full wp-image-7767\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/08/2017-08-31-at-3.17-PM.png 947w, https://swizec.com/blog/wp-content/uploads/2017/08/2017-08-31-at-3.17-PM-300x158.png 300w, https://swizec.com/blog/wp-content/uploads/2017/08/2017-08-31-at-3.17-PM-768x405.png 768w\" sizes=\"(max-width: 947px) 100vw, 947px\" />\n<p>The code starts with the usual HTML declarations, loading scripts, and a block of <code>&lt;style&gt;</code> stuff. Assuming we started our React app with <code>create-react-app</code>, we copy all the style info into <code>App.css</code>. That way we never have to worry about it again.</p>\n<p>We need styling because SVG elements are invisible by default.</p>\n<h2>Setup a component</h2>\n<p>To make our lives easy, we&#8217;re going to use the D3 blackbox approach to integration React and D3. By doing it this way, we can reuse all of the example code almost without change, and we lose most of React&#8217;s benefits. Great for slapping code together quickly, but I&#8217;d suggest a more structured approach for anything serious.</p>\n<p>We need a component:</p>\n<pre lang=\"javascript\">\n// src/CongressionalDistricts.js\n\nimport React, { Component } from 'react';\nimport * as topojson from 'topojson';\nimport * as d3 from 'd3';\n\nclass CongressionalDistricts extends Component {\n    state = {\n        usData: null,\n        usCongress: null\n    }\n\n    componentWillMount() {\n        // load data\n    }\n\n    componentDidUpdate() {\n        // render example D3\n    }\n\n    render() {\n        const { usData, usCongress } = this.state;\n\n        if (!usData || !usCongress) {\n            return null;\n        }\n\n        return <g ref=\"anchor\" />;\n    }\n}\n\nexport default CongressionalDistricts;\n</pre>\n<p>Our <code>CongressionalDistricts</code> component has three parts. We&#8217;re going to load data in <code>componentWillMount</code>, do all of our significant rendering in <code>componentDidUpdate</code>, and render an anchor element in <code>render</code>.</p>\n<p>This approach hands control of the DOM over to D3, which is why React can&#8217;t help us. Once we&#8217;re inside that anchor element, it&#8217;s all D3 with this approach.</p>\n<h2>Copypasta the code</h2>\n<p>Next in our example, we find the setup code.</p>\n<pre lang=\"javascript\">\nvar width = 960,\n    height = 600;\n\nvar projection = d3.geo.albersUsa()\n    .scale(1280)\n    .translate([width / 2, height / 2]);\n\nvar path = d3.geo.path()\n    .projection(projection);\n\nvar svg = d3.select(\"body\").append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n</pre>\n<p>This code is great, but has some problems.</p>\n<p>It&#8217;s still using <code>var</code> declarations, which are not encouraged in modern ES6. It also uses old D3 APIs which are going to fail when you run <code>npm install d3</code> because you&#8217;ll get the new D3v4 version.</p>\n<p>On a practical level, it&#8217;s setting up a new geographical projection, path generator, and creating an <code>svg</code> element. We can throw away the <code>svg</code> element creation because we&#8217;re wrapping our component in svg anyway.</p>\n<p>So we copy the projection and path setup into <code>componentDidUpdate</code> like this:</p>\n<pre lang=\"javascript\">\n// src/CongressionalDistricts.js\n    componentDidUpdate() {\n        const svg = d3.select(this.refs.anchor),\n              { width, height } = this.props;\n\n        const projection = d3.geoAlbers()\n                             .scale(1280)\n                             .translate([width / 2, height / 2]);\n\n        const path = d3.geoPath(projection);\n\n        const us = this.state.usData,\n              congress = this.state.usCongress;\n</pre>\n<p>We select our anchor element and name it <code>svg</code>. That way we won&#8217;t have to change any of the other code.</p>\n<p><code>d3.geo.albersUsa</code> becomes <code>d3.geoAlbers</code> and <code>d3.geo.path</code> becomes <code>d3.geoPath</code>. Same thing, simpler names. That&#8217;s the general principle behind the D3v3 to D3v4 transition.</p>\n<p>The example code assumes data is global, so we take it out of state and put it in variables. Again, so we don&#8217;t have to change any of the code.</p>\n<p>Next, the example loads its data.</p>\n<pre lang=\"javascript\">\nqueue()\n    .defer(d3.json, \"/mbostock/raw/4090846/us.json\")\n    .defer(d3.json, \"/mbostock/raw/4090846/us-congress-113.json\")\n    .await(ready);\n</pre>\n<p>This goes in our <code>componentWillMount</code> method. No sense fetching data before we know the component is getting mounted. And we definitely don&#8217;t want to do it on every render ðŸ™‚</p>\n<p>Also, we change the URLs and download those files into our <code>/public</code> folder.</p>\n<pre lang=\"javascript\">\n// src/CongressionalDistricts.js\n    componentWillMount() {\n        d3.queue()\n          .defer(d3.json, \"us.json\")\n          .defer(d3.json, \"us-congress-113.json\")\n          .await((error, usData, usCongress) => {\n              this.setState({\n                  usData,\n                  usCongress\n              });\n          })\n    }\n</pre>\n<p>This loads both datasets and updates component state, which triggers a re-render. Notice that with D3v4, <code>queue</code> is now an official part of D3. It helps us load multiple datasets sequentially.</p>\n<p>Now for the coup-de-grace: A massive copypasta that puts all the rendering code from our example into our React component. It&#8217;s messy but it works.</p>\n<pre lang=\"javascript\">\n// src/CongressionalDistricts.js\n\n    componentDidUpdate() {\n        const svg = d3.select(this.refs.anchor),\n              { width, height } = this.props;\n\n        const projection = d3.geoAlbers()\n                             .scale(1280)\n                             .translate([width / 2, height / 2]);\n\n        const path = d3.geoPath(projection);\n\n        const us = this.state.usData,\n              congress = this.state.usCongress;\n              \n        // Pure copypasta starts here\n        svg.append(\"defs\").append(\"path\")\n           .attr(\"id\", \"land\")\n           .datum(topojson.feature(us, us.objects.land))\n           .attr(\"d\", path);\n\n        svg.append(\"clipPath\")\n           .attr(\"id\", \"clip-land\")\n           .append(\"use\")\n           .attr(\"xlink:href\", \"#land\");\n\n        svg.append(\"g\")\n           .attr(\"class\", \"districts\")\n           .attr(\"clip-path\", \"url(#clip-land)\")\n           .selectAll(\"path\")\n           .data(topojson.feature(congress, congress.objects.districts).features)\n           .enter().append(\"path\")\n           .attr(\"d\", path)\n           .append(\"title\")\n           .text(function(d) { return d.id; });\n\n        svg.append(\"path\")\n           .attr(\"class\", \"district-boundaries\")\n           .datum(topojson.mesh(congress, congress.objects.districts, function(a, b) { return a !== b && (a.id / 1000 | 0) === (b.id / 1000 | 0); }))\n           .attr(\"d\", path);\n\n        svg.append(\"path\")\n           .attr(\"class\", \"state-boundaries\")\n           .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))\n           .attr(\"d\", path);\n    }\n\n</pre>\n<p>Copy all the code over, and you should get a map. It&#8217;s great.</p>\n<h2>Make it better</h2>\n<p>Now here&#8217;s what I&#8217;d do next. You see all those little <code>svg.append</code> calls? I&#8217;d change them to individual components.</p>\n<p>That way you could have a render method that looks more like this:</p>\n<pre lang=\"javascript\">\n<g>\n  <USLand />\n  <USStateBoundaries />\n    <USDistrictBoundaries />\n</g>\n</pre>\n<p>I think that sort of code is easier to understand.</p>\n<p>You can play with this example on Codepen ðŸ‘‡</p>\n<p class='codepen'  data-height='265' data-theme-id='0' data-slug-hash='GvPexr' data-default-tab='js,result' data-animations='run' data-editable='true' data-embed-version='2'>\nSee the Pen <a href='https://codepen.io/swizec/pen/GvPexr/'>113th congressional districts D3 example moved into React</a> by Swizec Teller (<a href='https://codepen.io/swizec'>@swizec</a>) on <a href='https://codepen.io'>CodePen</a>.0</p>\n<script async src=\"//codepen.io/assets/embed/ei.js\"></script>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"15df03ff-0a00-52be-9d5d-d904bfc86867"}}