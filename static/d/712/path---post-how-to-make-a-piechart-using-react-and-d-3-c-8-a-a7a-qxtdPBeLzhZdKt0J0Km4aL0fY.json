{"data":{"wordpressPost":{"title":"How to Make a Piechart using React and d3","content":"<p>Piecharts might be the single most mocked chart in the world, but they‚Äôre great. Is there a better way to show proportions?</p>\n<p>Of course, it all breaks down when you have more than a couple data points. And yes, it‚Äôs impossible to gauge the difference between 24% and 26% on a piechart. Not to mention the accessibility issues when the charts rely on colors to distinguish slices.</p>\n<p>If you google &#8220;never use a piechart‚Äù, 597,000 results show up. That‚Äôs a bunch of hate for the poor piechart.</p>\n<p><strong>But</strong> they‚Äôre easy and fun to make. They‚Äôre perfect for showing overwhelming proportions, and there‚Äôs nothing like a piechart to make an enterprise presentation more enterprisey.</p>\n<p>Especially if you make it 3D.</p>\n<p>When I say that a piechart is easy to make, I mean that with 86 lines of very beautiful and readable code, you can make one that looks great. 86 lines might sound like a lot for a piechart, but 33 of those are empty lines or closing braces. That‚Äôs 38%.</p>\n<p>Let me show you with a piechart üôÇ</p>\n<img class=\"size-medium wp-image-6789 aligncenter\" src=\"http://swizec.com/blog/wp-content/uploads/2016/04/Screen-Shot-2016-04-12-at-02.08.11-300x122.png\" alt=\"Screen Shot 2016-04-12 at 02.08.11\" srcset=\"https://swizec.com/blog/wp-content/uploads/2016/04/Screen-Shot-2016-04-12-at-02.08.11-300x122.png 300w, https://swizec.com/blog/wp-content/uploads/2016/04/Screen-Shot-2016-04-12-at-02.08.11.png 667w\" sizes=\"(max-width: 300px) 100vw, 300px\" />\n<p>See, piecharts <em>work</em>. To build this, we‚Äôre going to:</p>\n<ul>\n<li>use a d3 layout to calculate a piechart</li>\n<li>use React stuff to render the piechart</li>\n<li>build a generic Piechart component</li>\n</ul>\n<p>At the end of this tutorial, you‚Äôll have piechart component that you can use like this:</p>\n<pre lang=\"javascript\"><Piechart x={100} y={100} outerRadius={100} innerRadius={50}\r\n          data={[{value: 92-34, label: 'Code lines'},\r\n                 {value: 34, label: 'Empty lines'}]} />\r\n\r\n</pre>\n<p>Pretty great, huh?</p>\n<p>We‚Äôre going to build 3 components:</p>\n<ol>\n<li><code>Piechart</code> &#8211; the piechart itself</li>\n<li><code>Arc</code> &#8211; each of the slices</li>\n<li><code>LabeledArc</code> &#8211; a slice with some text</li>\n</ol>\n<h2 id=\"piechart\">Piechart</h2>\n<p>This is the piechart‚Äôs main component. It takes data and draws the arcs. That‚Äôs all it does.</p>\n<p>The component skeleton for <code>Piechart</code> looks like this:</p>\n<pre lang=\"javascript\">// ./src/components/Piechart/index.jsx\r\n\r\nimport React, { Component } from 'react';\r\n\r\nimport { LabeledArc } from './Arc';\r\n\r\nclass Piechart extends Component {\r\n    constructor() {\r\n    }\r\n\r\n    arcGenerator(d, i) {\r\n    }\r\n\r\n    render() {\r\n    }\r\n}\r\n\r\nexport default Piechart;\r\n</pre>\n<p>We start by importing react and the <code>LabeledArc</code> component, which we‚Äôll use for the arcs. The <code>constructor</code> is going to initialize d3‚Äôs pie layout, the <code>arcGenerator</code> is a helper function that makes our code easier to read, and <code>render</code> takes care of rendering.</p>\n<p>Yes, this is a simple component. As such, it doesn‚Äôt <em>really</em> need to be a class. It could be a functional stateless component, but the code looks messier to me.</p>\n<p>I‚Äôll show you the functional version later, and you can decide for yourself.</p>\n<p>Now, the <code>Piechart</code>‚Äôs constructor looks like this:</p>\n<pre lang=\"javascript\">// ./src/components/Piechart/index.jsx\r\nclass Piechart extends Component {\r\n    constructor() {\r\n        super();\r\n\r\n        this.pie = d3.layout.pie()\r\n                     .value((d) => d.value);\r\n        this.colors = d3.scale.category10();\r\n    }\r\n</pre>\n<p>We use <code>super()</code> to call the parent constructor, then initialize a pie layout with a basic value accessor. That tells it how to get values from our data.</p>\n<p>Of course, we could avoid this step and re-initialize a new pie layout on every render, but that seems wasteful.</p>\n<p>The layout is what turns the data into a piechart, by the way. It takes an array of values and returns an array of data in exactly the format that d3‚Äôs arc generator expects.</p>\n<p>It‚Äôs great. You‚Äôll see.</p>\n<p>We also initialize a color scale. We‚Äôll use it to give different colors to piechart slices.</p>\n<p>The next function we need is <code>arcGenerator</code>. This function returns a <code>LabeledArc</code> component with some props filled in. We <em>could</em> put this code in the iterator inside <code>render()</code>, but doing it that way gets messy and makes our code harder to read.</p>\n<pre lang=\"javascript\">// ./src/components/Piechart/index.jsx\r\narcGenerator(d, i) {\r\n        return (\r\n            <LabeledArc key={`arc-${i}`}\r\n                        data={d}\r\n                        innerRadius={this.props.innerRadius}\r\n                        outerRadius={this.props.outerRadius}\r\n                        color={this.colors(i)} />\r\n        );\r\n    }\r\n</pre>\n<p>We define a <code>key</code> because React yells at us otherwise. We use the current data points <code>data</code>, pass <code>innerRadius</code> and <code>outerRadius</code> from <code>Piechart</code>‚Äôs own props, and use the color scale to get a <code>color</code>.</p>\n<p>Now for the <code>render</code> function:</p>\n<pre lang=\"javascript\">// ./src/components/Piechart/index.jsx\r\n    render() {\r\n        let pie = this.pie(this.props.data),\r\n            translate = `translate(${this.props.x}, ${this.props.y})`;\r\n\r\n        return (\r\n            <g transform={translate}>\r\n                {pie.map((d, i) => this.arcGenerator(d, i))}\r\n            </g>\r\n        )\r\n    }\r\n</pre>\n<p>We use the data to generate a piechart with <code>this.pie</code>, set up a translation to move our piechart into desired position, then return a grouping element with a bunch of arcs.</p>\n<p>That‚Äôs it. Our piechart shows up on the screen.</p>\n<p>Or, well, an error shows up because <code>LabeledArc</code> doesn‚Äôt exist yet. But once we make that, a piechart is going to show up on screen.</p>\n<p>Here‚Äôs the same code as a functional stateless component. This snippet is 12 lines shorter, but I‚Äôm not sure it‚Äôs better, per se. It reinitializes both the pie layout and the colors scale on each render, and it awkwardly embeds <code>LabeledArc</code> in the iterator.</p>\n<pre lang=\"javascript\">const Piechart = ({x, y, innerRadius, outerRadius, data}) => {\r\n    let pie = d3.layout.pie()\r\n                .value((d) => d.value)(data),\r\n        translate = `translate(${x}, ${y})`,\r\n        colors = d3.scale.category10();\r\n\r\n    return (\r\n        <g transform={translate}>\r\n            {pie.map((d, i) => (\r\n                <LabeledArc key={`arc-${i}`}\r\n                            data={d}\r\n                            innerRadius={innerRadius}\r\n                            outerRadius={outerRadius}\r\n                            color={colors(i)} />))}\r\n        </g>\r\n    );\r\n}; \r\n</pre>\n<p>Use the approach you prefer. In this case, they both work essentially the same way.</p>\n<h2 id=\"arc\">Arc</h2>\n<p>Ok, we‚Äôve got the basic <code>Piechart</code>. It tries to draw arcs, but the component for them doesn‚Äôt exist yet.</p>\n<p>When you think about it, a <code>LabeledArc</code> is a type of <code>Arc</code>. It‚Äôs a component that draws a pie slice <em>and</em> a label. So it makes sense to build an <code>Arc</code> component first, then subclass it with <code>LabeledArc</code> and add some features.</p>\n<p>With ES6 classes, we can do that without funky JavaScript magic. Sure, Babel compiles it to weird funky magic, but we don‚Äôt have to worry about it.</p>\n<p>The base <code>Arc</code> class looks like this:</p>\n<pre lang=\"javascript\">// ./src/components/Piechart/index.jsx\r\nimport React, { Component } from 'react';\r\nimport d3 from 'd3';\r\n\r\nclass Arc extends Component {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    componentWillMount() {\r\n        this.updateD3(this.props);\r\n    }\r\n\r\n    componentWillReceiveProps(newProps) {\r\n        this.updateD3(newProps);\r\n    }\r\n\r\n    updateD3(newProps) {\r\n    }\r\n\r\n    render() {\r\n    }\r\n}\r\n\r\nexport default Arc;\r\n</pre>\n<p>We start by importing React and d3. Then, we define an <code>Arc</code> class which extends <code>Component</code>. In this case, we can‚Äôt use functional stateless components for two reasons:</p>\n<ol>\n<li>We need component lifecycle functions to update the internal state of our arc generator. I‚Äôll show you that in a bit.</li>\n<li>You can‚Äôt extend a function. We <em>could</em> play with functional composition, but in my experience, that sort of code, in JavaScript at least, is hard to read 2 months later. And it causes interesting issues when debugging.</li>\n</ol>\n<p>The <code>Arc</code> component has four methods: the constructor, the lifecycle hooks to call <code>updateD3</code>, the method that updates d3 internals‚Äô state, and the render method.</p>\n<p>All the constructor has to do is instantiate a new <code>d3.svg.arc</code> generator. That looks like this:</p>\n<pre lang=\"javascript\">// ./src/components/Piechart/index.jsx\r\nclass Arc extends Component {\r\n    constructor() {\r\n        super();\r\n\r\n        this.arc = d3.svg.arc();\r\n    }\r\n</pre>\n<p>We now have an instance of the arc generator, and we‚Äôre going to update its internals in <code>updateD3</code>. If we wanted to set up some arc defaults or constants, this would be a good place.</p>\n<p>If you aren‚Äôt familiar with arc generators, they‚Äôre these funny d3.js things that create SVG path definitions. For instance, the ‚Äú<em>Empty lines</em>‚Äù path definition in that screenshot you saw earlier looks like this:</p>\n<p><code>M-66.73188112222397,74.47721827437816A100,100 0 0,1 -1.8369701987210297e-14,-100L-9.184850993605149e-15,-50A50,50 0 0,0 -33.365940561111984,37.23860913718908Z</code>.</p>\n<p>You can define any shape in the world with an SVG path definition like that. But it‚Äôs not something you ever want to write by hand. Ever. Or even think about, really.</p>\n<p>So, when you want an arc, use <code>d3.svg.arc()</code> üôÇ</p>\n<p>The <code>updateD3</code> method looks like this:</p>\n<pre lang=\"javascript\">// ./src/components/Piechart/index.jsx\r\n    componentWillMount() {\r\n        this.updateD3(this.props);\r\n    }\r\n\r\n    componentWillReceiveProps(newProps) {\r\n        this.updateD3(newProps);\r\n    }\r\n\r\n    updateD3(newProps) {\r\n        this.arc.innerRadius(newProps.innerRadius);\r\n        this.arc.outerRadius(newProps.outerRadius);\r\n    }\r\n\r\n</pre>\n<p>Can you guess what happens here? We update our arc‚Äôs inner and outer radius. This lets the users of our component define how big they want arcs to be.</p>\n<p>Because d3 objects have internal state, we have to make sure to update them every time our props might have changed ‚Äì <code>componentWillMount</code> and <code>componentWillReceiveProps</code>.</p>\n<p>And yes, you‚Äôre right. We could reinitialize the arc on every render. And I still think that feels wasteful and unnecessary.</p>\n<p>Now for the <code>render</code> method. It looks like this:</p>\n<pre lang=\"javascript\">// ./src/components/Piechart/index.jsx\r\n    render() {\r\n        return (\r\n            <path d={this.arc(this.props.data)}\r\n                  style={{fill: this.props.color}}></path>\r\n        );\r\n    }\r\n</pre>\n<p>As I hinted earlier, we render an SVG path element. The shape definition ‚Äì <code>d</code> ‚Äì comes from <code>this.arc</code> and some data, and the color comes from <code>this.props.color</code>.</p>\n<p>You can render a piechart now. Wonderful, isn‚Äôt it? üôÇ</p>\n<img class=\"size-medium wp-image-6788 aligncenter\" src=\"http://swizec.com/blog/wp-content/uploads/2016/04/Screen-Shot-2016-04-12-at-02.08.26-300x118.png\" alt=\"Screen Shot 2016-04-12 at 02.08.26\" srcset=\"https://swizec.com/blog/wp-content/uploads/2016/04/Screen-Shot-2016-04-12-at-02.08.26-300x118.png 300w, https://swizec.com/blog/wp-content/uploads/2016/04/Screen-Shot-2016-04-12-at-02.08.26.png 651w\" sizes=\"(max-width: 300px) 100vw, 300px\" />\n<h2 id=\"labeledarc\">LabeledArc</h2>\n<p>Piecharts stand on shaky ground as it is. Almost everybody who‚Äôs into dataviz hates them. Almost everybody who‚Äôs into business intelligence loves them.</p>\n<p>Both groups hate <em>unlabeled</em> piecharts, though. Let‚Äôs take care of that.</p>\n<p>To add labels, we‚Äôre going to build a <code>LabeledArc</code> component that subclasses <code>Arc</code>. It‚Äôs what classes are for, right?</p>\n<p>Now, even though this component is a fancy render function, we <em>cannot</em> make it a functional stateless component. We need a reference to the arc generator when calculating coordinates for the label.</p>\n<p>Let me show you. <code>LabeledArc</code> looks like this:</p>\n<pre lang=\"javascript\">// ./src/components/Piechart/index.jsx\r\nclass LabeledArc extends Arc {\r\n    render() {\r\n        let [labelX, labelY] = this.arc.centroid(this.props.data),\r\n            labelTranslate = `translate(${labelX}, ${labelY})`;\r\n\r\n        return (\r\n            <g>\r\n                {super.render()}\r\n                <text transform={labelTranslate}\r\n                      textAnchor=\"middle\">\r\n                    {this.props.data.data.label}\r\n                </text>\r\n            </g>\r\n        );\r\n    }\r\n}\r\n\r\nexport { LabeledArc };\r\n</pre>\n<p>We calculate <code>labelX</code> and <code>labelY</code> with <code>this.arc.centroid(data)</code>. This gives us the center point of an arc. I don‚Äôt know how the math works. All I know is that it works and that I‚Äôm happy somebody made it for me.</p>\n<p>Notice how we can use <code>this.arc</code> as if it was defined inside <code>LabeledArc</code>. Subclassing is great like that. Don‚Äôt go overboard and become an <a href=\"https://www.google.com/search?q=architecture+astronaut&amp;oq=architecture+astronaut&amp;aqs=chrome..69i57j0l5.2833j0j1&amp;sourceid=chrome&amp;ie=UTF-8\">architecture astronaut</a>.</p>\n<p>Next, we put these coordinates into the usual SVG <code>translate</code> transformation and render a grouping element with an arc and a label. We get the arc itself with <code>super.render()</code>, which calls the parent render function, and the label as a <code>text</code> element.</p>\n<p>I know using <code>this.props.data.data.label</code> to get the text looks weird, but that‚Äôs how it works. <code>this.props.data</code> is a single datapoint in the entire piechart, its <code>.data</code> property is where d3‚Äôs pie layout puts original data, and <code>.label</code> is how our base data defined labels. It works.</p>\n<p>Our piechart‚Äôs code profile piechart looks like this:</p>\n<img class=\"size-medium wp-image-6789 aligncenter\" src=\"http://swizec.com/blog/wp-content/uploads/2016/04/Screen-Shot-2016-04-12-at-02.08.11-300x122.png\" alt=\"Screen Shot 2016-04-12 at 02.08.11\" srcset=\"https://swizec.com/blog/wp-content/uploads/2016/04/Screen-Shot-2016-04-12-at-02.08.11-300x122.png 300w, https://swizec.com/blog/wp-content/uploads/2016/04/Screen-Shot-2016-04-12-at-02.08.11.png 667w\" sizes=\"(max-width: 300px) 100vw, 300px\" />\n<p>Wonderful.</p>\n<h2 id=\"voil√†\">Voil√†</h2>\n<p>You now have a generic piechart component that you can copy-pasta around your codebase whenever you want.</p>\n<p>Need a piechart? Use <code>&lt;Piechart&gt;</code> and give it some props. The component has you covered.</p>\n<p>To recap, here‚Äôs what we learned:</p>\n<ul>\n<li>Piecharts are okay, but not great, dataviz</li>\n<li>A Piechart takes <strong>53 lines of real code</strong> to make</li>\n<li>41 lines with some boilerplate reduction</li>\n<li>A Piechart is made up of 3 components: Piechart, Arc, LabeledArc</li>\n<li>D3 makes the hard maths trivial</li>\n<li>ES6 classes and subclassing are great</li>\n</ul>\n<p>You can learn more about using React and d3js together in my new book, React+d3js ES6, <a href=\"http://swizec.com/reactd3js/\">here</a>.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"924d562b-3147-5822-b80f-80799b62adcb"}}