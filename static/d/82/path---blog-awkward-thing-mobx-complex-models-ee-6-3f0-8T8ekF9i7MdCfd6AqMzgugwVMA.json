{"data":{"wordpressPost":{"title":"One awkward thing about MobX: Complex models","content":"<p>Let&#39;s take an example from <a href=\"https://www.yup.com\">my day job</a>. An onboarding step for new tutors is a subject exam. It starts with this page:</p>\n<img class=\"alignnone size-full wp-image-7259\" src=\"https://swizec.com/blog/wp-content/uploads/2016/12/Screen-Shot-2016-12-02-at-07.59.53.png\" width=\"724\" height=\"304\" srcset=\"https://swizec.com/blog/wp-content/uploads/2016/12/Screen-Shot-2016-12-02-at-07.59.53.png 724w, https://swizec.com/blog/wp-content/uploads/2016/12/Screen-Shot-2016-12-02-at-07.59.53-300x126.png 300w\" sizes=\"(max-width: 724px) 100vw, 724px\" />\n<p>In this case, the applicant has already flunked chemistry, we&#39;re not accepting physics, and they can still take a math exam. To build this, we need data about the current user, about the subjects, and how they relate to each other.</p>\n<h2>Basic API-backed MobX model</h2>\n<p>Building a basic model with MobX is straightforward once you discover <code>extendObservable</code>. It&#39;s a store that gets its properties from the API.</p>\n<p>A <code>User</code> model might look like this:</p>\n<pre lang=\"javascript\">\nclass User {\n    constructor(mainStore, id) {\n        this.mainStore = mainStore;\n        this.id = id;\n     \n        this.fetchFromAPI()\n    }\n \n    @computed get url() {\n        return `/api/users/${id}`;\n    }\n \n    @action fetchFromAPI() {\n        fetch(this.url)\n            .then(response => response.json())\n            .then(action('set-user-params', json => {\n                extendObservable(json);\n            }));\n    }\n}\n</pre>\n<p>The <code>constructor</code> takes a user <code>id</code> and a <code>mainStore</code> reference. Having that reference to a parent store is often useful when spelunking through your data model. I learned that the hard way ?</p>\n<p>We call <code>fetchFromAPI</code> to fetch the user data, use a <code>url</code> computed value for the URL, and naively use <code>extendObservable</code> to set all the API data as observables on our <code>User</code> model.</p>\n<p>This approach embraces <a href=\"https://en.wikipedia.org/wiki/Duck_typing\">duck typing</a>. There&#8217;s no advance declaration of what a user model looks like. No description of properties, nothing you can rely on just by looking at the code. You&#8217;re just gonna have to try to access a property and hope it works.</p>\n<p>But when your model looks like this:</p>\n<img class=\"alignnone size-full wp-image-7258\" src=\"https://swizec.com/blog/wp-content/uploads/2016/12/Screen-Shot-2016-12-02-at-08.21.44.png\" width=\"989\" height=\"531\" srcset=\"https://swizec.com/blog/wp-content/uploads/2016/12/Screen-Shot-2016-12-02-at-08.21.44.png 989w, https://swizec.com/blog/wp-content/uploads/2016/12/Screen-Shot-2016-12-02-at-08.21.44-300x161.png 300w, https://swizec.com/blog/wp-content/uploads/2016/12/Screen-Shot-2016-12-02-at-08.21.44-768x412.png 768w\" sizes=\"(max-width: 989px) 100vw, 989px\" />\n<p>Do you really want to type all of that out? No, you don&#8217;t.</p>\n<p><code>extendObservable</code> is a convenient approach for these situations. It gives you infinite flexibility and makes properties deeply observable.</p>\n<p>That means using things like <code>user.subject_statuses[0].can_start_exam</code> Just Works™. You should be careful about undefineds, though. Until the API call goes through, anything beyond <code>user.</code> is undefined. That part is annoying.</p>\n<p>Sidenote:</p>\n<p>You can fake a <a href=\"#\">maybe monad</a> in MobX using <code>when</code>, like this:</p>\n<pre lang=\"javascript\">\nwhen(() => user.subject_statuses,\n        () => // do stuff with data)\n</pre>\n<img src=\"https://media.giphy.com/media/IeLOBZb7ZdQ1G/giphy.gif\" />\n<h2>Connecting models is where things get awkward</h2>\n<p>Let&#8217;s have a <code>mainStore</code> that looks a lot like the <code>User</code> model above. It may look like the <code>User</code> model, but it fetches a bunch of things about the environment, one of which is the current user&#8217;s id, another of which is a list of subjects.</p>\n<pre lang=\"javascript\">\nconst MainStore {\n    @observable currentUser = null;\n \n    constructor() {\n        fetch('/api/environment_data')\n            .then(response => response.json())\n            .then(this.setData);\n    }\n \n    @action setData(json) {\n        this.currentUser = new User(this, json.currentUser.id);\n        delete json.currentUser;\n     \n        extendObservable(this, json);\n    }\n}\n</pre>\n<p>Whoa, did you see that? We fetched data, took the <code>currentUser.id</code>, then deleted <code>currentUser</code> before using <code>extendObservable</code>. Wat.</p>\n<p>The API returns an object with many properties. In our example, let&#8217;s assume it looks like this:</p>\n<pre lang=\"javascript\">\n{\n    currentUser: {\n        id: N,\n        // other stuff, maybe\n    },\n    subjects: [\n        {id: N, name: 'Math'},\n        {id: N, name: 'Chemistry'},\n        // ...\n    ]\n}\n</pre>\n<p>We want to avoid writing a bunch of boilerplate, so we use the <code>extendObservable</code> trick to set everything. But we don&#8217;t want to overwrite our custom <code>currentUser</code>, which is a proper MobX model, not just an observable.</p>\n<p>So we have to delete that part of the data before extending. Awkward.</p>\n<p>And <em>why</em> do we want <code>User</code> to be more than just an observable? Because it&#8217;s going to need <code>@computed</code> values. We might re-fetch the model at random points or perform many actions that save stuff to the backend, change frontend state, and so on.</p>\n<p>Dealing with all of that in <code>MainStore</code> would get hairy fast.</p>\n<p>You&#8217;re right. From the perspective of this example, that&#8217;s a total <a href=\"https://en.wikipedia.org/wiki/You_aren't_gonna_need_it\">YAGNI</a> &#8211; ya ain&#8217;t gonna need it. But bear with me.</p>\n<h2>Add the domain logic, increase the awkward</h2>\n<p>Using the above <code>MainStore</code>, rendering a subject picker is straight forward. Loop through observable list of subjects, render elements. If something changes, MobX takes care of it.</p>\n<p>Not that the number or naming of subjects ever changes.</p>\n<pre lang=\"javascript\">\nconst SubjectPicker = inject('mainStore')(observer(({ mainStore }) => {\n    if (mainStore.subjects) {\n        return (\n            <div>\n                {mainStore.subjects.map((s, i) =>\n                    <Subject subject={s} key={i} />\n                 )}\n            </div>\n        );\n    } else {\n        return null;\n    }\n}));\n</pre>\n<p>Assume we put an instance of <code>MainStore</code> in a <code><Provider></code> as <code>mainStore</code>. That gives us global access via <code>inject</code> and cleans up our codebase.</p>\n<p>A simplified <code><Subject></code> component would look like this:</p>\n<pre lang=\"javascript\">\nconst Subject = observer(({ subject }) => (\n    <div>\n        <h3>{subject.name}</h3>\n        {subject.userStatus.can_start_exam ? 'Go for it' : 'LoL Nope.'}\n    </div>\n));\n</pre>\n<p>Not as pretty as the screenshot, but all that HTML and styling is irrelevant right now, so I took it out. Ours renders the subject name in an <code>h3</code> tag, and a string <code>Go for it</code> if you can take this exam or <code>LoL Nope</code> if you can&#8217;t.</p>\n<p>Now, the trouble; can you see it?</p>\n<p>It&#8217;s that <code>subject.userStatus.can_start_exam</code> bit. You see, we&#8217;ve found ourselves staring at a piece of data that lies <em>between</em> concepts.</p>\n<p>Ask a subject if it&#8217;s startable and it needs to know who you&#8217;re asking about. Ask a user and it needs to know which subject you&#8217;re asking about. It <em>smells</em> like a computable value, but where?</p>\n<p>Computables can&#8217;t take arguments.</p>\n<p>So even though the <code>User</code> model has this data – stored in <code>subject_statuses</code> – we can&#8217;t put the computed there. It can&#8217;t go in <code>MainStore</code> either because that too would require arguments.</p>\n<p><em>&#8220;Dude, it&#8217;s called a method. Just use a method&#8221;</em>, right?</p>\n<p>Yes, methods and functions can take arguments. But MobX computeds are preferable because they automagically observe values, memoize their results, and so on. Cleaner code. Faster code.</p>\n<p>We need a new <code>Subject</code> model that knows about <code>currentUser</code>. It looks like this:</p>\n<pre lang=\"javascript\">\nclass Subject {\n    @observable currentUser = null;\n\n    constructor(currentUser, data) {\n        this.currentUser = currentUser;\n        extendObservable(this, data);\n    }\n\n    @computed get userStatus() {\n        return this.currentUser.subject_statuses\n                            .find(s => this.id === s.subject_id);\n    }\n}\n</pre>\n<p>It takes a reference to <code>currentUser</code> and raw data about itself then uses <code>extendObservable</code> to set it all up. We&#8217;ve added a computed <code>userStatus</code> method that goes to <code>currentUser</code> and finds the correct data.</p>\n<p>This part is awkward, too. A model that returns information from a different model? Wat.</p>\n<p>I&#8217;m not sure. Maybe it&#8217;s dumb. Maybe I&#8217;m dumb. I think it makes sense.</p>\n<p>Anyway, in <code>MainStore</code>, we now do something like this:</p>\n<pre lang=\"javascript\">\n    @action setData(json) {\n        this.currentUser = new User(this, json.currentUser.id);\n        delete json.currentUser;\n     \n        this.subjects = json.subjects.map(\n            s => new Subject(this.currentUser, s)\n        );\n        delete json.subjects;\n     \n        extendObservable(this, json);\n    }\n</pre>\n<p>Not very elegant, is it? And I think the <code>subjects</code> array stopped being observable in the process, so we have to add it as an <code>@observable</code> property explicitly.</p>\n<h2>Conclusion</h2>\n<ol>\n<li>Use <code>extendObservable</code> to load and create large models</li>\n<li>Create new models when submodels need <code>@action</code>s or <code>@computed</code>s</li>\n<li>Do the <code>new Model</code> then <code>delete</code> dance when that happens</li>\n</ol>\n<p>It would be nice if <code>extendObservable</code> could do this for us. I&#39;m sure it&#39;s possible as long as model constructors are forced to follow a common pattern.</p>\n<p>But maybe that exists already and I don&#39;t know about it? Would def be a fun opensource project. ?</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"8658517d-84f6-517d-9674-3096b5bff519"}}