{"data":{"wordpressPost":{"title":"Aho-Corasick string matching algorithm in Haskell","content":"<p>Let&#8217;s say you have a large piece of text and a dictionary of keywords. How do you quickly locate all the keywords?</p>\n<div style=\"width: 307px\" class=\"wp-caption alignright\"><img class=\" \" title=\"Aho-Corasick algorithm diagram\" src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/9/90/A_diagram_of_the_Aho-Corasick_string_search_algorithm.svg/424px-A_diagram_of_the_Aho-Corasick_string_search_algorithm.svg.png\" alt=\"Aho-Corasick algorithm diagram\" width=\"297\" height=\"419\" /><p class=\"wp-caption-text\">Aho-Corasick algorithm diagram</p></div>\n<p>Well, there are many ways really, you could even iterate through the whole thing and compare words to keywords. But it turns out that&#8217;s going to be very slow. At least <em>O(N_keywords * N_words)</em>Â complexity. Essentially you&#8217;re making as many passes over the text as your dictionary is big.</p>\n<p>In 1975 a couple of IBM researchers &#8211; Alfred Aho and Margaret Corasick &#8211; discovered an algorithm that can do this in a single pass. The <a class=\"zem_slink\" title=\"Ahoâ€“Corasick string matching algorithm\" href=\"http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm\" rel=\"wikipedia\" target=\"_blank\">Aho-Corasick string matching algorithm</a>.</p>\n<p>I implemented it in Haskell and it takes <strong><em>0.005s</em></strong>Â to find 8 different keywords in <a href=\"http://en.wikisource.org/wiki/The_Nightingale_and_the_Rose\" target=\"_blank\">Oscar Wilde&#8217;s The Nightingale and The Rose</a> &#8211; a 12kb text.</p>\n<p>A quick naive keyword search implemented in python takes <em>0.023s</em>. Not a big difference practically speaking, but imagine Â a situation with megabytes of text and thousands of words in the dictionary. The authors mention <em>printing out the result</em>Â as a major bottleneck in their assessment of the algorithm.</p>\n<p>Yep, <em>printing</em>.</p>\n<h2>The Aho-Corasick algorithm</h2>\n<p>At the core of this algorithm are three functions:</p>\n<div id=\"attachment_5377\" style=\"width: 306px\" class=\"wp-caption alignright\"><a href=\"http://swizec.com/blog/wp-content/uploads/2012/10/aho-corasick-algorithm.png\"><img class=\" wp-image-5377 \" title=\"The three functions of aho-corasick algorithm\" src=\"http://swizec.com/blog/wp-content/uploads/2012/10/aho-corasick-algorithm.png\" alt=\"The three functions of aho-corasick algorithm\" width=\"296\" height=\"383\" srcset=\"https://swizec.com/blog/wp-content/uploads/2012/10/aho-corasick-algorithm.png 423w, https://swizec.com/blog/wp-content/uploads/2012/10/aho-corasick-algorithm-231x300.png 231w\" sizes=\"(max-width: 296px) 100vw, 296px\" /></a><p class=\"wp-caption-text\">The three functions of aho-corasick algorithm</p></div>\n<ul>\n<li>a parser based on a state machine, which maps <em>(state, char)</em>Â pairs to states and occasionally emits an output. This is called the <em>Goto</em>Â function</li>\n<li>a <em>Failure</em>Â function, which tells the <em>Goto</em>Â function which state to jump into when the character it just read doesn&#8217;t match anything</li>\n<li>an <em>Output</em>Â function, which maps states to outputs &#8211; potentially more than one per state</li>\n</ul>\n<p>The algorithm works in two stages. It will first construct the <em>Goto, Failure</em>Â and <em>Output</em>Â functions. The complexity of this operation hinges solely on the size of our dictionary. Then it iterates over the input text to produce all the matches.</p>\n<p>Using <a class=\"zem_slink\" title=\"Finite-state machine\" href=\"http://en.wikipedia.org/wiki/Finite-state_machine\" rel=\"wikipedia\" target=\"_blank\">state machines</a> for parsing text is a well known trick &#8211; the real genius of this algorithm rests in that <em>Failure </em>function if you ask me. It makes lateral transitions between states when the algorithm climbs itself into a wall.</p>\n<p>Say you have <em>she</em>Â and <em>hers</em>Â in the dictionary.</p>\n<p>The <em>Goto</em>Â machine eats your input string one character at the time. Let&#8217;s say it&#8217;s already read s<em>h</em>. The next input is an <em>e</em>Â so it outputs <em>she</em>Â and reaches a final state. Next it reads an <em>r</em>, but the state didn&#8217;t expect any more inputs, so the <em>Failure</em>Â function puts us on the path towards <em>hers</em>.</p>\n<p>This is a bit tricky to explain in text, I suggest you look at the picture from the original article and look at what&#8217;s happening.</p>\n<h2>My Haskell implementation</h2>\n<p>The first implementation I tried, relied on manully mapping inputs to outputs for the <em>Goto, Failure</em>Â and <em>Output</em>Â functions by using pattern recognition. Not very pretty, extremely hardcoded, but it worked and was easy to make.</p>\n<p>Building the functions dynamically proved a bit trickier.</p>\n<pre lang=\"haskell\">type Goto = Map (Int, Char) Int\r\ntype Failure = Map Int Int\r\ntype Output = Map Int [String]</pre>\n<p>First off, we build the <em>Goto</em> function.</p>\n<pre lang=\"haskell\">-- builds the goto function\r\nbuild_goto::Goto -> String -> (Goto, String)\r\nbuild_goto m s = (add_one 0 m s, s)\r\n\r\n-- adds one string to goto function\r\nadd_one::Int -> Goto -> [Char] -> Goto\r\nadd_one _  m [] = m\r\nadd_one state m (c:rest)\r\n  | member key m = add_one (fromMaybe 0 $ Map.lookup key m) m rest\r\n  | otherwise = add_one max (Map.insert key max m) rest\r\n  where key = (state, c)\r\n        max = (size m)+1</pre>\n<p>Essentially this builds a flattened prefix tree in a HashMap of <em>(state, char)</em> pairs mapping to the next state. It makes sure to avoid adding new edges to the three as much as possible.</p>\n<p>The reason it&#8217;s not simply a prefix tree are those lateral transitions; doing them in a tree would require backtracking and repeating of steps, so we haven&#8217;t achieved anything.</p>\n<p>Once we have the <em>Goto</em> function, building the <em>Output</em> is trivial.</p>\n<pre lang=\"haskell\">-- builds the output function\r\nbuild_output::(?m::Goto) => [String] -> Output\r\nbuild_output [] = empty\r\nbuild_output (s:rest) = Map.insert (fin 0 s)\r\n                          (List.filter (\\x -> elem x dictionary) $ List.tails s) $\r\n                          build_output rest\r\n\r\n-- returns the state in which an input string ends without using failures\r\nfin::(?m::Goto) => Int -> [Char] -> Int\r\nfin state [] = state\r\nfin state (c:rest) = fin next rest\r\n  where next = fromMaybe 0 $ Map.lookup (state, c) ?m</pre>\n<p>We are essentially going over the dictionary, finding the final state for each word and building a hash table mapping final states to their outputs.</p>\n<p>Building the <em>Failure</em> function was trickiest, because we need a way to iterate over the <em>depths</em> at which nodes are position in the <em>Goto</em> state machine. But we threw that info away by using a HashMap.</p>\n<pre lang=\"haskell\">-- tells us which nodes in the goto state machine are at which traversal depth\r\nnodes_at_depths::(?m::Goto) => [[Int]]\r\nnodes_at_depths =\r\n  List.map (\\i ->\r\n                  List.filter (>0) $\r\n                  List.map (\\l -> if i < length l then l!!i else -1)\r\n                  paths)\r\n           [0..(maximum $ List.map length paths)-1]\r\n  where paths = List.map (path 0) dictionary</pre>\n<p>We now have a list of lists, that tells us at which depth certain nodes are.</p>\n<pre lang=\"haskell\">-- builds the failure function\r\nbuild_fail::(?m::Goto) => [[Int]] -> Int -> Failure\r\nbuild_fail nodes 0 = fst $\r\n                  mapAccumL (\\f state ->\r\n                              (Map.insert state 0 f, state))\r\n                  empty (nodes!!0)\r\nbuild_fail nodes d = fst $\r\n                  mapAccumL (\\f state ->\r\n                              (Map.insert state (decide_fail state lower) f, state))\r\n                  lower (nodes!!d)\r\n  where lower = build_fail nodes (d-1)\r\n\r\n-- inner step of building the failure function\r\ndecide_fail::(?m::Goto) => Int -> Failure -> Int\r\ndecide_fail state lower = findWithDefault 0 (s, c) ?m\r\n  where (s', c) = key' state $ assocs ?m\r\n        s = findWithDefault 0 s' lower\r\n\r\n-- gives us the key associated with a certain state (how to get there)\r\nkey'::Int -> [((Int, Char), Int)] -> (Int, Char)\r\nkey' _ [] = (-1, '_') -- this is ugly, being of Maybe type would be better\r\nkey' state ((k, v):rest)\r\n  | state == v = k\r\n  | otherwise = key' state rest</pre>\n<p>Here we are going over the list of nodes at depths and deciding what the failure should be for each depth based on the failures of depth-1. At depth zero, all failures go to the zeroth state.</p>\n<p>An important part of this process was inverting the <em>Goto</em> HashMap so values point to keys, which is essentially what the <em>key'</em> function does.</p>\n<p>Finally, we can use the whole algorithm like this:</p>\n<pre lang=\"haskell\">main = do\r\n  let ?m = fst $ mapAccumL build_goto empty dictionary\r\n  let ?f = build_fail nodes_at_depths $ (length $ nodes_at_depths)-1\r\n      ?out = build_output dictionary\r\n\r\n  print $ ahocorasick text</pre>\n<p>A bit more involved than the usual example of Haskell found online, it's still pretty cool ðŸ™‚</p>\n<p>You can see the whole code on github <a href=\"https://github.com/Swizec/random-coding/blob/master/aho-corasick.hs\" target=\"_blank\">here</a>.</p>\n<h6 class=\"zemanta-related-title\" style=\"font-size: 1em;\">Related articles</h6>\n<ul class=\"zemanta-article-ul zemanta-article-ul-image\" style=\"margin: 0; padding: 0; overflow: hidden;\">\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://debasishg.blogspot.com/2012/07/does-category-theory-make-you-better.html\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/103612506_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://debasishg.blogspot.com/2012/07/does-category-theory-make-you-better.html\" target=\"_blank\">Does category theory make you a better programmer ?</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://swizec.com/blog/markov-chain-poem-trainergenerator-in-29-sloc-of-haskell/swizec/5310\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/noimg_106_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://swizec.com/blog/markov-chain-poem-trainergenerator-in-29-sloc-of-haskell/swizec/5310\" target=\"_blank\">Show HN: Markov chain poem trainer+generator in 29 sloc of Haskell</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://www.zemanta.com/fruitblog/downloading-the-internet-with-a-single-machine/\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/noimg_84_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://www.zemanta.com/fruitblog/downloading-the-internet-with-a-single-machine/\" target=\"_blank\">Downloading the Internet with a single machine</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://dave.fayr.am/posts/2012-10-4-finding-fizzbuzz.html\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/noimg_57_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://dave.fayr.am/posts/2012-10-4-finding-fizzbuzz.html\" target=\"_blank\">FizzBuzz, A Deep Navel to Gaze Into</a></li>\n<li class=\"zemanta-article-ul-li-image zemanta-article-ul-li\" style=\"padding: 0; background: none; list-style: none; display: block; float: left; vertical-align: top; text-align: left; width: 84px; font-size: 11px; margin: 2px 10px 10px 2px;\"><a style=\"box-shadow: 0px 0px 4px #999; padding: 2px; display: block; border-radius: 2px; text-decoration: none;\" href=\"http://hughewilliams.com/2012/10/01/five-myths-about-hash-tables/\" target=\"_blank\"><img style=\"padding: 0; margin: 0; border: 0; display: block; width: 80px; max-width: 100%;\" src=\"http://i.zemanta.com/115768156_80_80.jpg\" alt=\"\" /></a><a style=\"display: block; overflow: hidden; text-decoration: none; line-height: 12pt; height: 80px; padding: 5px 2px 0 2px;\" href=\"http://hughewilliams.com/2012/10/01/five-myths-about-hash-tables/\" target=\"_blank\">Five Myths about Hash Tables</a></li>\n</ul>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" src=\"http://img.zemanta.com/zemified_e.png?x-id=3131b59c-b284-43ea-b672-99bdad7199c4\" alt=\"Enhanced by Zemanta\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"3457fa72-b40c-592c-a4c3-650458e4b32c"}}