{"data":{"wordpressPost":{"title":"Firefox is slow, Lodash is fast","content":"<figure><img src=\"http://i.imgur.com/fXP7fLs.png\" alt=\"\" /></figure>\n<p>Look at those colors! Aren‚Äôt they shiny?</p>\n<p>They‚Äôre super shiny (unless you‚Äôre color blind), but what do they mean? I‚Äôm glad you asked. That‚Äôs a speed comparison chart of 6 ways to clone JavaScript objects, run in 5 browsers, on 2 devices: my laptop and my iPhone 5SE.</p>\n<p>You can try the benchmark yourself:</p>\n<p>&gt;<a href=\"http://swizec.github.io/compare-copy-methods\">Click here.</a> &lt; I‚Äôd make an iframe, but it freezes my browser for many seconds at a time. It even freezes the CSS animation on that React logo.</p>\n<figure><img src=\"http://i.imgur.com/BZP9d05.gif\" alt=\"\" /></figure>\n<p>Dangerous business those benchmarks.</p>\n<p>Firefox is the only browser that decides something weird is going on and throws a warning. Everyone else happily blocks JS, CSS, and UI.</p>\n<figure><img src=\"http://i.imgur.com/1TpGCEO.png\" alt=\"\" /></figure>\n<p>Now, is this benchmark fair? I don‚Äôt know. Running benchmarks on a computer that‚Äôs doing a bunch of other stuff is never <em>really</em> fair. Maybe a different tab just tried to do something, or Spotify downloaded a song, or Dropbox ran a metadata update on my entire hard drive.</p>\n<p>A bunch of things can affect these results. That‚Äôs why you can <a href=\"http://swizec.github.io/compare-copy-methods\">run it yourself</a>. But I did my best to ensure fairness as much as I could.</p>\n<ul>\n<li>Each test runs alone, asynchronously</li>\n<li>Each test is re-run 20-times</li>\n<li>Each test uses the same source data</li>\n<li>Each test produces the same deep-ish cloned dataset</li>\n</ul>\n<p>I say ‚Äúdeep-ish‚Äù because we‚Äôre cloning an array of some 81,000 objects. The objects are shallow, which means we can cut corners.</p>\n<pre lang=\"javascript\">\r\nconst experiments = {\r\n            'lodash _.cloneDeep': _.cloneDeep,\r\n            '.map + lodash _.clone': (arr) => arr.map((d) => _.clone(d)),\r\n            '.map + lodash _.assign': (arr) => arr.map((d) => _.assign({}, d)),\r\n            'JSON string/parse': (arr) => JSON.parse(JSON.stringify(arr)),\r\n            '.map + Object.assign': (arr) => arr.map((d) => Object.assign({}, d)),\r\n            '.map + React\\'s update()': (arr) => arr.map((d) => update({}, {$merge: d}))\r\n        };\r\n</pre>\n<p>We use <code>_.cloneDeep</code> without understanding context. This is a little bit unfair because it tries to do too much. We run <code>_.clone</code>, <code>_.assign</code>, <code>Object.assign</code>, and <a href=\"https://facebook.github.io/react/docs/update.html\">React‚Äôs <code>update</code></a> in a loop. They benefit from not trying to work in the general case. <code>JSON.parse/stringify</code> is on the same level as <code>_.cloneDeep</code>: na√Øve, complete, works for anything.</p>\n<p>I‚Äôm gobsmacked that for datasets this big, you‚Äôre better off converting to JSON and back than using Lodash‚Äôs <code>cloneDeep</code> function. I have no idea how that‚Äôs even possible. Maybe JSON benefits from an implementation detail deep in the engine?</p>\n<p>But then why is <code>_.assign</code> faster than <code>Object.assign</code>? They both make a shallow copy of an object, but <code>Object.assign</code> is a language feature, and <code>_.assign</code> is implemented in pure JavaScript.</p>\n<p>I think ‚Ä¶ how else? I hope <a href=\"https://twitter.com/jdalton\">@jdalton</a> can shed some light on this.</p>\n<p>You can see the entire test runner on Github <a href=\"https://github.com/Swizec/compare-copy-methods/blob/master/src/App.js\">here</a>. There are a few comments, but the interesting bit is this <code>runner</code> function. It ensure fairness by isolating timing to only the cloning method.</p>\n<pre lang=\"javascript\">\r\n\r\n    runner(name, method) {\r\n        let data = this.state.data;\r\n\r\n        const times = d3.range(0, this.N).map(() => {\r\n            const t1 = new Date();\r\n\r\n            let copy = method(data);\r\n\r\n            const t2 = new Date();\r\n            return t2 - t1;\r\n        });\r\n\r\n        let results = this.state.results;\r\n        results.push({name: name,\r\n                      avg: d3.mean(times)});\r\n\r\n        this.setState({results: results});\r\n    }\r\n</pre>\n<p>The runner itself is called asynchronously via <code>setTimeout(foo, 0)</code>, and the <code>async</code> library ensures tests don‚Äôt happen in parallel. Inside <code>runner</code>, we iterate through <code>N = 20</code> indexes, take timestamp, perform clone, take another timestamp, and construct an array of time diffs. Then we use <code>d3.mean</code> to get the average and add it to <code>this.state.results</code> with <code>setState</code>.</p>\n<p>It runs in React because I‚Äôm lazy and <code>create-react-app</code> is the quickest way to set everything up üôÇ</p>\n<p>Maybe there‚Äôs some unfairness in how Babel compiles this code? That‚Äôs possible ?</p>\n<p>My conclusion is this: Use the appropriate algorithm for your use-case, and run your code in Chrome.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"6f158435-805c-59a4-b6db-54d2fb8b0a12"}}