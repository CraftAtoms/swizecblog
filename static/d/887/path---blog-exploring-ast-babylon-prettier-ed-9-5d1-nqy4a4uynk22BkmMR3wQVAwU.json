{"data":{"wordpressPost":{"title":"Exploring the AST with Babylon and Prettier","content":"<p><iframe width=\"853\" height=\"480\" src=\"https://www.youtube.com/embed/zTE2QjKBJ-E\" frameborder=\"0\" allowfullscreen></iframe></p>\n<p>At <a href=\"https://swizec.com/blog/livecoding-39-towards-ai-writes-javascript/swizec/7621\">this week&#8217;s livecoding session</a>, I mentioned mutating ASTs to improve the performance of our <a href=\"https://github.com/Swizec/faux-js-ai\">faux AI that writes JavaScript</a> algorithm. It would help us converge on a solution faster.</p>\n<p>But what is an AST?</p>\n<p>Well, it&#8217;s an abstract syntax tree. It&#8217;s that thing computers use to understand your code. Let me explain how they work. I think every programmer can benefit from knowing this stuff.</p>\n<p>It took my compilers professor in college a few hours. Let&#8217;s see if I can show you the gist of it in a few hundred words. With a picture or two.</p>\n<p>We&#8217;re going to use <a href=\"https://github.com/babel/babylon\">Babylon</a> to parse code into an AST and <a href=\"https://github.com/prettier/prettier\">Prettier</a> to print it back out into code. Coincidentally, that&#8217;s how Prettier approaches making your code pretty. You&#8217;ll see that too.</p>\n<p>We begin with a test harness runnable in node.js.</p>\n<pre lang=\"javascript\">\nconst util = require('util')\nconst babylon = require('babylon');\n\nconst code = `\n`;\n\nlet AST = babylon.parse(code);\n\nconsole.log(util.inspect(\n    AST,\n    false, null\n));\n</pre>\n<p>We&#8217;re going to put the code we&#8217;re testing into <code>code</code>. The rest is there to parse it and print the resulting AST. <code>babylon.parse</code> is where the magic happens.</p>\n<p>Parsing an empty piece of code creates an AST like this:</p>\n<pre lang=\"javascript\">\nNode {\n  type: 'File',\n  start: 0,\n  end: 1,\n  loc: \n   SourceLocation {\n     start: Position { line: 1, column: 0 },\n     end: Position { line: 2, column: 0 } },\n  program: \n   Node {\n     type: 'Program',\n     start: 0,\n     end: 1,\n     loc: \n      SourceLocation {\n        start: Position { line: 1, column: 0 },\n        end: Position { line: 2, column: 0 } },\n     sourceType: 'script',\n     body: [],\n     directives: [] },\n  comments: [],\n  tokens: \n   [ Token {\n       type: \n        TokenType {\n          label: 'eof',\n          keyword: undefined,\n          beforeExpr: false,\n          startsExpr: false,\n          rightAssociative: false,\n          isLoop: false,\n          isAssign: false,\n          prefix: false,\n          postfix: false,\n          binop: null,\n          updateContext: null },\n       value: undefined,\n       start: 1,\n       end: 1,\n       loc: \n        SourceLocation {\n          start: Position { line: 2, column: 0 },\n          end: Position { line: 2, column: 0 } } } ] }\n</pre>\n<p>That doesn&#8217;t tell you much, does it? It doesn&#8217;t tell me anything.  Most of it is for Babylon to know what&#8217;s going on.</p>\n<p>Here&#8217;s the part we care about:</p>\n<pre lang=\"javascript\">\n  program: \n   Node {\n     type: 'Program',\n     start: 0,\n     end: 1,\n     loc: \n      SourceLocation {\n        start: Position { line: 1, column: 0 },\n        end: Position { line: 2, column: 0 } },\n     sourceType: 'script',\n     body: [],\n     directives: [] },\n</pre>\n<p>You can read this as <em>&#8220;There is a program that starts at 0:1 and ends at 0:2 and has an empty body. It is a script.&#8221;</em>. That means our code isn&#8217;t as empty as we thought; it&#8217;s got a whole empty line!</p>\n<p>In a picture, that AST looks something like this:</p>\n<img class=\"alignnone size-full wp-image-7632\" src=\"https://swizec.com/blog/wp-content/uploads/2017/06/fileprogram1.png\" width=\"800\" height=\"449\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/06/fileprogram1.png 800w, https://swizec.com/blog/wp-content/uploads/2017/06/fileprogram1-300x168.png 300w, https://swizec.com/blog/wp-content/uploads/2017/06/fileprogram1-768x431.png 768w\" sizes=\"(max-width: 800px) 100vw, 800px\" />\n<p>Root <code>file</code> node, child <code>program</code> node.</p>\n<p>Now let&#8217;s try a variable assignment.</p>\n<pre lang=\"javascript\">\nconst code = `\nlet a = 5;\n`;\n</pre>\n<p>That outputs a bigger AST. I&#8217;m going to snip out some of the details to make this readable.</p>\n<pre lang=\"javascript\">\nprogram: \n   Node {\n     type: 'Program',\n     start: 0,\n     end: 12,\n     loc: \n      SourceLocation {},\n     sourceType: 'script',\n     body: \n      [ Node {\n          type: 'VariableDeclaration',\n          start: 1,\n          end: 11,\n          loc: \n           SourceLocation {},\n          declarations: \n           [ Node {\n               type: 'VariableDeclarator',\n               start: 5,\n               end: 10,\n               loc: \n                SourceLocation {},\n               id: \n                Node {\n                  type: 'Identifier',\n                  start: 5,\n                  end: 6,\n                  loc: \n                   SourceLocation {},\n                  name: 'a' },\n               init: \n                Node {\n                  type: 'NumericLiteral',\n                  start: 9,\n                  end: 10,\n                  loc: \n                   SourceLocation {},\n                  extra: { rawValue: 5, raw: '5' },\n                  value: 5 } } ],\n          kind: 'let' } ],\n     directives: [] },\n</pre>\n<p>Our body now has a <code>variableDeclaration</code> node, which contains a <code>variableDeclarator</code> with an <code>Identifier</code> and a <code>NumericLiteral</code>. From this AST, you can infer that a <code>variableDeclarator</code> can contain multiple declarators, and that each declarator has an <code>id</code> and an <code>init</code>. The <code>id</code> node identifies the resulting variable and <code>init</code> sets its value.</p>\n<p>In a picture, that looks something like this:</p>\n<img class=\"alignnone size-full wp-image-7631\" src=\"https://swizec.com/blog/wp-content/uploads/2017/06/image2.png\" width=\"800\" height=\"449\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/06/image2.png 800w, https://swizec.com/blog/wp-content/uploads/2017/06/image2-300x168.png 300w, https://swizec.com/blog/wp-content/uploads/2017/06/image2-768x431.png 768w\" sizes=\"(max-width: 800px) 100vw, 800px\" />\n<p>You&#8217;ll notice the AST doesn&#8217;t talk much about what our code says. There&#8217;s no lets and equal signs or any of that. Sure, the identifier has a <code>name</code> and the init has a <code>value</code>, but the rest is an abstraction level higher.</p>\n<p>An AST talks about what the code does, not what it is.</p>\n<p>There&#8217;s a list of tokens if you want to know what the code says:</p>\n<pre lang=\"javascript\">\ntokens: \n   [ Token {\n       type: \n        KeywordTokenType {\n          label: 'let',\n          keyword: 'let',\n          beforeExpr: false,\n          startsExpr: false,\n          rightAssociative: false,\n          isLoop: false,\n          isAssign: false,\n          prefix: false,\n          postfix: false,\n          binop: null,\n          updateContext: null },\n       value: 'let',\n       start: 1,\n       end: 4,\n       loc: \n        SourceLocation {},\n     Token {\n       type: \n        TokenType {\n          label: 'name',\n          keyword: undefined,\n          beforeExpr: false,\n          startsExpr: true,\n          rightAssociative: false,\n          isLoop: false,\n          isAssign: false,\n          prefix: false,\n          postfix: false,\n          binop: null,\n          updateContext: [Function] },\n       value: 'a',\n       start: 5,\n       end: 6,\n       loc: \n        SourceLocation {},\n     Token {\n       type: \n        TokenType {\n          label: '=',\n          keyword: undefined,\n          beforeExpr: true,\n          startsExpr: false,\n          rightAssociative: false,\n          isLoop: false,\n          isAssign: true,\n          prefix: false,\n          postfix: false,\n          binop: null,\n          updateContext: null },\n       value: '=',\n       start: 7,\n       end: 8,\n       loc: \n        SourceLocation { },\n     Token {\n       type: \n        TokenType {\n          label: 'num',\n          keyword: undefined,\n          beforeExpr: false,\n          startsExpr: true,\n          rightAssociative: false,\n          isLoop: false,\n          isAssign: false,\n          prefix: false,\n          postfix: false,\n          binop: null,\n          updateContext: null },\n       value: 5,\n       start: 9,\n       end: 10,\n       loc: \n        SourceLocation {},\n     Token {\n       type: \n        TokenType {\n          label: ';',\n          keyword: undefined,\n          beforeExpr: true,\n          startsExpr: false,\n          rightAssociative: false,\n          isLoop: false,\n          isAssign: false,\n          prefix: false,\n          postfix: false,\n          binop: null,\n          updateContext: null },\n       value: undefined,\n       start: 10,\n       end: 11,\n       loc: \n        SourceLocation {},\n     Token {\n       type: \n        TokenType {\n          label: 'eof',\n          keyword: undefined,\n          beforeExpr: false,\n          startsExpr: false,\n          rightAssociative: false,\n          isLoop: false,\n          isAssign: false,\n          prefix: false,\n          postfix: false,\n          binop: null,\n          updateContext: null },\n       value: undefined,\n       start: 12,\n       end: 12,\n       loc: \n        SourceLocation { } ]\n</pre>\n<p>The list of tokens is a lot more interesting to Babylon than it is to you or I. It explains how to translate your code into a syntax tree.</p>\n<p>For example, let&#8217;s say our parser encounters the <code>a</code> token. Just like you, it recognizes that this is not a JavaScript reserved word. That must mean it&#8217;s a name for something and it starts a new expression.</p>\n<pre lang=\"javascript\">\nToken {\n   type: \n    TokenType {\n      label: 'name',\n      keyword: undefined,\n      beforeExpr: false,\n      startsExpr: true,\n      rightAssociative: false,\n      isLoop: false,\n      isAssign: false,\n      prefix: false,\n      postfix: false,\n      binop: null,\n      updateContext: [Function] },\n   value: 'a',\n   start: 5,\n   end: 6\n}\n</pre>\n<p>The parser keeps going. It doesn&#8217;t know yet what this new expression is going to be, but its name is <code>a</code>.</p>\n<p>So it finds the <code>=</code> sign.</p>\n<pre lang=\"javascript\">\ntype: \nTokenType {\n  label: '=',\n  keyword: undefined,\n  beforeExpr: true,\n  startsExpr: false,\n  rightAssociative: false,\n  isLoop: false,\n  isAssign: true,\n  prefix: false,\n  postfix: false,\n  binop: null,\n  updateContext: null },\nvalue: '=',\n</pre>\n<p>Ah, so we&#8217;re doing assignment, <code>isAssign</code>, and we&#8217;re expecting an expression afterwards. At least that&#8217;s what I think <code>beforeExpr</code> means. It&#8217;s hard to know for sure because <code>;</code> also gets the <code>beforeExpr</code> flag 🤔</p>\n<p>Either way, Babylon then encounters a <code>num</code> token, which also starts a new expression. In this case, an expression that&#8217;s the length of a single token, but still a new expression.</p>\n<p>As the parser goes through these tokens, it builds a syntax tree. Some tokens build new branches; others add more children to existing nodes.</p>\n<p>Making this work is tricky. I remember building a compiler at school, and it nearly broke my brain. The hard part is that you&#8217;re reading a flat stream of tokens and converting it into a rich tree.</p>\n<p>And yet, you do it every day when reading other people&#8217;s code! Quite impressive.</p>\n<p>Now, once you have an AST, you can use something like Prettier to print it back out into readable code.</p>\n<pre lang=\"javascript\">\nconst code = `\nlet\n\na\n         =\n\n 5;\n`;\n\nconsole.log(prettier.format(code));\n\n// let a = 5;\n</pre>\n<p>I couldn&#8217;t find the internal Prettier function that takes an AST and outputs it, but that&#8217;s what <code>.format</code> does internally. Parses your code, prints it back out with less cruft.</p>\n<p>When I have some time, I&#8217;ll figure out how to manipulate those ASTs to create different code.</p>\n<p>Now excuse me while I install Prettier in my editor. 🤓</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"59a27e56-862a-57ee-8071-ee59aeaac1eb"}}