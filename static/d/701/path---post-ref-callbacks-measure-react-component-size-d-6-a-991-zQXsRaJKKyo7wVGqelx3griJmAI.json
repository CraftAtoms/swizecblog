{"data":{"wordpressPost":{"title":"Use ref callbacks to measure React component size","content":"<p>You can use ref callbacks to measure the rendered size of React components, did you know? It&#8217;s a neat little trick.</p>\n<p><iframe src=\"https://codesandbox.io/embed/71vx2q5r76\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe></p>\n<p>Here&#8217;s how it works ðŸ‘‡<br />\n1. React renders your component<br />\n2. Browser layout engine does its thing<br />\n3. ref callback fires<br />\n4. Use <code>getBoundingClientRect</code> to measure element size<br />\n5. Use this info for whatever you want</p>\n<p>We used this trick in this <a href=\"https://swizec.com/blog/build-animated-accordion-react-d3/swizec/8418\">Dynamic SVG accordion example</a> and in this <a href=\"https://swizec.com/blog/tiny-react-d3-flamegraph-tutorial/swizec/8440\">Tiny React &amp; D3 flamegraph tutorial</a>. That&#8217;s because layouting in SVG is hard, and you have to do everything yourself.</p>\n<p>Using ref callbacks to measure your elements is a little less useful in the modern HTML + CSS world. You can use flexbox and css-grid so you never need to know what you&#8217;re dealing with.</p>\n<p>And yet when push comes to shove, sometimes you just really need your code to know the size of an element.</p>\n<p>A minimal size reporting component looks like this ðŸ‘‡</p>\n<pre lang=\"javascript\">\nclass ReportSize extends React.Component {\n  refCallback = element => {\n    if (element) {\n      this.props.getSize(element.getBoundingClientRect());\n    }\n  };\n\n  render() {\n    return (\n      <div ref={this.refCallback} style={{ border: \"1px solid red\" }}>\n        {faker.lorem.paragraphs(Math.random() * 10)}\n      </div>\n    );\n  }\n}\n</pre>\n<p>The <code>render</code> method outputs a <code>&lt;div&gt;</code> with a ref callback and a red border. Inside, we use <code>faker</code> to generate up to 10 random paragraphs.</p>\n<p>After React places this element, it calls <code>refCallback</code> with a reference to the rendered DOM node. We can then use <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\"><code>getBoundingClientRect</code></a> to measure its size.</p>\n<pre lang=\"javascript\">\n{\n  \"x\": 8,\n  \"y\": 158.8125,\n  \"width\": 544,\n  \"height\": 340,\n  \"top\": 158.8125,\n  \"right\": 552,\n  \"bottom\": 498.8125,\n  \"left\": 8\n}\n</pre>\n<p>All sorts of useful info!</p>\n<h2>So why not just use <code>componentDidMount</code>?</h2>\n<p>Yes, that works too. But it&#8217;s less elegant because you have to save the <code>ref</code> first. The <code>refCallback</code> API calls your function with a nice reference already packaged in.</p>\n<p>However, you might still have to do that if your component size changes <em>after</em> initial render. Observe ðŸ‘‡</p>\n<p><iframe src=\"https://codesandbox.io/embed/v6m4o48zl\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe></p>\n<p>Clicking the <code>shuffle</code> button doesn&#8217;t report new sizing information up the hierarchy. That&#8217;s not good ðŸ¤”</p>\n<p>If your component changes size without re-mounting, you have to re-measure its size in <code>componentDidUpdate</code> as well. But that way lies troubleâ€¦ you can fall into the infinite recursion trap.</p>\n<p>You can solve the problem with a lock, like this ðŸ‘‡</p>\n<p><iframe src=\"https://codesandbox.io/embed/7jqmo1jn8j\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe></p>\n<p>Keep clicking <code>shuffle</code> and sizing info is always correct.</p>\n<p>The key is enabling size reporting when you logically know size is going to change, in <code>shuffle</code>, and disabling it as soon as you report the change in <code>componentDidUpdate</code>.</p>\n<pre lang=\"javascript\">\nshuffle = () => {\n    this.doReportSize = true;\n    this.setState({\n      text: faker.lorem.paragraphs(Math.random() * 10)\n    });\n  };\n\n  refCallback = element => {\n    if (element) {\n      this.elementRef = element;\n      this.props.getSize(element.getBoundingClientRect());\n    }\n  };\n\n  componentDidUpdate() {\n    if (this.doReportSize) {\n      this.props.getSize(this.elementRef.getBoundingClientRect());\n      this.doReportSize = false;\n    }\n  }\n</pre>\n<p>Oof, not pretty. Setting a <code>this.elementRef</code> in our callback, messing around with class properties for flags. Pretty sure we could&#8217;ve just used the new <code>React.createRef()</code> API in combination with <code>componentDidMount</code> and <code>componentDidUpdate</code>.</p>\n<p>Would still need the flag to prevent infinite loops, however.</p>\n<p>I wonder if using class properties to make render flags like that will continue to work when asynchronous rendering comes with React 17 ðŸ¤”</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"95c733f8-e874-5836-a27e-ccd61b7e6da6"}}