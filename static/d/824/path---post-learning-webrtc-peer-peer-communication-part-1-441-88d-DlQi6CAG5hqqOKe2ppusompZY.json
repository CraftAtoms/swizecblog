{"data":{"wordpressPost":{"title":"Learning WebRTC peer-to-peer communication, part 1","content":"<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/pjoem5laCYQ?feature=oembed\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe></p>\n<p>Remember <a href=\"https://github.com/Swizec/blockchain-redux\">blockchain-redux</a>? Yeah, I&#8217;m still working on it. Last time, we got it to <a href=\"https://swizec.com/blog/blockchain-redux-shares-blocks-between-clients-real-time/swizec/8320\">share blocks between clients in real-time</a>.</p>\n<p>But that still used Firebase as the communication channel. Our blockchain isn&#8217;t really distributed. ‚òπÔ∏è</p>\n<p>I have to fix that before my talk at <a href=\"https://www.wearedevelopers.com/congress/\">WeAreDevelopers Congress</a> in Vienna. Otherwise, what&#8217;s the point?</p>\n<p>WebRTC can do that for us. Get browsers to talk to each other without any servers at all.</p>\n<p>I built <a href=\"https://swizec.github.io/webrtc-sample/\">a demo app</a> that uses <code>RTCPeerConnection</code> to build a peer-to-peer connection with itself. You can see the <a href=\"https://github.com/Swizec/webrtc-sample/blob/master/src/WebRTCPeerConnection.js\">code on GitHub</a> or keep reading.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">Got same page WebRTC working o/</p>\n<p>Now how do I peer-to-peer ü§î <a href=\"https://t.co/kHTPrmpJp5\">pic.twitter.com/kHTPrmpJp5</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/993269639235842051?ref_src=twsrc%5Etfw\">May 6, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>Since iOS 11, WebRTC now works in all browsers people use. You can use it for real! üëçüèº</p>\n<p><a href=\"https://swizec.github.io/webrtc-sample/\">Try my demo here</a>. I&#8217;d embed an iframe, but browser security rules say no.</p>\n<p>WebRTC offers 3 APIs:</p>\n<ul>\n<li>get video and audio from devices <a href=\"https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-mediastream\">(<code>MediaStream</code>)</a></li>\n<li>establish peer-to-peer connections <a href=\"https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcpeerconnection\">(<code>RTCPeerConnection</code>)</a></li>\n<li>send arbitrary data <a href=\"https://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-rtcdatachannel\">(<code>RTCDataChannel</code>)</a></li>\n</ul>\n<p>In this article, we&#8217;ll use 2 of them. Media and peer connection.</p>\n<h2>RTCPeerConnection connects clients without servers</h2>\n<div id=\"attachment_8358\" style=\"width: 1639px\" class=\"wp-caption alignnone\"><img class=\"alignnone size-full wp-image-8358\" src=\"https://swizec.com/blog/wp-content/uploads/2018/05/RTCPeerConnection-process-sketch.png\" alt=\"RTCPeerConnection process sketch\" width=\"1629\" height=\"1989\" srcset=\"https://swizec.com/blog/wp-content/uploads/2018/05/RTCPeerConnection-process-sketch.png 1629w, https://swizec.com/blog/wp-content/uploads/2018/05/RTCPeerConnection-process-sketch-246x300.png 246w, https://swizec.com/blog/wp-content/uploads/2018/05/RTCPeerConnection-process-sketch-768x938.png 768w, https://swizec.com/blog/wp-content/uploads/2018/05/RTCPeerConnection-process-sketch-839x1024.png 839w\" sizes=\"(max-width: 1629px) 100vw, 1629px\" /><p class=\"wp-caption-text\">RTCPeerConnection process sketch</p></div>\n<p>You establish a connection between 2 clients on the same page like this üëá</p>\n<ol>\n<li>Instantiate two <code>RTCPeerConnection</code> objects</li>\n<li>Add each other as ICE candidates</li>\n<li><code>createOffer</code> on the 1st object</li>\n<li>set local/remote &#8220;description&#8221; on both</li>\n<li><code>createAnswer</code> on the 2nd object</li>\n<li>set remote/local &#8220;description&#8221; on both</li>\n<li>Enjoy your direct communication</li>\n</ol>\n<p>Here&#8217;s how that goes <a href=\"https://github.com/Swizec/webrtc-sample/blob/master/src/WebRTCPeerConnection.js\">in code</a>.</p>\n<p>We start with a React component that renders 2 videos and 3 buttons. It has a bunch of default state that we&#8217;ll use to drive everything.</p>\n<pre lang=\"javascript\">\nclass WebRTCPeerConnection extends React.Component {\n    state = {\n        startDisabled: false,\n        callDisabled: true,\n        hangUpDisabled: true,\n        servers: null,\n        pc1: null,\n        pc2: null,\n        localStream: null\n    };\n\n    localVideoRef = React.createRef();\n    remoteVideoRef = React.createRef();\n\n    start = () => {\n        // start media devices\n    };\n\n    call = () => {\n        // initiate a call\n    };\n\n    hangUp = () => {\n        // hang up connection\n    };\n\n    render() {\n        const { startDisabled, callDisabled, hangUpDisabled } = this.state;\n\n        return (\n            <div>\n                <video\n                    ref={this.localVideoRef}\n                    autoPlay\n                    muted\n                    style={{ width: \"240px\", height: \"180px\" }}\n                />\n                <video\n                    ref={this.remoteVideoRef}\n                    autoPlay\n                    style={{ width: \"240px\", height: \"180px\" }}\n                />\n\n                <div>\n                    <button onClick={this.start} disabled={startDisabled}>\n                        Start\n                    </button>\n                    <button onClick={this.call} disabled={callDisabled}>\n                        Call\n                    </button>\n                    <button onClick={this.hangUp} disabled={hangUpDisabled}>\n                        Hang Up\n                    </button>\n                </div>\n            </div>\n        );\n    }\n}\n</pre>\n<p>We have 3 booleans that enable/disable our buttons, <code>null</code> peer connections <code>pc1</code> and <code>pc2</code>, I don&#8217;t know what <code>servers</code> are for, and we render videos and buttons.</p>\n<h2>Step 1 ‚Üí start</h2>\n<p>When you click the <code>Start</code> button, we ask for audio/video permissions and start a <code>localStream</code>.</p>\n<pre lang=\"javascript\">\n    start = () => {\n        this.setState({\n            startDisabled: true\n        });\n        navigator.mediaDevices\n            .getUserMedia({\n                audio: true,\n                video: true\n            })\n            .then(this.gotStream)\n            .catch(e => alert(\"getUserMedia() error:\" + e.name));\n    };\n    \n    gotStream = stream => {\n        this.localVideoRef.current.srcObject = stream;\n        this.setState({\n            callDisabled: false,\n            localStream: stream\n        });\n    };\n</pre>\n<p>Disable the start button with <code>this.setState</code>, get your media with <code>navigator.getUserMedia</code>. If you give permission, we start streaming in the <code>localVideo</code> element and add it to state.</p>\n<h2>Step 2 ‚Üí Call</h2>\n<p>You can now press the <code>Call</code> button. That starts two peer connections, <code>pc1</code> and <code>pc2</code>, and goes through the dance to get them talking to each other.</p>\n<ol>\n<li><code>call</code> initiates the offer</li>\n<li><code>onCreateOfferSuccess</code> updates both pcs and initiates the answer</li>\n<li><code>onCreateAnswerSuccess</code> finishes the handshake</li>\n<li><code>gotRemoteStream</code> wakes up and sets the second video</li>\n</ol>\n<pre lang=\"javascript\">\n    call = () => {\n        this.setState({\n            callDisabled: true,\n            hangUpDisabled: false\n        });\n        let { localStream } = this.state;\n\n        let servers = null,\n            pc1 = new RTCPeerConnection(servers),\n            pc2 = new RTCPeerConnection(servers);\n\n        pc1.onicecandidate = e => this.onIceCandidate(pc1, e);\n        pc1.oniceconnectionstatechange = e => this.onIceStateChange(pc1, e);\n\n        pc2.onicecandidate = e => this.onIceCandidate(pc2, e);\n        pc2.oniceconnectionstatechange = e => this.onIceStateChange(pc2, e);\n        pc2.ontrack = this.gotRemoteStream;\n\n        localStream\n            .getTracks()\n            .forEach(track => pc1.addTrack(track, localStream));\n\n        pc1\n            .createOffer({\n                offerToReceiveAudio: 1,\n                offerToReceiveVideo: 1\n            })\n            .then(this.onCreateOfferSuccess, error =>\n                console.error(\n                    \"Failed to create session description\",\n                    error.toString()\n                )\n            );\n\n        this.setState({\n            servers,\n            pc1,\n            pc2,\n            localStream\n        });\n    };\n</pre>\n<p>This code is mostly boilerplate.</p>\n<p>We enable and disable the appropriate buttons, get <code>localStream</code> from state, and instantiate <code>servers</code>, <code>pc1</code>, and <code>pc2</code>.</p>\n<p>Both <code>pc*</code> objects get a bunch of event listeners. <code>onIceCandidate</code> will connect them to each other, <code>onIceStateChange</code> just prints debugging info, and <code>gotRemoteStream</code> will add it to the right <code>&lt;video&gt;</code> element.</p>\n<p>Then we take all tracks from <code>localStream</code> (audio and video) and add them to the first client. After that <code>pc1</code> creates an offer to receive its video and audio.</p>\n<p>When all that&#8217;s done, we update component state.</p>\n<h3>onCreateOfferSuccess</h3>\n<p>After <code>pc1</code> successfully creates an offer to be received, we update local and remote descriptions in our clients. I&#8217;m not sure what these &#8220;descriptions&#8221; are, but it&#8217;s where the important stuff happens.</p>\n<pre lang=\"javascript\">\n    onCreateOfferSuccess = desc => {\n        let { pc1, pc2 } = this.state;\n\n        pc1\n            .setLocalDescription(desc)\n            .then(\n                () =>\n                    console.log(\"pc1 setLocalDescription complete createOffer\"),\n                error =>\n                    console.error(\n                        \"pc1 Failed to set session description in createOffer\",\n                        error.toString()\n                    )\n            );\n\n        pc2.setRemoteDescription(desc).then(\n            () => {\n                console.log(\"pc2 setRemoteDescription complete createOffer\");\n                pc2\n                    .createAnswer()\n                    .then(this.onCreateAnswerSuccess, error =>\n                        console.error(\n                            \"pc2 Failed to set session description in createAnswer\",\n                            error.toString()\n                        )\n                    );\n            },\n            error =>\n                console.error(\n                    \"pc2 Failed to set session description in createOffer\",\n                    error.toString()\n                )\n        );\n    };\n</pre>\n<p><code>pc1</code> updates its local description, and <code>pc2</code> updates its remote description. <code>pc2</code> also creates an answer, which I think is akin to saying <em>&#8220;Okay, I accepted your offer, let&#8217;s do this&#8221;</em>.</p>\n<h3>onCreateAnswerSuccess</h3>\n<p>When <code>pc2</code> successfully creates an answer, we do another round of description setting. This time in reverse order.</p>\n<pre lang=\"javascript\">\n    onCreateAnswerSuccess = desc => {\n        let { pc1, pc2 } = this.state;\n\n        pc1\n            .setRemoteDescription(desc)\n            .then(\n                () =>\n                    console.log(\n                        \"pc1 setRemoteDescription complete createAnswer\"\n                    ),\n                error =>\n                    console.error(\n                        \"pc1 Failed to set session description in onCreateAnswer\",\n                        error.toString()\n                    )\n            );\n\n        pc2\n            .setLocalDescription(desc)\n            .then(\n                () =>\n                    console.log(\n                        \"pc2 setLocalDescription complete createAnswer\"\n                    ),\n                error =>\n                    console.error(\n                        \"pc2 Failed to set session description in onCreateAnswer\",\n                        error.toString()\n                    )\n            );\n    };\n</pre>\n<p><code>pc1</code> sets its remote description and <code>pc2</code> sets its local description. I think this acknowledges that, from <code>pc1</code>&#8216;s perspective, it is local to itself and <code>pc2</code> is remote, and vice-versa for <code>pc2</code>.</p>\n<p>¬Ø&#92;_(„ÉÑ)_/¬Ø</p>\n<p>At this point, we have two video streams talking to each other on the same page.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">Got same page WebRTC working o/</p>\n<p>Now how do I peer-to-peer ü§î <a href=\"https://t.co/kHTPrmpJp5\">pic.twitter.com/kHTPrmpJp5</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/993269639235842051?ref_src=twsrc%5Etfw\">May 6, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<h3>onIceCandidate</h3>\n<p>At some point during all this, both <code>pc*</code>s say that they&#8217;ve got an ICE candidate. Don&#8217;t know when exactly that happens, but it gives us a chance to tell each client who they&#8217;re talking to.</p>\n<pre lang=\"javascript\">\n    onIceCandidate = (pc, event) => {\n        let { pc1, pc2 } = this.state;\n\n        let otherPc = pc === pc1 ? pc2 : pc1;\n\n        otherPc\n            .addIceCandidate(event.candidate)\n            .then(\n                () => console.log(\"addIceCandidate success\"),\n                error =>\n                    console.error(\n                        \"failed to add ICE Candidate\",\n                        error.toString()\n                    )\n            );\n    };\n</pre>\n<p>We guess the other client and add it as a candidate. If we had more than 2, this could get tricky.</p>\n<h2>Step 3: HangUp</h2>\n<p>Hanging up is easy. You close both clients.</p>\n<pre lang=\"javascript\">\n    hangUp = () => {\n        let { pc1, pc2 } = this.state;\n\n        pc1.close();\n        pc2.close();\n\n        this.setState({\n            pc1: null,\n            pc2: null,\n            hangUpDisabled: true,\n            callDisabled: false\n        });\n    };\n</pre>\n<h2>The tricky part</h2>\n<p>This works great as a tech demo. And that&#8217;s when your dreams are shattered.</p>\n<p>The first part of your connection, where two clients find each other, is called signaling. The WebRTC spec doesn&#8217;t say anything about signaling.</p>\n<p>It&#8217;s easy in a single page, two client demo. Both clients are right there, in memory. And there&#8217;s only two clients to boot.</p>\n<p>But in the real world, you want those clients to run in different browsers, on different machines, far apart in the world. How do you make them find each other? What if there&#8217;s thousands?</p>\n<p>Well, you need some sort of communication channel that knows where all the clients are and can say <em>&#8220;Yo, connect here. You, over there!&#8221;</em>. A central server of some sort‚Ä¶</p>\n<p>That won&#8217;t do for a distributed decentralized blockchain ‚òπÔ∏è</p>\n<p>Next step: Serverless WebRTC signaling. Stay tuned.</p>\n<p>&lt;strong<em>This is a Livecoding Recap ‚Äì an almost-weekly post about interesting things discovered while livecoding. Usually shorter than 500 words. Often with pictures. Livecoding happens almost <strong>every Sunday at 2pm PDT</strong> on multiple channels. You should subscribe to <a href=\"https://www.youtube.com/TheSwizec\">My Youtube</a> channel to catch me live.</em></strong></p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"f2bea0b1-f98d-5090-b96d-c4a58125429d"}}