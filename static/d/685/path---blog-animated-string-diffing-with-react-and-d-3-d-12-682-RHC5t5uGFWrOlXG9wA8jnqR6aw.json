{"data":{"wordpressPost":{"title":"Animated string diffing with React and D3","content":"<figure><img src=\"http://i.imgur.com/sAr4q3L.gif\" alt=\"\" /></figure>\n<p>I turned <a href=\"http://swizec.com/blog/using-d3js-transitions-in-react/swizec/6797\">my animated alphabet example</a> into an animation of what youâ€™re typing. New characters drop in from above, old characters drop down, and any white space gets squeezed out.</p>\n<p>Pretty cool, huh? Try it out:</p>\n<p><iframe src=\"https://swizec.github.io/react-d3-enter-exit-transitions/\" width=\"600\" height=\"600\"></iframe></p>\n<p>Maybe Iâ€™m a weirdo nerd, but I could play with that for days. Well, okay, minutes. At least 30 seconds!</p>\n<p>What I like about this demo is that itâ€™s a great example of declarative transitions built with React. Each letter handles its own animation, so all that the main component has to do is go through a list of characters in a loop and render a <code>Letter</code> component for each, like this:</p>\n<pre lang=\"javascript\">\r\n    render() {\r\n        let { x, y } = this.props,\r\n            transition = d3.transition()\r\n                           .duration(750)\r\n                           .ease(d3.easeCubicInOut);\r\n\r\n        return (\r\n            <g transform={`translate(${x}, ${y})`}>\r\n                <ReactTransitionGroup component=\"g\">\r\n                    {this.state.text.map((l, i) =>\r\n                        <Letter letter={l} i={i} key={i} transition={transition} />\r\n                     )}\r\n                </ReactTransitionGroup>\r\n            </g>\r\n        );\r\n    }\r\n</pre>\n<p>Declaring a root <code>transition</code> ensures individual letter transitions are synced. Rendering them in a <code>ReactTransitionGroup</code> gives us some additional lifecycle methods, and each letter needs its index so that it can calculate horizontal positioning because it lacks situational awareness.</p>\n<p>Then, each <code>Letter</code> component takes care of its own enter/update/exit transitions inside special lifecycle hooks. <code>componentWillEnter</code> for the enter animation, <code>componentWillReceiveProps</code> for update, and <code>componentWillLeave</code> for exit. <a href=\"https://github.com/Swizec/react-d3-enter-exit-transitions/blob/master/src/components/Letter.jsx\">The whole component</a> is just 59 standard lines of code.</p>\n<p>You can read my previous 2000-word article to learn the details about <a href=\"http://swizec.com/blog/using-d3js-transitions-in-react/swizec/6797\">using D3 transitions with React components</a>. Iâ€™ve cleaned up the code since then, but the gist hasnâ€™t changed. You can see the current code in my <a href=\"https://github.com/Swizec/react-d3-enter-exit-transitions\">github repository</a>.</p>\n<p>The <em>key</em> mystery was choosing the right key prop for each <code>Letter</code> component. That part was hard. It took me two whole nights!</p>\n<h2>Choosing the key prop</h2>\n<p>The key prop is how React identifies your components. For the most part, you donâ€™t have to worry about choosing correctly. Make it unique and youâ€™re done. React can tell your components apart, which lets it do the fancy diffing stuff, and everything Just Worksâ„¢.</p>\n<p>Sometimes, though, the type of uniqueness matters.</p>\n<p>For example: if you use the letter itself for the key prop, this example breaks down. It wonâ€™t even display input value correctly.</p>\n<figure><img src=\"http://i.imgur.com/zkgtGiR.gif\" alt=\"\" /></figure>\n<p>You only get one chance to show each character. Repeat it and React wonâ€™t care &#8211; itâ€™s the same component as far as React is concerned. Empty spaces show up because we use character index from the original string to calculate horizontal positioning.</p>\n<p>?</p>\n<p>Okay then, what if we use the index? Each letter has its own, so thatâ€™s good, and itâ€™s easy to set up, so thatâ€™s great.</p>\n<figure><img src=\"http://i.imgur.com/gWKujjz.gif\" alt=\"\" /></figure>\n<p>Waaaait a minute. Thatâ€™s no good! Appending new characters to the end looks great, deleting characters from the end works too, but as soon as you mess around in the middle, all hell breaks loose.</p>\n<p>React uses indexes to identify <code>Letter</code> instances, so only the last character animates. The fancy-pants diffing algorithm can do the diffing, but it doesnâ€™t understand the context.</p>\n<p>Ugh.</p>\n<p>We have to help React out and implement our own string diffing algorithm. If youâ€™ve ever gone to a computer science class or three, this should be a familiar problem. Itâ€™s a variation of the much researched <a href=\"https://en.wikipedia.org/wiki/Longest_common_subsequence_problem\">longest subsequence problem</a>.</p>\n<h2>A simple string diffing algorithm</h2>\n<p>The full longest common subsequence problem is a hairy beast with decades of research behind it. Efficient solutions are used in everything from version control systems to bioinformatics.</p>\n<p>A few assumptions make it easier in our case:</p>\n<ul>\n<li>changes only happen at the caret</li>\n<li>there is only 1 caret</li>\n<li>there will only ever be 1 change</li>\n</ul>\n<p>A linear-complexity algorithm will do ðŸ™‚</p>\n<figure><img src=\"http://i.imgur.com/iknWGlq.jpg\" alt=\"\" /></figure>\n<p>Assuming thereâ€™s only one change at a time works even when you take copy/paste into account. Users canâ€™t copy/paste disparate chunks of text at the same time. It has to be connected. So even if the change uses the same text, it acts as a big remove followed by an insert.</p>\n<p>Our game plan is thus:</p>\n<ul>\n<li>assign a unique ID to each new character</li>\n<li>maintain <code>(char, id)</code> pairs for the same portion</li>\n<li>create or drop <code>(char, id)</code> pairs for the changed portion</li>\n<li>shift <code>(char, id)</code> pairs to new indexes for the shifted portion</li>\n</ul>\n<p>The implementation took me 55 lines of code. You can see it in its entirety at the <a href=\"https://github.com/Swizec/react-d3-enter-exit-transitions/blob/master/src/components/FancyText.jsx\">github repository</a>. There are 7 steps.</p>\n<h3>Step 1 &#8211; prep the vars</h3>\n<pre lang=\"javascript\">\r\n// FancyText.jsx -> componentWillReceiveProps()\r\n  const oldText = this.state.textWithIds;\r\n        const newText = newProps.text.split('');\r\n        let indexOfChange = 0,\r\n            sizeOfChange = 0,\r\n            newLastId = this.state.lastId;\r\n</pre>\n<p><code>oldText</code> is the current array of <code>(char, id)</code> pairs, <code>newText</code> becomes an array of characters in the new string. We initiate <code>indexOfChange</code> and <code>sizeOfChange</code> to <code>0</code>. <code>this.state.lastId</code> is where we keep a running tally of new characters. Think of it as an auto increment ID.</p>\n<h3>Step 2 &#8211; find the change</h3>\n<pre lang=\"javascript\">\r\n// FancyText.jsx -> componentWillReceiveProps()\r\n// find change\r\nfor (; newText[indexOfChange] == (oldText[indexOfChange] && oldText[indexOfChange][0]); indexOfChange++);\r\n</pre>\n<p>Looks like old school C code, doesnâ€™t it? We keep incrementing <code>indexOfChange</code> until we find a character mismatch between the new and old text. Then we know where the insertion or deletion begins.</p>\n<h3>Step 3 &#8211; calculating size of change</h3>\n<pre lang=\"javascript\">\r\n// FancyText.jsx -> componentWillReceiveProps()\r\n\r\n        // calculate size of change\r\n        if (newText.length > oldText.length) {\r\n            while (newText[indexOfChange+sizeOfChange] != (oldText[indexOfChange] && oldText[indexOfChange][0])\r\n                    && indexOfChange+sizeOfChange < newText.length) {\r\n                        sizeOfChange = sizeOfChange+1;\r\n            }\r\n        }else{\r\n            while (newText[indexOfChange] != (oldText[indexOfChange+sizeOfChange] &#038;&#038; oldText[indexOfChange+sizeOfChange][0])\r\n                    &#038;&#038; indexOfChange+sizeOfChange < oldText.length) {\r\n                        sizeOfChange = sizeOfChange+1;\r\n            }\r\n        }\r\n</pre>\n<p>Here we have two different branches - one for insertion and one for deletion. They both use the same principle and have small differences based on which characters to compare.</p>\n<p>We keep increasing <code>sizeOfChange</code> until <code>indexOfChange+sizeOfChange</code> either finds a character that matches in both strings, or until it runs out of characters to check. The difference between insertion and deletion is that weâ€™re shifting the lookup index of either <code>newText</code> or <code>oldText</code>.</p>\n<h3>Step 4 - copying same section</h3>\n<pre lang=\"javascript\">\r\n// FancyText.jsx -> componentWillReceiveProps()\r\n\r\n// use existing ids up to point of change\r\nd3.range(0, indexOfChange).forEach((i) => newText[i] = oldText[i]);\r\n</pre>\n<p><code>d3.range</code> creates an array of indexes from <code>0</code> to <code>indexOfChange</code>. We loop through it and overwrite <code>newText</code> with existing <code>(char, id)</code> pairs from <code>oldText</code>.</p>\n<h3>Step 5 - add new (char, id) pairs</h3>\n<pre lang=\"javascript\">\r\n// FancyText.jsx -> componentWillReceiveProps()\r\n\r\n      // use new ids for additions\r\n        if (newText.length > oldText.length) {\r\n            d3.range(indexOfChange, indexOfChange+sizeOfChange).forEach((i) => {\r\n                let letter = newText[i];\r\n                newText[i] = [letter, newLastId++];\r\n            });\r\n</pre>\n<p>If the change is an insertion, we go from <code>indexOfChange</code> to <code>indexOfChange+sizeOfChange</code>, create new <code>(char, id)</code> pairs, and override <code>newText</code> at each index. To create each ID, we take <code>newLastId</code> and increment it.</p>\n<p>Just like an auto increment index. Itâ€™s a running count of new characters that never decrements.</p>\n<h3>Step 6 - shift remaining (char, id) pairs</h3>\n<pre lang=\"javascript\">\r\n// FancyText.jsx -> componentWillReceiveProps()\r\n\r\n        if (newText.length > oldText.length) {\r\n            // insertion â€¦\r\n\r\n            // use existing ids from change to end\r\n            d3.range(indexOfChange+sizeOfChange, newText.length).forEach((i) =>\r\n                newText[i] = oldText[i-sizeOfChange]);\r\n        }else{\r\n            // use existing ids from change to end, but skip what's gone\r\n            d3.range(indexOfChange, newText.length).forEach((i) =>\r\n                newText[i] = oldText[i+sizeOfChange]);\r\n        }\r\n</pre>\n<p>Here we again have two branches: one for insertion, one for deletion. Both copy <code>(char, id)</code> pairs from <code>oldText</code> to <code>newText</code>, but the shift happens in different directions.</p>\n<p>When inserting, we have to shift the index by <code>sizeOfChange</code> to the right. When deleting, we shift the index to the left.</p>\n<pre lang=\"javascript\">\r\n// FancyText.jsx -> componentWillReceiveProps()\r\n\r\n        this.setState({text: newProps.text,\r\n                       textWithIds: newText,\r\n                       lastId: newLastId});\r\n</pre>\n<p>We have an updated list of <code>(char, id)</code> pairs in <code>newText</code>. It reflects the updated text value while keeping all ID assignments stable throughout the process. Pretty neat.</p>\n<p>We use <code>this.setState</code> so that when React calls <code>render()</code> on our <code>FancyText</code> component, it will use the updated state. <code>componentWillReceiveProps</code> is the only lifecycle method where calling <code>setState</code> does not trigger a re-render.</p>\n<p>Neat, huh?</p>\n<h3>Step 7.5 - use the (char, id) pairs</h3>\n<p>Thereâ€™s one more thing. We have to update how rendering happens. Invoking the <code>Letter</code> component looks like this now:</p>\n<pre lang=\"javascript\">\r\n// FancyText.jsx -> render()\r\n\r\n return (\r\n            <g transform={`translate(${x}, ${y})`}>\r\n                <ReactTransitionGroup component=\"g\">\r\n                    {this.state.textWithIds.map(([l, id], i) =>\r\n                        <Letter letter={l} i={i} key={id} transition={transition} />\r\n                     )}\r\n                </ReactTransitionGroup>\r\n            </g>\r\n        );\r\n</pre>\n<p>Instead of iterating over <code>this.props.text</code>, we iterate over <code>this.state.textWithIds</code>. For each iteration, we take the <code>(char, id)</code> pair, destructure it, and use the <code>id</code> for our key prop.</p>\n<p>And thatâ€™s it, our animated typing example looks like this:</p>\n<figure><img src=\"http://i.imgur.com/11aZVdH.gif\" alt=\"\" /></figure>\n<p>Wasnâ€™t that fun?</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"956fb2d3-5b47-5762-ae45-b4f52c4af2b4"}}