{"data":{"wordpressPost":{"title":"Livecoding #32: A Map of Global Migrations, Part 1","content":"<p><em>This is a Livecoding Recap – an almost-weekly post about interesting things discovered while livecoding ?. Always under 500 words and with pictures. You can follow my channel, <a href=\"https://liveedu.tv/swizec\">here</a>. New content almost <strong>every Sunday at 2pm PDT</strong>. There’s live chat, come say hai ?</em></p>\n<p><iframe src=\"https://www.liveedu.tv/swizec/videos/k4vJP/embed\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"true\" scrolling=\"no\"></iframe></p>\n<p>You know, it&#39;s really hard to compete with the Super Bowl. This Sunday must have been the lowest live coding turnout I&#39;ve ever seen.</p>\n<p>A cumulative of 80 people came to see me live, and that makes me happy, and I still don&#39;t know how <a href=\"https://www.liveedu.tv/swizec/\">liveedu.tv</a> calculates that. It doesn&#39;t matter. It&#39;s a number, it&#39;s not zero, and that&#39;s great.</p>\n<p>Thanks to <a href=\"https://www.liveedu.tv/mrmaru/\">mrmaru</a> for teaching me how to jump to the end of line (<code>$</code>) and beginning of line (<code>0</code>) in Vim. I sure feel dumb for holding the left and right arrow keys for the past 15 years like an idiot. Why didn&#39;t I look that up? ?</p>\n<p>Together, we talked about not understanding football and built this map:</p>\n<img class=\"alignnone size-full wp-image-7414\" src=\"https://swizec.com/blog/wp-content/uploads/2017/02/map-screenshot.png\" width=\"1024\" height=\"566\" srcset=\"https://swizec.com/blog/wp-content/uploads/2017/02/map-screenshot.png 1024w, https://swizec.com/blog/wp-content/uploads/2017/02/map-screenshot-300x166.png 300w, https://swizec.com/blog/wp-content/uploads/2017/02/map-screenshot-768x425.png 768w\" sizes=\"(max-width: 1024px) 100vw, 1024px\" />\n<p>We&#39;re going to make it better next week. I know it doesn&#39;t look like much yet.</p>\n<p>Our (my?) goal is to build a map of global migrations using the <a href=\"https://github.com/curran/data/blob/gh-pages/un/migration/README.md\">UN dataset</a> I mentioned <a href=\"https://swizec.com/blog/livecoding-31-datasets-hard/swizec/7403\">last week</a>. Initially, I wanted to build one of those cool maps that change country sizes to represent a value. No idea how to do that. Yet.</p>\n<p>Instead we&#39;re drawing lines. Because I couldn&#39;t figure out how to make curves ?</p>\n<p>In my defense, I was tired and dying from a cold.</p>\n<p>Right now, you&#39;re seeing global migrations <em>into</em> Djibouti. Lines connect <code>source</code> migrations to their <code>destination</code>. There&#39;s nothing about magnitude yet. That comes next week, and I&#39;d love some suggestions on how to do that. Line thickness smells interesting but would probably look weird.</p>\n<p>Oh, and the lines are going to be curved. I think what I&#39;m missing is a third point between the <code>source</code> and <code>destination</code>.  Something to give D3&#39;s curve <code>curveBasis</code> interpolator a reason to make a curve.</p>\n<p>Right now we&#39;re rendering the migrations layer as a React component, like this:</p>\n<pre lang=\"javascript\">\nconst Migrations = ({ topology, projection, data, nameIdMap }) => {\n    const countries = topojson.feature(topology, topology.objects.countries),\n          path = d3.geoPath(projection),\n          centroids = _.fromPairs(countries.features\n                                           .map(country => [country.id,\n                                                            path.centroid(country)]));\n\n\n    return (\n        <g>\n            <CountryMigrations data={data[10]} nameIdMap={nameIdMap}\n                               centroids={centroids} />\n        </g>\n    );\n};\n\nconst CountryMigrations = ({ data, nameIdMap, centroids }) => {\n    const line = d3.line()\n                   .curve(d3.curveBasis),\n          destination = centroids[data.id];\n\n    console.log(data.name);\n\n    const sources =  Object.keys(data.sources)\n                           .filter(name => centroids[nameIdMap[name]])\n                           .map(name => centroids[nameIdMap[name]]);\n    return (\n        <g>\n            {sources.map((source, i) => (\n                <path d={line([destination, source])}\n                      style={{stroke: 'black',\n                              strokeWidth: '1px'}}\n                      key={`${data.id}-${i}`} />\n             ))}\n        </g>\n    )\n};\n</pre>\n<p>The <code>Migrations</code> component builds a dictionary of country centroids, which gives us a cached mapping from country <code>id</code> to country centroid position. We use these as line anchors.</p>\n<p>Then we iterate through the list of countries and render <code>CountryMigration</code> components. Well, in theory. There&#39;s just one <code>CountryMigration</code> right now, so it&#39;s easier to debug.</p>\n<p>Each <code>CountryMigration</code> component creates a <code>d3.line</code> generator, compiles a list of <code>sources</code>, then iterates through them and adds <code>path</code> elements for each line. As you can see, this works, but it doesn&#39;t make curves because a curve between two points is a straight line.</p>\n<p>That sounds stupidly obvious when I say it out loud ?</p>\n<p>Join me next week as we curve the curves, add animation to represent migration volume, and maybe some interactivity. Mouseovers could filter countries? Perhaps.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"9a2c9279-78e0-5709-836b-923721316daa"}}