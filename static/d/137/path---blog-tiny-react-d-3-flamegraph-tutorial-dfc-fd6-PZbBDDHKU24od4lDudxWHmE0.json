{"data":{"wordpressPost":{"title":"Tiny React &#038; D3 flamegraph tutorial","content":"<p><em>This is a Livecoding Recap â€“ an almost-weekly post about interesting things discovered while livecoding. Usually shorter than 500 words. Often with pictures. Livecoding happens almost <strong>every Sunday at 2pm PDT</strong> on multiple channels. You should <a href=\"http://youtube.com/user/theswizec\">subscribe to ï¿¼My Youtubeï¿¼ channel</a>(https://www.youtube.com/user/theswizec) to catch me live.</em></p>\n<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/eOenovuDHxE?feature=oembed\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe></p>\n<p><a href=\"http://brendangregg.com/flamegraphs.html\">Flamegraphs</a> are great. They show you when you&#8217;ve been bad and made the CPU cry.</p>\n<p>Here is a flamegraph built with React &amp; D3. It shows some stack data I stole from <a href=\"https://github.com/spiermar/d3-flame-graph/blob/master/examples/stacks.json\">the internet</a>:</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">This is better. I&#39;m gonna have to spend some time thinking about how to make individual nodes inspectable with a nice animated transition.</p>\n<p>I assume that would be a useful feature <a href=\"https://twitter.com/brian_d_vaughn?ref_src=twsrc%5Etfw\">@brian_d_vaughn</a> ? <a href=\"https://t.co/7shyFCxyde\">pic.twitter.com/7shyFCxyde</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/1003402982552002560?ref_src=twsrc%5Etfw\">June 3, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>You can try it out <a href=\"https://dist-wnnnpntytb.now.sh/\">here</a>, and see the <a href=\"https://github.com/Swizec/react-d3-flamegraph\">code on GitHub</a>. Consider it a work in progress. Releasing as open source once the animation works smoothly ðŸ™‚</p>\n<p><iframe src=\"https://dist-wnnnpntytb.now.sh/\" style=\"width: 100%; height: 400px\"></iframe></p>\n<h2>Here&#8217;s how it works ðŸ‘‡</h2>\n<p>You have two components:</p>\n<ol>\n<li><code>&lt;Flamegraph&gt;</code>, which recursively renders the data tree</li>\n<li><code>&lt;FlameRect&gt;</code>, which renders a particular rectangle and its label</li>\n</ol>\n<h3>Flamegraph</h3>\n<p>The <code>&lt;Flamegraph&gt;</code> component without animation takes your data, loops it through the array of entries at this level, and calls itself on <code>data.children</code>.</p>\n<pre lang=\"javascript\">\nimport { scaleLinear, schemeOrRd, color as d3color } from \"d3\";\n\nclass Flamegraph extends React.Component {\n    render() {\n        const { x = 0, y = 0, width, level = 0, data } = this.props;\n\n        const xScale = scaleLinear()\n            .domain([0, data.reduce((sum, d) => sum + d.value, 0)])\n            .range([0, width]);\n\n        return (\n            <g transform={`translate(${x}, ${y})`}>\n                {data.map((d, i) => {\n                    const start = data\n                        .slice(0, i)\n                        .reduce((sum, d) => sum + d.value, 0);\n\n                    return (\n                        <React.Fragment key={`${level}-${d.name}`}>\n                            <FlameRect\n                                x={xScale(start)}\n                                y={0}\n                                width={xScale(d.value)}\n                                height={RowHeight}\n                                name={d.name}\n                            />\n                            {d.children && (\n                                <Flamegraph\n                                    data={d.children}\n                                    x={xScale(start)}\n                                    y={RowHeight}\n                                    width={xScale(d.value)}\n                                    level={level + 1}\n                                />\n                            )}\n                        </React.Fragment>\n                    );\n                })}\n            </g>\n        );\n    }\n}\n</pre>\n<p>Our <code>render</code> method takes a bunch of params out of <code>props</code>, creates a linear D3 scale to make calculations easier, then renders an SVG grouping element.</p>\n<p>Inside that element, we loop through the <code>data</code>, and for each entry, we create a new <code>&lt;React.Fragment&gt;</code>. The fragment contains <code>&lt;FlameRect&gt;</code> which represents the current datapoint, and a <code>&lt;Flamegraph&gt;</code> which renders all the child nodes.</p>\n<p>We decide each element&#8217;s <code>x</code> position based on the sum of all node values up to the current one. And we make sure the child <code>&lt;Flamegraph&gt;</code> uses the same width as the current node. This creates the neat stacking effect.</p>\n<img class=\"alignnone size-full wp-image-8439\" src=\"https://swizec.com/blog/wp-content/uploads/2018/06/flamegraph-screenshot.png\" width=\"2584\" height=\"836\" srcset=\"https://swizec.com/blog/wp-content/uploads/2018/06/flamegraph-screenshot.png 2584w, https://swizec.com/blog/wp-content/uploads/2018/06/flamegraph-screenshot-300x97.png 300w, https://swizec.com/blog/wp-content/uploads/2018/06/flamegraph-screenshot-768x248.png 768w, https://swizec.com/blog/wp-content/uploads/2018/06/flamegraph-screenshot-1024x331.png 1024w\" sizes=\"(max-width: 2584px) 100vw, 2584px\" />\n<h3><FlameRect></h3>\n<p>The <code>&lt;FlameRect&gt;</code> component takes care of choosing a random color on initial render, highlighting when clicked, and displaying a label if there&#8217;s enough space.</p>\n<p>It looks like this:</p>\n<pre lang=\"javascript\">\nimport { scaleLinear, schemeOrRd, color as d3color } from \"d3\";\n\nclass FlameRect extends React.Component {\n    state = {\n        hideLabel: false,\n        selected: false,\n        color: schemeOrRd[9][Math.floor(Math.random() * 9)]\n    };\n\n    labelRefCallback = element => {\n        if (\n            element &&\n            element.getBoundingClientRect().width > this.props.width\n        ) {\n            this.setState({\n                hideLabel: true\n            });\n        }\n    };\n\n    onClick = () => this.setState({ selected: !this.state.selected });\n\n    render() {\n        const { x, y, width, height, name } = this.props,\n            { hideLabel, selected } = this.state;\n        let { color } = this.state;\n\n        if (selected) {\n            color = d3color(color).brighter();\n        }\n\n        return (\n            <g\n                transform={`translate(${x}, ${y})`}\n                style={{ cursor: \"pointer\" }}\n                onClick={this.onClick}\n            >\n                <rect\n                    x={0}\n                    y={0}\n                    width={width}\n                    height={height}\n                    style={{\n                        stroke: \"white\",\n                        fill: color\n                    }}\n                />\n                {!hideLabel && (\n                    <text\n                        x={5}\n                        y={13}\n                        style={{ fontSize: \"12px\" }}\n                        ref={this.labelRefCallback}\n                    >\n                        {name}\n                    </text>\n                )}\n            </g>\n        );\n    }\n}\n</pre>\n<p>We render a grouping element that contains a <code>&lt;rect&gt;</code> and a <code>&lt;text&gt;</code>. The rect gets sizing and color information, and the label gets a ref callback and some text.</p>\n<p>We use the ref callback to dynamically detect the size of our label and hide it if necessary. That happens in <code>labelRefCallback</code>.</p>\n<p><code>onClick</code>, we flip the selected state.</p>\n<p>And well, that&#8217;s it. You can think of this component as a basic toggle component. Uses all the same logic, just renders as a colorful rectangle instead of a button.</p>\n<h2>Fin</h2>\n<p>That&#8217;s the basic <code>&lt;Flamegraph&gt;</code> component. Uses recursion to render a tree data structure and lets you highlight individual elements.</p>\n<p>Where it gets tricky is adding animation that lets users explore their data. Turns out deeply nested React elements are hard to animate smoothly.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">Smoothly animating recursive structures is hard. <a href=\"https://twitter.com/brian_d_vaughn?ref_src=twsrc%5Etfw\">@brian_d_vaughn</a> might not get the flamegraph shininess I half promised<a href=\"https://twitter.com/sxywu?ref_src=twsrc%5Etfw\">@sxywu</a> <a href=\"https://twitter.com/micahstubbs?ref_src=twsrc%5Etfw\">@micahstubbs</a> any tips? <a href=\"https://t.co/2ARgb3izCq\">pic.twitter.com/2ARgb3izCq</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/1003904212755857408?ref_src=twsrc%5Etfw\">June 5, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>The worst part is how long it takes before React even propagates <code>prop</code> updates through the tree before the animation even starts. Once the animation is running, it&#8217;s smooth as silk.</p>\n<p>But getting it started, ho boy.</p>\n<p>This warrants further research. I&#8217;ll be back ðŸ™‚</p>\n<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/MLchhOfiOwM?feature=oembed\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe></p>\n<p>PS: version <a href=\"https://www.npmjs.com/package/react-d3-flamegraph\">0.1.0 is in fact on npm</a> if you want to play.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"e2ad5914-099b-5977-b4ea-48323c572bfa"}}