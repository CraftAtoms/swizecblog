{"data":{"wordpressPost":{"title":"Declarative D3 transitions with React 16.3","content":"<p>The new React 16.3 brings some changes to the ecosystem that change how we go about integrating React and D3 to build data visualizations.</p>\n<p><code>componentWillReceiveProps</code>, <code>componentWillUpdate</code> and <code>compnentWillMount</code> are on their way out. They were great for making <a href=\"https://swizec.com/reactd3js\">React and D3</a> happy together, but they cause issues with the async rendering that the React team is planning for React 17.</p>\n<p>You tend to use those now-deprecated lifecycle methods to update D3 objects&#8217; internal state. Things like setting scale domains and ranges, updating complex D3 layouts, setting up transitions, etc.</p>\n<p>But you don&#8217;t need to! You can do it all with the new lifecycle API.</p>\n<p>Here&#8217;s a small example of building a transition with React 16.3.  Using only approved lifecycle callbacks and the new <code>ref</code> API.</p>\n<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/dipl9j1gpM8?feature=oembed\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe></p>\n<p>You can play with it on CodeSandbox üëá</p>\n<p><iframe src=\"https://codesandbox.io/embed/618mr9r6nr\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe></p>\n<h2>How it works</h2>\n<p>The core issue we&#8217;re working around is that when you pass new props into a component, React re-renders. This happens instantly. Because the re-render is instant, you don&#8217;t have time to show a nice transition going into the new state.</p>\n<p>You can solve this by rendering your component from <code>state</code> instead of props and keeping that state in sync.</p>\n<p>Something like this üëá</p>\n<img src=\"https://swizec.com/blog/wp-content/uploads/2018/04/carbon-945x1024.png\" alt=\"\" class=\"alignnone size-large wp-image-8327\" srcset=\"https://swizec.com/blog/wp-content/uploads/2018/04/carbon-945x1024.png 945w, https://swizec.com/blog/wp-content/uploads/2018/04/carbon-277x300.png 277w, https://swizec.com/blog/wp-content/uploads/2018/04/carbon-768x832.png 768w, https://swizec.com/blog/wp-content/uploads/2018/04/carbon.png 1312w\" sizes=\"(max-width: 945px) 100vw, 945px\" />\n<p>We define a <code>Ball</code> class-based component. Its state has a single attribute, <code>x</code>, which is set to the <code>props.x</code> value by default. That way our Ball component starts off rendered at the position the caller wants.</p>\n<p>Next, we create a new <code>circleRef</code> using the React 16.3 ref API. We use this reference to give D3 control of the DOM so it can run our transition.</p>\n<p>That happens in <code>componentDidUpdate</code>.</p>\n<pre lang=\"javascript\">\ncomponentDidUpdate() {\n    d3\n      .select(this.circleRef.current)\n      .transition()\n      .duration(1000)\n      .ease(d3.easeCubicInOut)\n      .attr(\"cx\", this.props.x)\n      .on(\"end\", () =>\n        this.setState({\n          x: this.props.x\n        })\n      );\n  }\n</pre>\n<p>React calls <code>componentDidUpdate</code> whenever we change our component&#8217;s props.</p>\n<p>We use <code>d3.select()</code> to give D3 control of the DOM node, run a transition that lasts <code>1000</code> milliseconds, define an easing function, and change the <code>cx</code> attribute to the new value we got from props.</p>\n<p>Right now, <code>state</code> holds the old position and <code>props</code> hold the new desired position.</p>\n<p>When our transition ends, we update state to match the new reality. This ensures React doesn&#8217;t get upset with us.</p>\n<p>At the very end, we have our <code>render()</code> function. It returns an SVG circle. Don&#8217;t forget to set the <code>ref</code> to <code>this.circleRef</code>.</p>\n<h2>Declarative üí™</h2>\n<p>We made sure our implementation is completely declarative. To the outside world at least.</p>\n<p>Making the ball jump left to right looks like this:</p>\n<pre lang=\"javascript\">\n// state = { ballLeft: false }\n// ballJump() flip ballLeft state\n// render()\n<svg style={{ width: \"300\", height: \"100px\" }} onClick={this.ballJump}>\n          <Ball x={ballLeft ? 15 : 300} />\n        </svg>\n</pre>\n<p>Our <code>state</code> holds a flag that says whether our ball is on the left. If it is, we pass an <code>x</code> prop value of <code>15</code>, otherwise <code>300</code>.</p>\n<p>When that value changes, the <code>&lt;Ball /&gt;</code> transitions itself to its new position. No need for us to worry.</p>\n<p>If we flip positions <em>during</em> a transition, D3 is smart enough to stop the previous transition and start a new one. UI looks perfect.</p>\n<p>Try it. üèÄ</p>\n<p><em>PS: I&#8217;m thinking about updating <a href=\"https://swizec.com/reactd3js\">my React+D3v4 book</a> for React 16.3 and D3v5. Would that interest you? <a href=\"http://twitter.com/home?status=Yo%20@swizec%20you%20should%20update%20your%20React+D3v4%20book\">Tell me on Twitter</a>.</em></p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"6133930b-be31-5448-b18a-97825a2461e6"}}