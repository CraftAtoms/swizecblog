{"data":{"wordpressPost":{"title":"(ab)Using d3.js to make a Pong game","content":"<p>D3.js is a data visualization library first and foremost. That&#8217;s what people use it for. To make shiny things that blow everyone&#8217;s minds.</p>\n<p>But D3 is more than that. It&#8217;s a powerful <a class=\"zem_slink\" title=\"Scalable Vector Graphics\" href=\"http://www.w3.org/Graphics/SVG/\" target=\"_blank\" rel=\"homepage\">SVG</a> manipulation library. Yes, some people would say <em>&#8220;But you don&#8217;t need an SVG manipulation library! You can just write SVG like you do <a class=\"zem_slink\" title=\"HTML\" href=\"http://en.wikipedia.org/wiki/HTML\" target=\"_blank\" rel=\"wikipedia\">HTML</a>&#8220;</em>. Those people are silly and probably write their own time manipulation functions as well.</p>\n<p>Recently I made a simple game of <a class=\"zem_slink\" title=\"Pong\" href=\"http://en.wikipedia.org/wiki/Pong\" target=\"_blank\" rel=\"wikipedia\">Pong</a> using D3. Nothing fancy, just two paddles that you can drag around, a ball that bounces to and fro, two score counters, and reacting to orientation changes on mobile devices. There isn&#8217;t even a start or stop button.</p>\n<p><iframe style=\"width: 100%; height: 400px;\" src=\"http://swizec.github.io/d3-pong/\"></iframe></p>\n<p>You can play the game <a href=\"http://swizec.github.io/d3-pong/\">here</a>, and see the code <a href=\"https://github.com/Swizec/d3-pong\">here</a>.</p>\n<p>It was a quick project though, so it doesn&#8217;t work on Firefox because of a weird SVG canvas sizing bug (I needed it to spread the whole screen) and some people have told me dragging the paddles doesn&#8217;t work on desktop. Worked for me. <em>shrug</em></p>\n<h2>Putting it together</h2>\n<p>There really isn&#8217;t much to making a game like this with D3.</p>\n<p>First we need some minimal HTML:</p>\n<pre lang=\"html\">\r\n<!DOCTYPE html>\r\n<meta charset=\"utf-8\">\r\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0\"/>\r\n<title>D3 pong</title>\r\n<link href='http://fonts.googleapis.com/css?family=Overlock' rel='stylesheet' type='text/css'>\r\n<link rel=\"stylesheet\" href=\"style.css\">\r\n\r\n<main></main>\r\n\r\n<script src=\"http://d3js.org/d3.v3.min.js\" charset=\"utf-8\"></script>\r\n<script src=\"d3-pong.js\"></script>\r\n\r\n</pre>\n<p>The HTML isn&#8217;t interesting. Our game will go in the <code>&lt;main&gt;&lt;/main&gt;</code> tag. The rest is about loading necessary files and telling mobile browsers not to act funny.</p>\n<p>We also need some <a class=\"zem_slink\" title=\"Cascading Style Sheets\" href=\"http://en.wikipedia.org/wiki/Cascading_Style_Sheets\" target=\"_blank\" rel=\"wikipedia\">CSS</a> to make sure our game fills the entire screen and things look decent.</p>\n<pre lang=\"css\">html, body, main {\r\n    height: 100%;\r\n    padding: 0;\r\n    margin: 0;\r\n    -webkit-box-sizing: border-box;\r\n    -moz-box-sizing: border-box;\r\n    box-sizing: border-box;\r\n}\r\n\r\nsvg {\r\n    width: 100%;\r\n    height: 99%; /* gets rid of scrollbar */\r\n}\r\n\r\ntext {\r\n    font-family: 'Overlock', cursive;\r\n    font-size: 1.5em;\r\n}\r\n\r\nline {\r\n    stroke: black;\r\n    stroke-width: 2;\r\n}\r\n\r\n.area {\r\n    fill: white;\r\n    stroke: \"red\";\r\n}</pre>\n<h2>The base elements</h2>\n<p>After that ground work, the fun begins.</p>\n<p>We create the SVG element, define some useful margins, and a helper function that turns css properties like <code>\"10px\"</code> into numbers.</p>\n<pre lang=\"javascript\">var svg = d3.select(\"main\")\r\n            .append(\"svg\"),\r\n        margin = {top: 10,\r\n                  right: 10,\r\n                  bottom: 10,\r\n                  left: 10},\r\n        parse = function (N) {\r\n            return Number(N.replace(\"px\", \"\"));\r\n        };</pre>\n<p>Simple.</p>\n<p>The <code>Screen</code> function will always tell us how much room we&#8217;ve got.</p>\n<pre lang=\"javascript\">var Screen = function () {\r\n            return {\r\n                width: parse(svg.style(\"width\")),\r\n                height: parse(svg.style(\"height\"))\r\n            };\r\n        };</pre>\n<p>Next up, making a paddle. For extra fun, I made it so creating a paddle returns a function we can call whenever we want to update the paddle&#8217;s position.</p>\n<pre lang=\"javascript\">Paddle = function (which) {\r\n            var width = 5,\r\n                area = svg.append('rect')\r\n                    .classed('area', true)\r\n                    .attr({width: width*7}),\r\n                paddle = svg.append('rect')\r\n                    .classed('paddle', true)\r\n                    .classed(which+\"_paddle\", true)\r\n                    .attr({width: 5}),\r\n                update = function (x, y) {\r\n                    var height = Screen().height*0.15;\r\n\r\n                    paddle.attr({\r\n                        x: x,\r\n                        y: y,\r\n                        height: height\r\n                    });\r\n                    area.attr({\r\n                        x: x-width*5/2,\r\n                        y: y,\r\n                        height: height\r\n                    });\r\n                    return update;\r\n                };</pre>\n<p>Because fingers are fat and paddles are thin, we defined an <code>area</code> that&#8217;s bigger than the actual paddle. This will be used as the drag handle. Then we&#8217;ve got the <code>paddle</code> itself &#8211; both of these are just SVG rectangles.</p>\n<p>The <code>update</code> function si a little bit more interesting, but not much. It just takes an <code>x, y</code> position and updates <code>paddle</code> and <code>area</code>.</p>\n<p>To make paddles draggable either with a mouse or a finger, we&#8217;re going to use D3&#8217;s draggable behavior. A pre-built function we can call on any SVG element to create listeners for all relevant events.</p>\n<p>All it requires of us is defining what actually happens when something gets dragged.</p>\n<p>This goes inside the <code>Paddle</code> function.</p>\n<pre lang=\"javascript\">// make paddle draggable\r\n            var drag = d3.behavior.drag()\r\n                    .on(\"drag\", function () {\r\n                        var y = parse(area.attr(\"y\")),\r\n                            height = Screen().height*0.1;\r\n\r\n                        update(parse(paddle.attr(\"x\")),\r\n                               Math.max(margin.top, \r\n                                        Math.min(parse(paddle.attr(\"y\"))+d3.event.dy,\r\n                                                 Screen().height-margin.bottom-height)));\r\n\r\n                    })\r\n                    .origin(function () {\r\n                        return {x: parse(area.attr(\"x\")),\r\n                                y: parse(area.attr(\"y\"))};\r\n                    });\r\n\r\n            area.call(drag);\r\n\r\n            return update;\r\n        },</pre>\n<p>The <code>\"drag\"</code> event represents any type of either mouse or touch event that might represent dragging. In the callback we essentially just call the <code>update</code> function with new coordinates. All that <code>Math.max</code> and <code>Math.min</code> nonsense makes sure paddles can&#8217;t be dragged out of the screen.</p>\n<p><code>.origin</code> is something this behaviour needs to calculate positions properly. It&#8217;s best to just set it to whatever is the current position of our element.</p>\n<p><code>area.call(drag);</code> activates the draggable behaviour on our draggable <code>area</code>.</p>\n<p>Next up &#8211; a function that keeps score.</p>\n<pre lang=\"javascript\">// generates a score, returns function for updating value and repositioning score\r\n        Score = function (x) {\r\n            var value = 0,\r\n                score = svg.append('text')\r\n                    .text(value);\r\n\r\n            return function f(inc) {\r\n                value += inc;\r\n\r\n                score.text(value)\r\n                    .attr({x: Screen().width*x,\r\n                           y: margin.top*3});\r\n                return f;\r\n            };\r\n        },</pre>\n<p>We&#8217;re going for the trick with returning update functions again. But other than that it&#8217;s really simple, just add a <code>text</code> element to the drawing area and give it a value. Don&#8217;t worry about that repositioning stuff for now.</p>\n<p>Nearly the same goes for the middle line &#8211; add a line, make sure it can be moved when needed.</p>\n<pre lang=\"javascript\">// generates middle line, returns function for updating position\r\n        Middle = function () {\r\n            var line = svg.append('line');\r\n\r\n            return function f() {\r\n                var screen = Screen();\r\n\r\n                line.attr({\r\n                    x1: screen.width/2,\r\n                    y1: margin.top,\r\n                    x2: screen.width/2,\r\n                    y2: screen.height-margin.bottom\r\n                });\r\n                return f;\r\n            };</pre>\n<p>The ball is going to be a bit more fun. Not only does it have to draw a simple circle and be able to move it around, it should also react to hitting obstacles and updating scores.</p>\n<p>This time we&#8217;re going to return a function that does a full step of the main animation. Things might get hairy.</p>\n<pre lang=\"javascript\">Ball = function () {\r\n            var R = 5,\r\n                ball = svg.append('circle')\r\n                    .classed(\"ball\", true)\r\n                    .attr({r: R,\r\n                           cx: Screen().width/2,\r\n                           cy: Screen().height/2}),\r\n                scale = d3.scale.linear().domain([0, 1]).range([-1, 1]),\r\n                vector = {x: scale(Math.random()),\r\n                          y: scale(Math.random())},\r\n                speed = 7;</pre>\n<p>We started with the simple stuff &#8211; drawing a ball, defining a random vector, and making up a speed that looked good on my screen.</p>\n<p>The collision logic is hairier.</p>\n<pre lang=\"javascript\">var hit_paddle = function (y, paddle) {\r\n                return y-R > parse(paddle.attr(\"y\")) && y+R < parse(paddle.attr(\"y\"))+parse(paddle.attr(\"height\"));\r\n            },\r\n            collisions = function () {\r\n                var x = parse(ball.attr(\"cx\")),\r\n                    y = parse(ball.attr(\"cy\")),\r\n                    left_p = d3.select(\".left_paddle\"),\r\n                    right_p = d3.select(\".right_paddle\");\r\n\r\n                // collision with top or bottom\r\n                if (y-R &lt; margin.top || y+R &gt; Screen().height-margin.bottom) {\r\n                    vector.y = -vector.y;\r\n                }\r\n\r\n                // bounce off right paddle or score\r\n                if (x+R &gt; parse(right_p.attr(\"x\"))) {\r\n                    if (hit_paddle(y, right_p)) {\r\n                        vector.x = -vector.x;\r\n                    }else{\r\n                        return \"left\";\r\n                    }\r\n                }\r\n\r\n                // bounce off left paddle or score\r\n                if (x-R &lt; \r\n                    parse(left_p.attr(\"x\"))+parse(left_p.attr(\"width\"))) {\r\n                    if (hit_paddle(y, left_p)) {\r\n                        vector.x = -vector.x;\r\n                    }else{\r\n                        return \"right\";\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            };</pre>\n<p>Hokay.</p>\n<p><code>hit_paddle</code> is a helper function that tells us whether the ball is touching a paddle - paddle position minus ball radius. Simple.</p>\n<p><code>collisions</code> looks hairy, but it's very repetitive:</p>\n<ul id=\"draft_check_box_list_0\">\n<li>if the ball hits top or bottom edge, its vertical position should flip.</li>\n<li>if the ball is to the right enough to hit the paddle, it will either flip its horizontal direction, or tell the calling code that <code>\"right\"</code> messed up</li>\n<li>same thing on the left</li>\n<li>if nothing happens, return false</li>\n</ul>\n<p>The last part of the <code>Paddle</code> function is the function that performs an animation step.</p>\n<pre lang=\"javascript\">return function f(left, right, delta_t) {\r\n                var screen = Screen(),\r\n                    // this should pretend we have 100 fps\r\n                    fps = delta_t &gt; 0 ? (delta_t/1000)/100 : 1; \r\n\r\n                ball.attr({\r\n                    cx: parse(ball.attr(\"cx\"))+vector.x*speed*fps,\r\n                    cy: parse(ball.attr(\"cy\"))+vector.y*speed*fps\r\n                });\r\n\r\n                var scored = collisions();\r\n\r\n                if (scored) {\r\n                    if (scored == \"left\") {\r\n                        left.score(1);\r\n                    }else{\r\n                        right.score(1);\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            };\r\n        };</pre>\n<p>It's pretty simple. First we update the ball's position according to the current vector, then we check for collisions and update scores if need be. Lastly we return <code>true</code> or <code>false</code> depending on whether we want the current animation to continue or not.</p>\n<h2>The main bit</h2>\n<p>Now that we've got all the elements, which sneakily contain most of our code already, it's time to put it all in motion.</p>\n<pre lang=\"javascript\"> // generate starting scene\r\n    var left = {score: Score(0.25)(0),\r\n                paddle: Paddle(\"left\")(margin.left, Screen().height/2)},\r\n        right = {score: Score(0.75)(0),\r\n                paddle: Paddle(\"right\")(Screen().width-margin.right, Screen().height/2)},\r\n        middle = Middle()(),\r\n        ball = Ball();</pre>\n<p><code>left</code> and <code>right</code> hold each player's score and paddle update functions, and <code>middle</code> and <code>ball</code> are the middle line and the ball.</p>\n<p>We also have to react to window resizing. This sneakily captures orientation changes as well.</p>\n<pre lang=\"javascript\">    // detect window resize events (also captures orientation changes)\r\n    d3.select(window).on('resize', function () {\r\n        var screen = Screen();\r\n\r\n        left.score(0);\r\n        left.paddle(margin.left, screen.height/2);\r\n        right.score(0);\r\n        right.paddle(screen.width-margin.right, screen.height/2);\r\n\r\n        middle();\r\n    });</pre>\n<p>When the screen changes, we just update the position of everything. See how always returning an update function made our life easier?</p>\n<p>And finally, we start the animation.</p>\n<pre lang=\"javascript\"> // start animation timer that runs until a player scores\r\n    // then reset ball and start again\r\n    function run() {\r\n        var last_time = Date.now();\r\n        d3.timer(function () {\r\n\r\n            var now = Date.now(),\r\n                scored = ball(left, right, now-last_time),\r\n                last_time = now;\r\n\r\n            if (scored) {\r\n                d3.select(\".ball\").remove();\r\n                ball = Ball();\r\n                run();\r\n            }\r\n            return scored;\r\n        }, 500);\r\n    };\r\n    run();</pre>\n<p>We used a <code>d3.timer</code> to create a custom animation loop that's tied to the graphics speed of the user's device. To counter for this, we feed a time delta into our <code>ball</code> animation function to create the appearance of consistent speed.</p>\n<p>Actual game developers told me I have to do that, so I did.</p>\n<p>When a user scores, we reset the ball to its current position and re-run everything. <code>d3.timer</code>'s main loop runs for as long as the function keeps returning <code>false</code>. We took care of that by returning <code>scored</code>.</p>\n<h2>Fin</h2>\n<p>And that's it. (ab)Using D3 to make a simple Pong game because we can. It was a fun hack, there are a million better tools you could use to make this, but I had fun.</p>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/?px\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" alt=\"Enhanced by Zemanta\" src=\"http://img.zemanta.com/zemified_e.png?x-id=7a0131b4-3a05-4d09-9408-40fa8cb003ce\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"5194b08a-fd84-5377-b4f2-55181b725cec"}}