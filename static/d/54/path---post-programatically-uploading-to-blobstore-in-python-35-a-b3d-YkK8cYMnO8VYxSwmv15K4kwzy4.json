{"data":{"wordpressPost":{"title":"Programatically uploading to blobstore in python","content":"<p>Officially this is something that cannot be done. Or rather that shouldn&#8217;t be done. When you look at the <a class=\"zem_slink freebase/en/google_app_engine\" title=\"Google App Engine\" rel=\"homepage\" href=\"http://code.google.com/appengine/\">google appengine</a> docs on &#8220;<a class=\"zem_slink freebase/en/uploading_and_downloading\" title=\"Uploading and downloading\" rel=\"wikipedia\" href=\"http://en.wikipedia.org/wiki/Uploading_and_downloading\">uploading</a> to blobstore&#8221; this is what they have to say:</p>\n<blockquote><p>Blobs are useful for serving large files, such as video or image files, and for allowing users to upload large data files.</p>\n<p>To prompt a user to upload a Blobstore value, your app presents a <a class=\"zem_slink freebase/guid/9202a8c04000641f8000000000955540\" title=\"Form (web)\" rel=\"wikipedia\" href=\"http://en.wikipedia.org/wiki/Form_%28web%29\">web form</a> with a file upload field.</p></blockquote>\n<p>So ok, obviously the official documentation isn&#8217;t of much use here since it only talks about letting users upload files. But I needed something different. I needed to fetch an image from an url (gotten by intricate means, different story) and store it in the blobstore so it could later be served to many users. Obviously since <a class=\"zem_slink freebase/en/file_system\" title=\"File system\" rel=\"wikipedia\" href=\"http://en.wikipedia.org/wiki/File_system\">file access</a> isn&#8217;t permitted on appengine the only choice left was storing the file in the blobstore.</p>\n<p>Naturally someone else has had this problem before right?</p>\n<p>No. There are no solutions I could find online. None. Nada. Zilch. Niente.</p>\n<p>After a few hours of hacking a week or so ago, however, I got it working.</p>\n<p>Essentially the solution is to fake a form post to the blobstore url the <a class=\"zem_slink freebase/guid/9202a8c04000641f80000000163b3ef7\" title=\"Application programming interface\" rel=\"wikipedia\" href=\"http://en.wikipedia.org/wiki/Application_programming_interface\">API</a> creates. An interesting gotcha is that a redirect happens. Initially I thought I was making the form post right back to my application, but apparently you&#8217;re first posting to the blobstore, then the blobstore posts back to you. For some reason I couldn&#8217;t keep the associated meta-data to go through with the request so there&#8217;s an ugly-ish workaround that happens.</p>\n<p>Another thing that&#8217;s important to note for this tutorial/howto is that I am using django-nonrel and that the initial event that starts the process is triggered by appengine&#8217;s task queue.</p>\n<h4>The howto</h4>\n<p>First, these are all the imports I&#8217;m using, there&#8217;s quite a few, so heh ðŸ™‚</p>\n<pre lang=\"python\">from django.http import HttpResponse, HttpResponseBadRequest, HttpRequest\r\nfrom django.views.decorators.csrf import csrf_exempt\r\nfrom django.conf import settings\r\nfrom django.core.urlresolvers import reverse\r\nimport simplejson as json\r\nimport urllib2, urllib\r\nfrom cStringIO import StringIO\r\n\r\nfrom google.appengine.api.urlfetch import ResponseTooLargeError, DownloadError\r\nfrom google.appengine.ext import blobstore\r\nfrom google.appengine.api import urlfetch\r\n\r\nfrom forms import ArticleProcForm\r\nfrom models import Article\r\nfrom lib import ImageExtractor\r\nfrom lib import urllib2_file\r\nfrom lib.urllib2_file import UploadFile\r\nfrom lib.decorators import form_valid</pre>\n<p>First thing that you&#8217;re going to need is the function that starts the whole process (in my case this is a django view)</p>\n<pre lang=\"python\">class ArticleProcForm(forms.Form):\r\n    article = forms.IntegerField(required=True)\r\n\r\n@csrf_exempt\r\n@form_valid(ArticleProcForm, 'POST')\r\ndef article(request):\r\n    try:\r\n        article = Article.objects.get(id=request.form.cleaned_data['article'])\r\n    except Article.DoesNotExist:\r\n        return HttpResponse(json.dumps({'status': 'Bad Article'}))\r\n\r\n    try:\r\n        image_url = ImageExtractor.getImages(article.url)[0]['url']\r\n    except IndexError:\r\n        pass\r\n    else:\r\n        # important bit\r\n        try:\r\n            image = StringIO(urllib2.urlopen(image_url).read())\r\n        except (urllib2.HTTPError, DownloadError):\r\n            pass\r\n        else:\r\n            image = UploadFile(image, '.'.join([str(article.id), image_url.rsplit('.', 1)[1][:4]]))\r\n            upload_url = blobstore.create_upload_url(reverse('Articles.views.upload'))\r\n\r\n            try:\r\n                urllib2.urlopen(upload_url, {'file': image})\r\n            except (DownloadError, RequestTooLargeError):\r\n                pass\r\n        # end of important bit\r\n\r\n    return HttpResponse(json.dumps({'status': 'OK'}))</pre>\n<p>Here is basically what happens in the important bit:</p>\n<ol>\n<li>Download image from url and change it to a StringIO</li>\n<li>Make an UploadFile (basically a bundle of <a class=\"zem_slink freebase/en/string\" title=\"String (computer science)\" rel=\"wikipedia\" href=\"http://en.wikipedia.org/wiki/String_%28computer_science%29\">byte-string</a>-data and desired filename)</li>\n<li>Create an upload_url with the blobstore API</li>\n<li>Fake a file-upload form post</li>\n</ol>\n<p>The next thing we need is a view that will handle the request the blobstore will send back to our app.</p>\n<pre lang=\"python\">@csrf_exempt\r\ndef upload(request):\r\n    if request.method == 'POST':\r\n        blobs = get_uploads(request, field_name='file', populate_post=True)\r\n\r\n        article = Article.objects.get(id=int(blobs[0].filename.split('.')[0]))\r\n        article.media = blobs[0].filename\r\n        article.parsed = True\r\n        article.save()\r\n\r\n        return HttpResponseRedirect(reverse('Articles.views.upload'))\r\n    else:\r\n        return HttpResponse('meow')</pre>\n<p>Basically it extracts the article&#8217;s id from the filename (the only way I could make work to pass that information) and stores some changes into the datastore. You&#8217;ll notice that I&#8217;m basically just storing the article&#8217;s id again in another field, this is to preserve knowledge of the file extension. It&#8217;s also important to note that the blobstore requires a redirect response upon success, otherwise it will throw an error.</p>\n<p>Here is the get_uploads function I found online somewhere.</p>\n<pre lang=\"python\">def get_uploads(request, field_name=None, populate_post=False):\r\n    \"\"\"Get uploads sent to this handler.\r\n    Args:\r\n      field_name: Only select uploads that were sent as a specific field.\r\n      populate_post: Add the non blob fields to request.POST\r\n    Returns:\r\n      A list of BlobInfo records corresponding to each upload.\r\n      Empty list if there are no blob-info records for field_name.\r\n    \"\"\"\r\n\r\n    if hasattr(request,'__uploads') == False:\r\n        request.META['wsgi.input'].seek(0)\r\n        fields = cgi.FieldStorage(request.META['wsgi.input'], environ=request.META)\r\n\r\n        request.__uploads = {}\r\n        if populate_post:\r\n            request.POST = {}\r\n\r\n        for key in fields.keys():\r\n            field = fields[key]\r\n            if isinstance(field, cgi.FieldStorage) and 'blob-key' in field.type_options:\r\n                request.__uploads.setdefault(key, []).append(blobstore.parse_blob_info(field))\r\n            elif populate_post:\r\n                request.POST[key] = field.value\r\n    if field_name:\r\n        try:\r\n            return list(request.__uploads[field_name])\r\n        except KeyError:\r\n            return []\r\n    else:\r\n        results = []\r\n        for uploads in request.__uploads.itervalues():\r\n            results += uploads\r\n        return results</pre>\n<p>Now the process of serving this blob to the browser is very simple and goes something like this:</p>\n<pre lang=\"python\">class ImageForm(forms.Form):\r\n    id = forms.CharField(required=True)\r\n\r\n@form_valid(ImageForm, 'GET')\r\n@cache_response\r\ndef image(request):\r\n    blob = BlobInfo.gql(\"WHERE filename='%s' LIMIT 1\" % request.form.cleaned_data['id'])[0]\r\n\r\n    return HttpResponse(BlobReader(blob.key()).read(),\r\n                        content_type=blob.content_type)</pre>\n<h4>One final note</h4>\n<p>And one VERY important final note. The vanilla urllib2 library can&#8217;t handle file uploads, so I found one online that can. It&#8217;s called <a href=\"http://fabien.seisen.org/python/urllib2_file/\">urllib2_file</a>.</p>\n<p>However it doesn&#8217;t quite work on google appengine. For example it can&#8217;t handle being told what you want the filename to be and some other details because it relies on raw file access. So I changed it a little bit, unfortunately I don&#8217;t quite know how to upstream my changes so I&#8217;m hosting it on github.</p>\n<p>You can get it <a href=\"http://github.com/Swizec/urllib2_file\">at github</a>, feel free to contribute.</p>\n<h6 class=\"zemanta-related-title\" style=\"font-size: 1em;\">Related articles by Zemanta</h6>\n<ul class=\"zemanta-article-ul\">\n<li class=\"zemanta-article-ul-li\"><a href=\"http://blog.notdot.net/2010/08/Using-BlobReader-wildcard-subdomains-and-webapp2\">Using BlobReader, wildcard subdomains and webapp2 on Google AppEngine</a> (notdot.net)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://swizec.com/blog/django-protip-2-forms-are-awesome/swizec/1410\">Django protip #2: Forms are awesome</a> (swizec.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://googleappengine.blogspot.com/2010/06/app-engine-sdk-135-released-with-new.html\">App Engine SDK 1.3.5 Released With New Task Queue, Python Precompilation, and Blob Features</a> (googleappengine.blogspot.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb\">Parsing file uploads at 500 mb/s with node.js</a> (debuggable.com)</li>\n</ul>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" src=\"http://img.zemanta.com/zemified_e.png?x-id=82ae7610-8dea-47af-9e81-485f91ffacd6\" alt=\"Enhanced by Zemanta\" /></a><span class=\"zem-script more-related more-info pretty-attribution\"><script src=\"http://static.zemanta.com/readside/loader.js\" type=\"text/javascript\"></script></span></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"b4df8ef6-cb62-5c09-8b3f-2e69197d07c7"}}