{"data":{"wordpressPost":{"title":"Arcane JavaScript knowledge still useful","content":"<p>ES6 has been with us for 2 years. <a href=\"https://es2017.io\">ES2016 and ES2017</a> are standard practice. ES2018 is just around the corner.</p>\n<p>And yet, sometimes you still need JavaScript practices so arcane you&#8217;ve almost forgotten they exist. Such was the case with a production bug we discovered after a performance optimization.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\">\n<p lang=\"en\" dir=\"ltr\">When you get </p>\n<p>Uncaught TypeError: Cannot read property &#39;call&#39; of undefined<br />    at __webpack_require__</p>\n<p>But only on every 4th page load. Sometimes 3rd. Or 7th. <a href=\"https://t.co/7T7gXFwQmi\">pic.twitter.com/7T7gXFwQmi</a></p>\n<p>&mdash; Swizec (@Swizec) <a href=\"https://twitter.com/Swizec/status/928761345750605825?ref_src=twsrc%5Etfw\">November 9, 2017</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>Every once in a while, you would refresh <a href=\"https://www.yup.com\">our webapp</a> and stare at the loading animation forever. Yes, we have one of those because we&#8217;re cool.</p>\n<img class=\"alignnone size-full wp-image-7930\" src=\"https://swizec.com/blog/wp-content/uploads/2017/11/yuploader.gif\" width=\"370\" height=\"260\" />\n<p>We worked hard on it, and it looks great. But we don&#8217;t want you to be stuck staring at it never getting to the page.</p>\n<p>We traced the problem down to a JavaScript error during app initialization. Sometimes Webpack would try to execute modules before they were ready.</p>\n<p>This shows up as a cryptic error ðŸ‘‡</p>\n<pre><code>Uncaught TypeError: Cannot read property 'call' of undefined\n    at __webpack_require__\n</code></pre>\n<p>It happens on this line inside <code>manifest.js</code> ðŸ‘‡</p>\n<pre><code>// Execute the module function\nmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n</code></pre>\n<p>Now <code>manifest.js</code> is a generated file, so there isn&#8217;t much you can do to fix it. In fact, you shouldn&#8217;t have to fix it. Or even consider modifying it. Ever.</p>\n<p>Webpack generates this file when you compile your code and uses it to bootstrap your code. It builds a list of modules inside that <code>modules</code> dictionary and executes them when you run <code>import</code> or <code>require()</code>.</p>\n<p>Usually, this either always works or never works.</p>\n<p>It always works when your code is correct. It never works when you forget to <code>export</code> your module.</p>\n<p>But it&#8217;s never supposed to get into such a situation that it <em>sometimes</em> works and sometimes doesn&#8217;t. That is right out.</p>\n<p>So I started to dig.</p>\n<p>And dig.</p>\n<p>And dig some more.</p>\n<p>Our bug stymied even grandmaster TheLarkInn.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\">\n<p lang=\"und\" dir=\"ltr\">Wat.</p>\n<p>&mdash; Sean Thomas Larkin (@TheLarkInn) <a href=\"https://twitter.com/TheLarkInn/status/928789785124016128?ref_src=twsrc%5Etfw\">November 10, 2017</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>I dug for an hour. Then two. Then five.</p>\n<p>I tried everything. I added console logs into manifest.js to track which module exactly was causing a problem. I used <a href=\"https://webpack.github.io/analyse/\">Webpack&#8217;s official analyze tool</a> to inspect our builds and associate <code>moduleId</code>s with specific code files.</p>\n<p>At up to 3 minutes per compile, it was slow going.</p>\n<p>I changed this and that and nothing worked.</p>\n<img class=\"alignnone size-full wp-image-7931\" src=\"https://swizec.com/blog/wp-content/uploads/2017/11/tired-at-computer.gif\" width=\"500\" height=\"373\" />\n<p>Then I found this old article Jake Archibald published in 2013. <a href=\"https://www.html5rocks.com/en/tutorials/speed/script-loading/\">Deep dive into the murky waters of script loading</a></p>\n<p>In it, he explained that scripts dynamically inserted into the DOM were <code>async</code> by default.</p>\n<p>ðŸ’¡</p>\n<p>Why does that matter? Because our performance optimization made our scripts <code>preload</code> then injected them into the DOM when the files were loaded.</p>\n<p>This meant that <em>sometimes</em> our <code>main_code.js</code> would start executing <em>before</em> our <code>main_code_vendor.js</code> file was loaded. As a result, core libraries our code depends on weren&#8217;t loaded yet by the time our code tried to use them.</p>\n<p>Ha!</p>\n<h2>Some background</h2>\n<p>Let me give you some background.</p>\n<p>We use <a href=\"https://swizec.com/blog/dirty-hack-took-30percent-off-webpack-size/swizec/7657\">Webpack to split our app into multiple files</a>. Libraries go into an <code>app_vendor.js</code> file, and our code goes into an <code>app.js</code> file. Most of our apps also have chunks that Webpack loads asynchronously when they&#8217;re needed.</p>\n<p>So you need to load at least 3 JavaScript files to make any of our apps work</p>\n<ol>\n<li>manifest.js</li>\n<li>app_vendor.js</li>\n<li>app.js</li>\n</ol>\n<p>Loading scripts as <code>async</code> is an old technique to make webapps faster. You write <code>&lt;script src=\"bla\" async&gt;&lt;/script&gt;</code> and the browser doesn&#8217;t wait for JavaScript to load before moving on to rendering the rest of your DOM.</p>\n<p>This is great, but it leads to problems. Scripts might execute in random order.</p>\n<p>So instead, we used <code>defer</code> for a long time. This downloads scripts without waiting for them, then executes all of them in order as they were defined.</p>\n<p>Wonderful.</p>\n<p>But preloading is even better ðŸ‘‰ <code>&lt;link rel=\"preload\" href=\"bla\" onload=\"loadJsFiles(this.href) /&gt;</code>. With preloading, you&#8217;re loading scripts without waiting for them, potentially before the user even opens your site, then executing a callback to say <em>&#8220;Ok we got the script, now what?&#8221;</em></p>\n<p>In our case, the <em>&#8220;now what&#8221;</em> part would create a <code>script</code> DOM node and insert it into the page. That makes it execute.</p>\n<pre lang=\"javascript\">\nfunction loadJsFile(file) {\n    // keep track of what's been loaded\n    if (allScriptsLoaded) {\n        loadedScripts.forEach(function () {\n            var script = document.createElement('script');\n            script.src = '<%= \"#{js_file_href}\" %>';            document.body.appendChild(script);\n        })\n    }\n}\n</pre>\n<p>Keep track of all scripts that were loaded, insert them into the DOM, and trigger their execution when all are ready.</p>\n<h2>The solution</h2>\n<p>This <em>&#8220;Preload as much as possible, insert into DOM when all is ready&#8221;</em> works great.</p>\n<p>Except when it doesn&#8217;t.</p>\n<p><em>Sometimes</em> they would execute in the wrong order. Our business code would start executing before our vendor code and discover that the libraries it needs weren&#8217;t there.</p>\n<p>ðŸ’©</p>\n<p>But why? We wait until all scripts are preloaded before inserting them into the page.</p>\n<p>Because dynamically inserted scripts are <code>async</code> by default. You have explicitly disable that with <code>script.async = false</code>.</p>\n<p>And everything works.</p>\n<p>2013-era JavaScript strikes again. Still relevant.</p>\n<img class=\"alignnone size-full wp-image-7929\" src=\"https://swizec.com/blog/wp-content/uploads/2017/11/cosby-facepalm.gif\" width=\"400\" height=\"271\" />\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"da063804-6d8c-523a-8f8d-53dca50b7697"}}