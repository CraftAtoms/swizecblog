{"data":{"wordpressPost":{"title":"Using YouTube as a data source in Gatsbyjs","content":"<p><em>This is a Livecoding Recap ‚Äì an almost-weekly post about interesting things discovered while livecoding. Usually shorter than 500 words. Often with pictures. Livecoding happens almost <strong>every Sunday at 2pm PDT</strong> on multiple channels. You should subscribe to <a href=\"https://www.youtube.com/TheSwizec\">My Youtube</a> channel to catch me live.</em></p>\n<p><iframe width=\"580\" height=\"326\" src=\"https://www.youtube.com/embed/o_sXQ4fWHac?feature=oembed\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe></p>\n<p><a href=\"https://www.gatsbyjs.org/\">Gatsby</a> is hands down the best static site generator out there. Builds sites so fast it looks like a bug.</p>\n<p>The magic trick Gatsby uses to make sites so fast is binding data build time. Most modern server-side-rendered (ssr) sites build an HTML page of your initial view, load data into the browser, and build the rest of the page live. Or they render a skeleton and fill it with dynamic data.</p>\n<blockquote class=\"twitter-tweet\" data-width=\"550\" data-dnt=\"true\">\n<p lang=\"en\" dir=\"ltr\">Just had a CS-y insight into <a href=\"https://twitter.com/gatsbyjs?ref_src=twsrc%5Etfw\">@gatsbyjs</a> </p>\n<p>Gatsby is early binding for code *and* data</p>\n<p>Most web apps early bind code (at build) and late bind data. Gatsby does both at build time which really speeds up running the site.</p>\n<p>Gatsby can also do late binding for data from the client.</p>\n<p>&mdash; Kyle Mathews (@kylemathews) <a href=\"https://twitter.com/kylemathews/status/988484209697210368?ref_src=twsrc%5Etfw\">April 23, 2018</a></p></blockquote>\n<p><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script></p>\n<p>Gatsby does all that at build time. Run <code>gatsby build</code>, and it loads your dynamic data and builds static HTML pages with data-dependent parts already baked in.</p>\n<h2>How you use it</h2>\n<p>At a high level, Gatsby uses various source plugins to read data and make it available via a GraphQL interface. You write GraphQL queries to load this data and render React components.</p>\n<p>Gatsby handles the rest. I&#8217;m not really sure how, but smart people assure me it works, and I&#8217;ve never seen it not work. ü§∑‚Äç‚ôÄÔ∏è</p>\n<p>Let&#8217;s say you want to build pages with markdown files. I do that for my workshop materials. I use a bunch of markdown files published as a website, and it works great.</p>\n<p>You have to enable the <code>gatsby-source-filesystem</code> plugin. It lets you read local files as a data source. Then you enable the <code>gatsby-transformer-remark</code> plugin, which lets you parse markdown files.</p>\n<p>When that&#8217;s set up, you can get a list of page titles with a query like this:</p>\n<pre lang=\"javascript\">\n// anywhere in your JS\nexport const query = graphql`\n    allMarkdownRemark {\n        edges {\n            node {\n                frontmatter {\n                    title\n                }\n                fields {\n                    slug\n                }\n            }\n        }\n    }\n`;\n</pre>\n<p>You&#8217;re looking for all nodes of the <code>markdownRemark</code> type, collecting their <code>edges</code> and <code>nodes</code>, and plucking the <code>title</code> and <code>slug</code> value of each.</p>\n<p>This shows up in your page component as a <code>data</code> prop. So to list all those page titles, you&#8217;d do something like this üëá</p>\n<pre lang=\"javascript\">\nconst allPages = _.sortBy(\n            data.allMarkdownRemark.edges,\n            ({ node }) => node.fields.slug\n        );\n\n<ul>\n    {allPages.map(({ node: { frontmatter: { title }}}) => <li>{title}</li>)}\n</ul>\n</pre>\n<p>There&#8217;s a lot of looping and destructuring because our data comes in the shape of a graph, and I&#8217;m bad at writing GraphQL queries. I&#8217;m sure this looks terrible to someone who knows what they&#8217;re doing.</p>\n<h2>Adding a custom data source ‚Äì&nbsp;YouTube</h2>\n<p>The fun part is building your own data sources, which you can do, and it&#8217;s easier than I thought.</p>\n<p>Your basic approach goes like this:</p>\n<ol>\n<li>Search far and wide for an existing plugin</li>\n<li>Give up and realize you&#8217;ll have to build it yourself</li>\n<li>Strongly consider building a releasable plugin</li>\n<li>Decide you&#8217;re better off building a one-off integration</li>\n<li>Spend the next hour fiddling inside <code>gatsby-node.js</code></li>\n</ol>\n<p>Your goal is to read your data source and create Gatsby data nodes for each object you want to make available.</p>\n<p>The general template goes like this:</p>\n<pre lang=\"javascript\">\n// gatsby-node.js\nexports.sourceNodes = async ({ boundActionCreators }) => {\n    const { createNode } = boundActionCreators;\n \n    // get data\n    // call createNode for each entry\n}\n</pre>\n<p>You can see <a href=\"https://github.com/Swizec/learnwhileyoupoop.com/blob/2749ed3654e8f9a222fa6df77cb20e7ead91c174/gatsby-node.js\">my full code on GitHub</a>.</p>\n<p>My goal was a list of videos from a YouTube playlist. I used <a href=\"https://github.com/benkaiser/youtube-playlist-info\">youtube-playlist-info</a> to fetch a list of videos from a public playlist. Google&#8217;s official node.js library is too hard to use.</p>\n<pre lang=\"javascript\">\n// gatsby-node.js\n\n// require library\nconst ypi = require('youtube-playlist-info')\n// read my API key\nconst YT_KEY = require('./client_secrets.json')['yt_key']\n// hardcode ID of my playlist for now\nconst LWyP = 'PLF8WgaD4xmjWuh7FTYTealxehOuNor_2S'\n\nexports.sourceNodes = async ({ boundActionCreators }) => {\n  const { createNode } = boundActionCreators\n  const items = await ypi(YT_KEY, LWyP)\n  \n  // build Gatsby nodes\n}\n</pre>\n<p>When Gatsby builds my site, it goes into <code>gatsby-nodes</code> and calls my node builder function. This uses <code>ypi</code> to fetch a list of videos from the hardcoded <a href=\"https://www.youtube.com/playlist?list=PLF8WgaD4xmjWuh7FTYTealxehOuNor_2S\">Learn While You Poop playlist</a>.</p>\n<p>Yes, that means building the site is now slow. It has to talk to YouTube&#8217;s API every time, but it‚Äôs worth it.</p>\n<p>Your next step is to build Gatsby nodes for each video in the playlist.</p>\n<p>Nodes require a <code>contentDigest</code> so Gatsby can tell whether they&#8217;ve changed. To make that easier, I built a helper function üëá</p>\n<pre lang=\"javascript\">\n// gatsby-node.js\n\n  const makeNode = node => {\n    node.internal.contentDigest = crypto\n      .createHash('md5')\n      .update(JSON.stringify(node))\n      .digest('hex')\n\n    createNode(node)\n  }\n</pre>\n<p><code>makeNode</code> is a thin wrapper on Gatsby&#8217;s built-in <code>createNode</code> function that automatically generates an <code>md5</code> hash of the whole node and saves it in <code>contentDigest</code>. Not sure why this isn&#8217;t default behavior.</p>\n<p>With that set up, you can build your nodes in a loop like this:</p>\n<pre lang=\"javascript\">\n// gatsby-node\n\n  let lwypNode = {\n    id: 'lwypPlaylist',\n    parent: 'ytPlaylists',\n    children: [],\n    internal: {\n      type: 'ytPlaylist',\n    },\n  }\n\n  lwypNode.children = items.map(\n    ({ title, description, resourceId, thumbnails, position }) => {\n      const id = `ytVideo-${resourceId.videoId}`\n      makeNode({\n        id,\n        title,\n        description,\n        thumbnails,\n        position,\n        resourceId,\n        internal: {\n          type: 'ytVideo',\n        },\n        parent: 'lwypPlaylist',\n        children: [],\n      })\n      return id\n    }\n  )\n\n  makeNode(lwypNode)\n</pre>\n<p>Set up an empty node for the <code>lwypPlaylist</code> of type <code>ytPlaylist</code>. Fill its children with nodes that contain important data from the YouTube API.</p>\n<p>When all those nodes are created, <em>then</em> create the main <code>lwypNode</code>. This reverse order is important. You have to build your data graph from the bottom up otherwise you&#8217;ll get strange errors.</p>\n<p>You can see me struggling with that in the video above. Lots of head scratching.</p>\n<h2>Read your YouTube data source</h2>\n<p>When your nodes are created, you can read them anywhere inside Gatsby with a GraphQL query like this üëá</p>\n<pre lang=\"javascript\">\nexport const query = graphql`\n  query LwypPlaylist {\n    ytPlaylist(id: { eq: \"lwypPlaylist\" }) {\n      childrenYtVideo {\n        id\n        title\n        description\n      }\n    }\n  }\n`\n</pre>\n<p>Fetch a node of type <code>ytPlaylist</code> with <code>id</code> equal to <code>lwypPlaylist</code>. Inside that node, get all children <code>ytVideo</code> nodes and their <code>id</code>, <code>title</code>, and <code>description</code>.</p>\n<p>You can then render them in a loop.</p>\n<pre lang=\"javascript\">\nComponent = ({ data }) => {\n    const videos = data.ytPlaylist.childrenYtVideo;\n \n    return <div>{videos.map(video => \n        <div>\n        <h3>{video.title}</h3>\n        {video.description}\n      </div>\n  )}</div>\n}\n</pre>\n<p>Full page coming soon.</p>\n<img src=\"https://media.giphy.com/media/u0v3z2iQLxyHC/giphy.gif\" />\n<p>Should I make a real YouTube source plugin for Gatsby? <a href=\"https://twitter.com/Swizec\">Ping me on Twitter</a>.</p>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"65d2005f-caf5-55ad-984d-6c5ff2bf36f5"}}