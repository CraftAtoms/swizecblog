{"data":{"wordpressPost":{"title":"Collatz, Haskell and Memoization","content":"<div style=\"width: 321px\" class=\"wp-caption alignright\"><a href=\"http://xkcd.com/710/\"><img title=\"xkcd collatz conjecture\" src=\"http://swizec.com/blog/wp-content/uploads/2012/01/collatz_conjecture3.png\" alt=\"xkcd collatz conjecture\" width=\"311\" height=\"452\" /></a><p class=\"wp-caption-text\">xkcd collatz conjecture</p></div>\n<p>After an awesome <a class=\"zem_slink\" title=\"Longboarding\" href=\"http://en.wikipedia.org/wiki/Longboarding\" rel=\"wikipedia\">longboarding</a> session yesterday afternoon I decided to play around with <a class=\"zem_slink\" title=\"Sequence\" href=\"http://en.wikipedia.org/wiki/Sequence\" rel=\"wikipedia\">infinite sequences</a> in <a class=\"zem_slink\" title=\"Haskell (programming language)\" href=\"http://haskell.org\" rel=\"homepage\">Haskell</a> &#8211; it&#8217;s supposed to be one of the more (most?) powerful features of Haskell &#8211; because it&#8217;s a <a class=\"zem_slink\" title=\"Evaluation strategy\" href=\"http://en.wikipedia.org/wiki/Evaluation_strategy\" rel=\"wikipedia\">lazy language</a> apparently.</p>\n<p>My first impulse of creating a primes generator was nipped in the bud by a long page of <a href=\"http://www.haskell.org/haskellwiki/Prime_numbers\" target=\"_blank\">prime number generators in Haskell</a>. Scary, complex, mindboggling.</p>\n<p><a class=\"zem_slink\" title=\"Project Euler\" href=\"http://projecteuler.net/\" rel=\"homepage\">Project Euler</a> posed a much better challenge:Â <em>Which starting number, under one million, produces the longest collatz chain?</em></p>\n<p>The solution I came up with was a simple brute force generator of infinitely many collatz sequences. Then I would take the first 1,000,000 find the maximum and that&#8217;s that.</p>\n<pre lang=\"haskell\">\r\ncollatz :: Integer -> [Integer]\r\ncollatz 1 = []\r\ncollatz n\r\n    | odd n = 3*n+1:collatz(3*n+1)\r\n    | even n = div n 2:collatz(div n 2)\r\n\r\nchains = [collatz x | x <- [1..]]\r\n</pre>\n<p>Didn't help.</p>\n<p>So I started looking for the maximum a bit differently - take all the sequences, sort them by length and take the last one.</p>\n<pre lang=\"haskell\">longest max =\r\n  last $ sortBy (comparing snd) $ zip [1..] $ map length $ take max chains</pre>\n<p>Great! It worked! But it takes ~26 seconds!</p>\n<p>Well sorting maybe isn't the best idea ever, so let's try creating a list of sequences where the list's tail only contains those sequences that are longer than the head. A sprinkle of dropWhile and it was done.</p>\n<pre lang=\"haskell\">longest' (max_i, max_l) =\r\n  let l = head $ dropWhile (\\(i,l) -> l <= max_l) $ zip [max_i..] $ map length $ chains' max_i\r\n  in l:longest' l\r\n</pre>\n<p>~25 seconds!</p>\n<p>That's odd ... even odder still is running both algorithms one after another only takes 33 seconds. Huh?</p>\n<p>It would seem I'm using <a class=\"zem_slink\" title=\"Memoization\" href=\"http://en.wikipedia.org/wiki/Memoization\" rel=\"wikipedia\">memoization</a> incorrectly. I've heard it performs funny in recursive functions. The theory I formulated last night was that because haskell was lazy each execution chain was constructed to its end and the intermittent memoized values never got used until the whole function was called again.</p>\n<p>Looking at the code samples this morning, though, I discovered this:</p>\n<pre lang=\"haskell\">collatz :: Integer -> [Integer]\r\ncollatz = memoize col where\r\n  col 1 = []\r\n  col n\r\n    | odd n = 3*n+1:collatz(3*n+1)\r\n    | even n = div n 2:collatz(div n 2)\r\n</pre>\n<p>As you can see, I don't call the memoized function internally. Just goes to show what a night's sleep can do to one's coding abilities. I bashed my head against this problem for four hours yesterday and I never noticed I was recursing to the wrong function!</p>\n<p>Interestingly enough, fixing that makes the algorithm spaz out and die after 16 seconds. The only output I get is \"Killed\". Curious.</p>\n<h6 class=\"zemanta-related-title\" style=\"font-size: 1em;\">Related articles</h6>\n<ul class=\"zemanta-article-ul\">\n<li class=\"zemanta-article-ul-li\"><a href=\"http://mrhonner.com/2011/11/18/graphing-the-collatz-conjecture/\">Graphing the Collatz Conjecture</a> (mrhonner.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/\">The Point of Laziness in Programing Languages</a> (existentialtype.wordpress.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://swizec.com/blog/learning-me-a-haskell/swizec/3272\">Learning me a Haskell</a> (swizec.com)</li>\n<li class=\"zemanta-article-ul-li\"><a href=\"http://geeklogs.posterous.com/what-is-memoization\">Memoization explained using a python implementation of fibonacci</a> (geeklogs.posterous.com)</li>\n</ul>\n<div class=\"zemanta-pixie\" style=\"margin-top: 10px; height: 15px;\"><a class=\"zemanta-pixie-a\" title=\"Enhanced by Zemanta\" href=\"http://www.zemanta.com/\"><img class=\"zemanta-pixie-img\" style=\"border: none; float: right;\" src=\"http://img.zemanta.com/zemified_e.png?x-id=6f7c0838-57e3-4b8a-a0c3-3ef0dc670559\" alt=\"Enhanced by Zemanta\" /></a></div>\n"},"site":{"siteMetadata":{"title":"Swizec Blog","subtitle":"Fetch Data From Local WP Install"}}},"pageContext":{"id":"b3c65016-cb0f-5c3e-9f30-fc29038e54a3"}}