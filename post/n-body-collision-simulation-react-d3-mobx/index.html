<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/swizecblog/component---src-components-post-js.345c7c4f16662f410581.css">@import url(https://fonts.googleapis.com/css?family=Lora);
html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;font-family:Lora,serif}body{background-color:#f6f6f6;margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{-webkit-text-decoration-skip:objects;background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:Lora,serif;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{box-sizing:border-box;font:112.5%/1.45em georgia,serif;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{-moz-font-feature-settings:"kern","liga","clig","calt";-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";color:rgba(0,0,0,.8);font-family:Lora,serif;font-feature-settings:"kern","liga","clig","calt";font-kerning:normal;font-weight:400;word-wrap:break-word}img{margin:0 0 1.45rem;max-width:100%;padding:0}h1{font-size:2.25rem}h1,h2{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{list-style-image:none;list-style-position:outside;margin:0 0 1.45rem 1.45rem;padding:0}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{background:rgba(0,0,0,.04);border-radius:3px;font-size:.85rem;line-height:1.42;margin:0 0 1.45rem;overflow:auto;padding:1.45rem;word-wrap:normal}table{border-collapse:collapse;font-size:1rem;line-height:1.45rem;width:100%}fieldset,table{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{background:rgba(0,0,0,.2);border:none;height:1px;margin:0 0 calc(1.45rem - 1px);padding:0}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-bottom:.725rem;margin-left:1.45rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:Lora,serif;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{content:" ";letter-spacing:-.2em}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}

/*# sourceMappingURL=component---src-components-post-js.345c7c4f16662f410581.css.map*/</style><style data-styled-components="cEsjyT hklXLQ gpHXOM cTUdjA">
/* sc-component-id: sc-bdVaJa */
.cEsjyT{margin:3rem auto;max-width:960px;padding:1.25rem 1rem;} .cEsjyT ul{margin:0 0 0px 0;list-style:none;float:right;}
/* sc-component-id: sc-bwzfXH */
.cTUdjA{-webkit-text-decoration:none;text-decoration:none;text-align:right;margin:0 .5rem 0 .5rem;padding:10px;color:#7c51a1;} .cTUdjA:hover{color:#fff;background-color:#7c51a1;}
/* sc-component-id: sc-htpNat */
.gpHXOM{-webkit-text-decoration:none;text-decoration:none;color:black;} .gpHXOM:hover{-webkit-text-decoration:underline;text-decoration:underline;color:#7c51a1;} .gpHXOM h3{display:inline;font-size:30px;}
/* sc-component-id: sc-bxivhb */
.hklXLQ{margin:0 3rem 4.5rem;}</style><title data-react-helmet="true">Swizec Blog</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><link as="script" rel="preload" href="/swizecblog/component---src-components-post-js-dbedf083f25f7ad1f3b1.js"/><link as="script" rel="preload" href="/swizecblog/0-f215691c134019ee6fa5.js"/><link as="script" rel="preload" href="/swizecblog/app-49ff0b4ea28eff25fc3b.js"/><link as="script" rel="preload" href="/swizecblog/webpack-runtime-4f3a0bd1eef0c4ba11a9.js"/><link rel="preload" href="/swizecblog/static/d/107/path---post-n-body-collision-simulation-react-d-3-mobx-029-d8e-KxdkSXWslEAuvuzLif5QST6ksgc.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div><div class="sc-bdVaJa cEsjyT"><div class="sc-bxivhb hklXLQ"><a class="sc-htpNat gpHXOM" href="/swizecblog/"><h3>Swizec Teller</h3></a><ul><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Business/">Business</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Personal/">Personal</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Technical/">Technical</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Thoughts/">Thoughts</a></ul></div><h1>N-body Collision Simulation with React, D3, and MobX</h1><div><p><iframe width="853" height="480" src="https://www.youtube.com/embed/H84fmXjTElM" frameborder="0" allowfullscreen></iframe></p>
<p>Collision detection is one of those problems that&#39;s easy in theory but hard in practice. Even between ideal circles.</p>
<p>All you have to do is:</p>
<ol>
<li>For every item, find all items with which it intersects</li>
<li>Change its movement vector so it reacts to the collision</li>
<li>Potentially change vectors of other items involved in collision</li>
</ol>
<p>This is called <a href="https://en.wikipedia.org/wiki/Collision_detection#A_posteriori_.28discrete.29_versus_a_priori_.28continuous.29">a posteriori collision detection</a>. It detects collisions <em>after</em> they happen and corrects in the next animation frame. If items move very fast, they can pass through each other.</p>
<p>Another approach is called a priori collision detection. That predicts collisions <em>before</em> they happen. It&#39;s more correct, but it’s hard to implement because predicting when two items will collide is, in theory, an algorithm with infinite steps. Wikipedia says the problem doesn&#39;t have a <a href="https://en.wikipedia.org/wiki/Closed-form_expression">closed-form solution</a>.</p>
<p>As per this <a href="https://wwwx.cs.unc.edu/~geom/papers/documents/dissertations/lin93.pdf">159 page thesis on collision detection</a>, collision detection is important.</p>
<blockquote><p>
The problem of collision detection or contact determination between two or more objects is fundamental to computer animation, physical-based modeling, molecular modeling, computer simulated environments (e.g. virtual environments) and robot motion planning as well. (Depending on the content of applications, it is also called with many different names, such as interference detection, clash detection, intersection tests, etc.)
</p></blockquote>
<p>Indeed. It&#39;s also fun to build. You can play with the final solution in this <a href="https://swizec.github.io/declarative-canvas-react-konva/">live example</a>.</p>
<p>Here is my first attempt ?</p>
<img class="alignnone size-full wp-image-7496" src="https://swizec.com/blog/wp-content/uploads/2017/03/base-collision.gif" width="616" height="589" />
<p>? Hmmmm… the two marbles do bounce off each other, but that&#39;s not quite right. They come too close together before bouncing.</p>
<p>On my second attempt, I used <a href="https://github.com/d3/d3-quadtree">D3v4&#39;s quadtree</a> to detect the collision. Quadtrees subdivide a space based on a list of coordinates. In my case, it’s a list of marbles. You can then perform fast lookups for <em>&quot;Which items are within radius R of coordinates (x, y)?”</em>.</p>
<p>With some finagling, we can use a quadtree to reduce our n-body collision problem to a series of 2-body collision problems. Each item collides only with its nearest neighbor.</p>
<img class="alignnone size-full wp-image-7491" src="https://swizec.com/blog/wp-content/uploads/2017/03/quadtree-collision.gif" width="616" height="589" />
<p>Better. Mr. Quadtree catches the collision when it happens and both marbles bounce off. After the collision, they travel in the opposite direction of where they were going before.</p>
<p>But a collision should deflect marbles, not just bounce them. So I used a <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a> to calculate new vectors. Thanks to <a href="https://twitter.com/air_hadoken/status/837363064005623810">@air_hadoken</a> for showing me some of his old code. It helped a lot ^_^</p>
<img class="alignnone size-full wp-image-7490" src="https://swizec.com/blog/wp-content/uploads/2017/03/dotproduct-collision.gif" width="616" height="589" />
<p>Marvelous! Direction vectors get deflected, marbles bounce off each other, and something is still wrong. My collision correction algorithm doesn&#39;t account for mass.</p>
<p>Real marbles have mass. To make life easier, I decided all marbles should have the same mass. This means each marble involved in a collision gets half the combined speed involved in the impact.</p>
<img class="alignnone size-full wp-image-7492" src="https://swizec.com/blog/wp-content/uploads/2017/03/mass-collision.gif" width="699" height="647" />
<p>?… hmmm… I don&#39;t think marbles are that sticky.</p>
<p>I started tweaking parameters, changing coefficients, and tweaking multipliers. I came up with this:</p>
<blockquote class="twitter-tweet" data-width="550">
<p lang="en" dir="ltr">This is how physics works, right? <a href="https://t.co/rAjq8jx2Ys">pic.twitter.com/rAjq8jx2Ys</a></p>
<p>&mdash; Swizec (@Swizec) <a href="https://twitter.com/Swizec/status/841529688002449409">March 14, 2017</a></p></blockquote>
<p><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<p>Click play. A gif wouldn&#39;t do it justice.</p>
<p>Turns out, speed is definitely not additive. That looks more like a fission simulation at the atom level than a simulation of marbles hitting each other. ?</p>
<p>After some more tweaking, I think I got it:</p>
<img class="alignnone size-full wp-image-7494" src="https://swizec.com/blog/wp-content/uploads/2017/03/better-collisions.gif" width="958" height="773" />
<p><em>In general</em>, marbles bounce off each other, have their vectors deflected, slow down due to friction, and share mass in a collision. I don&#39;t know if it&#39;s a physically correct simulation, but it looks good enough to me.</p>
<p>Some marbles still stick.</p>
<h2>Why some marbles still stick together</h2>
<p>Marbles sticking together can happen due to one of three reasons:</p>
<ol>
<li>User overlaid marbles manually</li>
<li>A marble <em>actually</em> collides with multiple marbles within the same 16ms frame. Only one of the collisions is detected</li>
<li>A fast marble hits a small marble in such a way that their cumulative speed doesn&#39;t produce escape velocity</li>
</ol>
<p>The 1st case often goes away when you release the mouse. Sometimes it does not, depending on angle of approach.</p>
<p>The 2nd case is unsolvable when using quadtrees for collision detection.</p>
<p>The 3rd case can be solved by applying the collision step until all collisions are resolved. This <em>might</em> help with the 2nd case too ?</p>
<img class="alignnone size-full wp-image-7495" src="https://swizec.com/blog/wp-content/uploads/2017/03/iterative-application.gif" width="958" height="773" />
<p>Well… there&#39;s no stickiness… but no.</p>
<hr />
<h2>Here&#39;s how it works</h2>
<p>The marbles are rendered on <code>&lt;canvas&gt;</code> using a combination of React, react-konva, and Konva. Each is rendered declaratively from an array of <code>(x, y)</code> positions that change with each step of the simulation.</p>
<p>You can read about the rendering part in my <a href="https://swizec.com/blog/declarative-canvas-animation-react-konva/swizec/7443">Declarative canvas with React and Konva</a> article.</p>
<p>Since then, I have moved all logic into a MobX store called <code>Physics</code>. You can see the <a href="https://github.com/Swizec/declarative-canvas-react-konva">full code on Github</a>. The interesting bits for collision detection are in the <a href="https://github.com/Swizec/declarative-canvas-react-konva/tree/master/src/logic">src/logic</a> directory.</p>
<p>Our general approach goes like this:</p>
<ol>
<li>Have an observable array of marbles</li>
<li>Run a <code>simulationStep</code> on each <code>requesAnimationFrame</code> using <code>d3.timer</code></li>
<li>Change marble positions and speed</li>
<li>MobX observables and observers trigger re-renders of marbles that move</li>
</ol>
<p>The <a href="https://github.com/Swizec/declarative-canvas-react-konva/blob/master/src/logic/Physics.js"><code>Physics.js</code></a> file is 160 lines, so let me show you just the interesting part: <code>@action simulationStep</code>. It handles collision detection and the aftermath of each collision.</p>
<h2>simulationStep –&nbsp;where collisions collision</h2>
<pre lang="javascript">

@action simulationStep() {
    const { width, height, MarbleR } = this;

    const moveMarble = ({x, y, vx, vy, id}) => {
        let _vx = ((x+vx < MarbleR) ? -vx : (x+vx > width-MarbleR) ? -vx : vx)*.99,
            _vy = ((y+vy < MarbleR) ? -vy : (y+vy > height-MarbleR) ? -vy : vy)*.99;

        // nearest marble is a collision candidate
        const subdividedSpace = quadtree().extent([[-1, -1],
                                                   [this.width+1, this.height+1]])
                                          .x(d => d.x)
                                          .y(d => d.y)
                                          .addAll(this.marbles
                                                      .filter(m => id !== m.id)),
              candidate = subdividedSpace.find(x, y, MarbleR*2);

        if (candidate) {

            // borrowing @air_hadoken's implementation from here:
            // https://github.com/airhadoken/game_of_circles/blob/master/circles.js#L64
            const cx = candidate.x,
                  cy = candidate.y,
                  normx = cx - x,
                  normy = cy - y,
                  dist = (normx ** 2 + normy ** 2),
                  c = (_vx * normx + _vy * normy) / dist * 2.3;

            _vx = (_vx - c * normx)/2.3;
            _vy = (_vy - c * normy)/2.3;

            candidate.vx += -_vx;
            candidate.vy += -_vy;
            candidate.x += -_vx;
            candidate.y += -_vy;
        }

        return {
            x: x + _vx,
            y: y + _vy,
            vx: _vx,
            vy: _vy
        }
    };

    this.marbles.forEach((marble, i) => {
        const { x, y, vx, vy } = moveMarble(marble);

        this.marbles[i].x = x;
        this.marbles[i].y = y;
        this.marbles[i].vx = vx;
        this.marbles[i].vy = vy;
    });
}
</pre>
<p>That&#39;s a lot of code ?. Let&#39;s break it down.</p>
<p>You can think of it as a function and a loop. At the bottom, there is a <code>.forEach</code> that applies a <code>moveMarble</code> function to each marble.</p>
<pre lang="javascript">
    this.marbles.forEach((marble, i) => {
        const { x, y, vx, vy } = moveMarble(marble);

        this.marbles[i].x = x;
        this.marbles[i].y = y;
        this.marbles[i].vx = vx;
        this.marbles[i].vy = vy;
    });
</pre>
<p>We iterate over the list of marbles, feed them into <code>moveMarble</code>, get their new properties, and save them in the main marbles array. This might be unnecessary because of MobX. We <em>should</em> be able to change them inside the loop and rely on MobX observables to do the heavy lifting.</p>
<p>I wonder why I did it like this ? Maybe a leftover from before MobX?</p>
<h3>moveMarble</h3>
<p><code>moveMarble</code> is itself a hairy function. Things happen in 3 steps:</p>
<ol>
<li>Handle collisions with walls</li>
<li>Find collision with closest other marble</li>
<li>Handle collision with marble</li>
</ol>
<p><strong>Handling collisions with walls happens</strong> in two lines of code. One per coordinate.</p>
<pre lang="javascript">
let _vx = ((x+vx < MarbleR) ? -vx : (x+vx > width-MarbleR) ? -vx : vx)*.99,
    _vy = ((y+vy < MarbleR) ? -vy : (y+vy > height-MarbleR) ? -vy : vy)*.99;
</pre>
<p>Nested ternary expressions are kinda messy, but they’re good enough. If a marble is beyond any boundary, we reverse its direction. We <em>always</em> apply a <code>.99</code> friction coefficient so that marbles slow down.</p>
<p><strong>Finding collisions</strong> with the next closest marble happens via a quadtree. Since we don&#39;t have too many marbles, we can afford to build a new quadtree from scratch every time.</p>
<pre lang="javascript">
// nearest marble is a collision candidate
const subdividedSpace = quadtree().extent([[-1, -1],
                                           [this.width+1, this.height+1]])
                                  .x(d => d.x)
                                  .y(d => d.y)
                                  .addAll(this.marbles
                                              .filter(m => id !== m.id)),
      candidate = subdividedSpace.find(x, y, MarbleR*2);
</pre>
<p>We&#39;re using <a href="https://github.com/d3/d3-quadtree"><code>d3-quadtree</code></a> for the quadtree implementation. It takes an <code>extent</code>, which tells it how big our space is. It uses <code>x</code> and <code>y</code> accessors to get coordinates out of our marble objects, and we use <code>addAll</code> to fill it with marbles.</p>
<p>To avoid detecting each marble as colliding with itself, we take each marble out of our list before feeding the quadtree.</p>
<p>Once we have a quadtree built out, we use <code>.find</code> to look for the nearest marble within <code>MarbleR*2</code> of the current marble. Which is exactly the one we&#39;re colliding with! 🙂</p>
<p><strong>Handling collisions with marbles</strong> involves math. It’s the sort of thing you think you remember from high school and then suddenly realize you don&#39;t when the time comes to use it.</p>
<p>The code looks like this:</p>
<pre lang="javascript">
if (candidate) {

    // borrowing @air_hadoken's implementation from here:
    // https://github.com/airhadoken/game_of_circles/blob/master/circles.js#L64
    const cx = candidate.x,
          cy = candidate.y,
          normx = cx - x,
          normy = cy - y,
          dist = (normx ** 2 + normy ** 2),
          c = (_vx * normx + _vy * normy) / dist * 2.3;

    _vx = (_vx - c * normx)/2.3;
    _vy = (_vy - c * normy)/2.3;

    candidate.vx += -_vx;
    candidate.vy += -_vy;
    candidate.x += -_vx;
    candidate.y += -_vy;
}

return {
    x: x + _vx,
    y: y + _vy,
    vx: _vx,
    vy: _vy
}
</pre>
<p>Ok, the <code>return</code> statement isn&#39;t about handling collisions. It updates the current marble.</p>
<p>The rest kind of looks like magic. I implemented it and it looks like magic and I feel like I don&#39;t <em>really</em> understand it.</p>
<p>You can think of <code>[normx, normy]</code> as a vector that points from current marble to collision candidate. It gives us bounce direction. We use the <a href="https://en.wikipedia.org/wiki/Euclidean_distance">euclidean distance</a> formula to calculate the length of this vector. It measures the distance between the centers of both marbles.</p>
<p>Then we calculate the <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a> between our marble&#39;s speed vector and the collision direction vector. We normalize it by distance. Multiplying distance by <code>2</code> accounts for there being two marbles in the collision. That extra <code>.3</code> made the simulation look better.</p>
<p>I fiddled with it 🙂</p>
<p>Then we use the dot product scalar to adjust the marble&#39;s speed vector. Dividing by <code>2</code> takes into account that half the energy goes to the other marble. This is only true because we assume their masses are equal.</p>
<p>Finally, we update the <code>candidate</code> marble and make sure it bounces off as well. We do it additively because that&#39;s how it happens in real life.</p>
<p>Two marbles traveling towards each other in exactly opposite directions with exactly the same speed will stop dead and stay there. As soon as there&#39;s any misalignment, deflection happens. If one is stationary, it starts moving. If it&#39;s moving in the same direction, it speeds up… etc.</p>
<p>The end result is a decent-looking simulation of billiards.</p>
<a href="https://swizec.github.io/declarative-canvas-react-konva/"><img class="alignnone size-full wp-image-7493" src="https://swizec.com/blog/wp-content/uploads/2017/03/better-collisions-1.gif" width="958" height="773" /></a>
</div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-components-post-js","jsonName":"post-n-body-collision-simulation-react-d-3-mobx-029","path":"/post/n-body-collision-simulation-react-d3-mobx/"};window.dataPath="107/path---post-n-body-collision-simulation-react-d-3-mobx-029-d8e-KxdkSXWslEAuvuzLif5QST6ksgc";/*]]>*/</script><script src="/swizecblog/webpack-runtime-4f3a0bd1eef0c4ba11a9.js" async=""></script><script src="/swizecblog/app-49ff0b4ea28eff25fc3b.js" async=""></script><script src="/swizecblog/0-f215691c134019ee6fa5.js" async=""></script><script src="/swizecblog/component---src-components-post-js-dbedf083f25f7ad1f3b1.js" async=""></script></body></html>