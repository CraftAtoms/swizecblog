<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/swizecblog/component---src-components-post-js.345c7c4f16662f410581.css">@import url(https://fonts.googleapis.com/css?family=Lora);
html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;font-family:Lora,serif}body{background-color:#f6f6f6;margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{-webkit-text-decoration-skip:objects;background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:Lora,serif;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{box-sizing:border-box;font:112.5%/1.45em georgia,serif;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{-moz-font-feature-settings:"kern","liga","clig","calt";-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";color:rgba(0,0,0,.8);font-family:Lora,serif;font-feature-settings:"kern","liga","clig","calt";font-kerning:normal;font-weight:400;word-wrap:break-word}img{margin:0 0 1.45rem;max-width:100%;padding:0}h1{font-size:2.25rem}h1,h2{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{list-style-image:none;list-style-position:outside;margin:0 0 1.45rem 1.45rem;padding:0}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{background:rgba(0,0,0,.04);border-radius:3px;font-size:.85rem;line-height:1.42;margin:0 0 1.45rem;overflow:auto;padding:1.45rem;word-wrap:normal}table{border-collapse:collapse;font-size:1rem;line-height:1.45rem;width:100%}fieldset,table{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{background:rgba(0,0,0,.2);border:none;height:1px;margin:0 0 calc(1.45rem - 1px);padding:0}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-bottom:.725rem;margin-left:1.45rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:Lora,serif;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{content:" ";letter-spacing:-.2em}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}

/*# sourceMappingURL=component---src-components-post-js.345c7c4f16662f410581.css.map*/</style><style data-styled-components="cEsjyT hklXLQ gpHXOM cTUdjA">
/* sc-component-id: sc-bdVaJa */
.cEsjyT{margin:3rem auto;max-width:960px;padding:1.25rem 1rem;} .cEsjyT ul{margin:0 0 0px 0;list-style:none;float:right;}
/* sc-component-id: sc-bwzfXH */
.cTUdjA{-webkit-text-decoration:none;text-decoration:none;text-align:right;margin:0 .5rem 0 .5rem;padding:10px;color:#7c51a1;} .cTUdjA:hover{color:#fff;background-color:#7c51a1;}
/* sc-component-id: sc-htpNat */
.gpHXOM{-webkit-text-decoration:none;text-decoration:none;color:black;} .gpHXOM:hover{-webkit-text-decoration:underline;text-decoration:underline;color:#7c51a1;} .gpHXOM h3{display:inline;font-size:30px;}
/* sc-component-id: sc-bxivhb */
.hklXLQ{margin:0 3rem 4.5rem;}</style><title data-react-helmet="true">Swizec Blog</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><link as="script" rel="preload" href="/swizecblog/component---src-components-post-js-352e8466f0cbd742adc0.js"/><link as="script" rel="preload" href="/swizecblog/0-7538a10af02717828d76.js"/><link as="script" rel="preload" href="/swizecblog/app-e5d3c6935dd41a7392ed.js"/><link as="script" rel="preload" href="/swizecblog/webpack-runtime-bf7869bd5fe0e771eaf7.js"/><link rel="preload" href="/swizecblog/static/d/162/path---post-animated-string-diffing-with-react-and-d-3-4-a-8-1a9-RHC5t5uGFWrOlXG9wA8jnqR6aw.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div><div class="sc-bdVaJa cEsjyT"><div class="sc-bxivhb hklXLQ"><a class="sc-htpNat gpHXOM" href="/swizecblog/"><h3>Swizec Teller</h3></a><ul><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Business/">Business</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Personal/">Personal</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Technical/">Technical</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Thoughts/">Thoughts</a></ul></div><h1>Animated string diffing with React and D3</h1><div><figure><img src="http://i.imgur.com/sAr4q3L.gif" alt="" /></figure>
<p>I turned <a href="http://swizec.com/blog/using-d3js-transitions-in-react/swizec/6797">my animated alphabet example</a> into an animation of what you’re typing. New characters drop in from above, old characters drop down, and any white space gets squeezed out.</p>
<p>Pretty cool, huh? Try it out:</p>
<p><iframe src="https://swizec.github.io/react-d3-enter-exit-transitions/" width="600" height="600"></iframe></p>
<p>Maybe I’m a weirdo nerd, but I could play with that for days. Well, okay, minutes. At least 30 seconds!</p>
<p>What I like about this demo is that it’s a great example of declarative transitions built with React. Each letter handles its own animation, so all that the main component has to do is go through a list of characters in a loop and render a <code>Letter</code> component for each, like this:</p>
<pre lang="javascript">
    render() {
        let { x, y } = this.props,
            transition = d3.transition()
                           .duration(750)
                           .ease(d3.easeCubicInOut);

        return (
            <g transform={`translate(${x}, ${y})`}>
                <ReactTransitionGroup component="g">
                    {this.state.text.map((l, i) =>
                        <Letter letter={l} i={i} key={i} transition={transition} />
                     )}
                </ReactTransitionGroup>
            </g>
        );
    }
</pre>
<p>Declaring a root <code>transition</code> ensures individual letter transitions are synced. Rendering them in a <code>ReactTransitionGroup</code> gives us some additional lifecycle methods, and each letter needs its index so that it can calculate horizontal positioning because it lacks situational awareness.</p>
<p>Then, each <code>Letter</code> component takes care of its own enter/update/exit transitions inside special lifecycle hooks. <code>componentWillEnter</code> for the enter animation, <code>componentWillReceiveProps</code> for update, and <code>componentWillLeave</code> for exit. <a href="https://github.com/Swizec/react-d3-enter-exit-transitions/blob/master/src/components/Letter.jsx">The whole component</a> is just 59 standard lines of code.</p>
<p>You can read my previous 2000-word article to learn the details about <a href="http://swizec.com/blog/using-d3js-transitions-in-react/swizec/6797">using D3 transitions with React components</a>. I’ve cleaned up the code since then, but the gist hasn’t changed. You can see the current code in my <a href="https://github.com/Swizec/react-d3-enter-exit-transitions">github repository</a>.</p>
<p>The <em>key</em> mystery was choosing the right key prop for each <code>Letter</code> component. That part was hard. It took me two whole nights!</p>
<h2>Choosing the key prop</h2>
<p>The key prop is how React identifies your components. For the most part, you don’t have to worry about choosing correctly. Make it unique and you’re done. React can tell your components apart, which lets it do the fancy diffing stuff, and everything Just Works™.</p>
<p>Sometimes, though, the type of uniqueness matters.</p>
<p>For example: if you use the letter itself for the key prop, this example breaks down. It won’t even display input value correctly.</p>
<figure><img src="http://i.imgur.com/zkgtGiR.gif" alt="" /></figure>
<p>You only get one chance to show each character. Repeat it and React won’t care &#8211; it’s the same component as far as React is concerned. Empty spaces show up because we use character index from the original string to calculate horizontal positioning.</p>
<p>?</p>
<p>Okay then, what if we use the index? Each letter has its own, so that’s good, and it’s easy to set up, so that’s great.</p>
<figure><img src="http://i.imgur.com/gWKujjz.gif" alt="" /></figure>
<p>Waaaait a minute. That’s no good! Appending new characters to the end looks great, deleting characters from the end works too, but as soon as you mess around in the middle, all hell breaks loose.</p>
<p>React uses indexes to identify <code>Letter</code> instances, so only the last character animates. The fancy-pants diffing algorithm can do the diffing, but it doesn’t understand the context.</p>
<p>Ugh.</p>
<p>We have to help React out and implement our own string diffing algorithm. If you’ve ever gone to a computer science class or three, this should be a familiar problem. It’s a variation of the much researched <a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem">longest subsequence problem</a>.</p>
<h2>A simple string diffing algorithm</h2>
<p>The full longest common subsequence problem is a hairy beast with decades of research behind it. Efficient solutions are used in everything from version control systems to bioinformatics.</p>
<p>A few assumptions make it easier in our case:</p>
<ul>
<li>changes only happen at the caret</li>
<li>there is only 1 caret</li>
<li>there will only ever be 1 change</li>
</ul>
<p>A linear-complexity algorithm will do 🙂</p>
<figure><img src="http://i.imgur.com/iknWGlq.jpg" alt="" /></figure>
<p>Assuming there’s only one change at a time works even when you take copy/paste into account. Users can’t copy/paste disparate chunks of text at the same time. It has to be connected. So even if the change uses the same text, it acts as a big remove followed by an insert.</p>
<p>Our game plan is thus:</p>
<ul>
<li>assign a unique ID to each new character</li>
<li>maintain <code>(char, id)</code> pairs for the same portion</li>
<li>create or drop <code>(char, id)</code> pairs for the changed portion</li>
<li>shift <code>(char, id)</code> pairs to new indexes for the shifted portion</li>
</ul>
<p>The implementation took me 55 lines of code. You can see it in its entirety at the <a href="https://github.com/Swizec/react-d3-enter-exit-transitions/blob/master/src/components/FancyText.jsx">github repository</a>. There are 7 steps.</p>
<h3>Step 1 &#8211; prep the vars</h3>
<pre lang="javascript">
// FancyText.jsx -> componentWillReceiveProps()
  const oldText = this.state.textWithIds;
        const newText = newProps.text.split('');
        let indexOfChange = 0,
            sizeOfChange = 0,
            newLastId = this.state.lastId;
</pre>
<p><code>oldText</code> is the current array of <code>(char, id)</code> pairs, <code>newText</code> becomes an array of characters in the new string. We initiate <code>indexOfChange</code> and <code>sizeOfChange</code> to <code>0</code>. <code>this.state.lastId</code> is where we keep a running tally of new characters. Think of it as an auto increment ID.</p>
<h3>Step 2 &#8211; find the change</h3>
<pre lang="javascript">
// FancyText.jsx -> componentWillReceiveProps()
// find change
for (; newText[indexOfChange] == (oldText[indexOfChange] && oldText[indexOfChange][0]); indexOfChange++);
</pre>
<p>Looks like old school C code, doesn’t it? We keep incrementing <code>indexOfChange</code> until we find a character mismatch between the new and old text. Then we know where the insertion or deletion begins.</p>
<h3>Step 3 &#8211; calculating size of change</h3>
<pre lang="javascript">
// FancyText.jsx -> componentWillReceiveProps()

        // calculate size of change
        if (newText.length > oldText.length) {
            while (newText[indexOfChange+sizeOfChange] != (oldText[indexOfChange] && oldText[indexOfChange][0])
                    && indexOfChange+sizeOfChange < newText.length) {
                        sizeOfChange = sizeOfChange+1;
            }
        }else{
            while (newText[indexOfChange] != (oldText[indexOfChange+sizeOfChange] &#038;&#038; oldText[indexOfChange+sizeOfChange][0])
                    &#038;&#038; indexOfChange+sizeOfChange < oldText.length) {
                        sizeOfChange = sizeOfChange+1;
            }
        }
</pre>
<p>Here we have two different branches - one for insertion and one for deletion. They both use the same principle and have small differences based on which characters to compare.</p>
<p>We keep increasing <code>sizeOfChange</code> until <code>indexOfChange+sizeOfChange</code> either finds a character that matches in both strings, or until it runs out of characters to check. The difference between insertion and deletion is that we’re shifting the lookup index of either <code>newText</code> or <code>oldText</code>.</p>
<h3>Step 4 - copying same section</h3>
<pre lang="javascript">
// FancyText.jsx -> componentWillReceiveProps()

// use existing ids up to point of change
d3.range(0, indexOfChange).forEach((i) => newText[i] = oldText[i]);
</pre>
<p><code>d3.range</code> creates an array of indexes from <code>0</code> to <code>indexOfChange</code>. We loop through it and overwrite <code>newText</code> with existing <code>(char, id)</code> pairs from <code>oldText</code>.</p>
<h3>Step 5 - add new (char, id) pairs</h3>
<pre lang="javascript">
// FancyText.jsx -> componentWillReceiveProps()

      // use new ids for additions
        if (newText.length > oldText.length) {
            d3.range(indexOfChange, indexOfChange+sizeOfChange).forEach((i) => {
                let letter = newText[i];
                newText[i] = [letter, newLastId++];
            });
</pre>
<p>If the change is an insertion, we go from <code>indexOfChange</code> to <code>indexOfChange+sizeOfChange</code>, create new <code>(char, id)</code> pairs, and override <code>newText</code> at each index. To create each ID, we take <code>newLastId</code> and increment it.</p>
<p>Just like an auto increment index. It’s a running count of new characters that never decrements.</p>
<h3>Step 6 - shift remaining (char, id) pairs</h3>
<pre lang="javascript">
// FancyText.jsx -> componentWillReceiveProps()

        if (newText.length > oldText.length) {
            // insertion …

            // use existing ids from change to end
            d3.range(indexOfChange+sizeOfChange, newText.length).forEach((i) =>
                newText[i] = oldText[i-sizeOfChange]);
        }else{
            // use existing ids from change to end, but skip what's gone
            d3.range(indexOfChange, newText.length).forEach((i) =>
                newText[i] = oldText[i+sizeOfChange]);
        }
</pre>
<p>Here we again have two branches: one for insertion, one for deletion. Both copy <code>(char, id)</code> pairs from <code>oldText</code> to <code>newText</code>, but the shift happens in different directions.</p>
<p>When inserting, we have to shift the index by <code>sizeOfChange</code> to the right. When deleting, we shift the index to the left.</p>
<pre lang="javascript">
// FancyText.jsx -> componentWillReceiveProps()

        this.setState({text: newProps.text,
                       textWithIds: newText,
                       lastId: newLastId});
</pre>
<p>We have an updated list of <code>(char, id)</code> pairs in <code>newText</code>. It reflects the updated text value while keeping all ID assignments stable throughout the process. Pretty neat.</p>
<p>We use <code>this.setState</code> so that when React calls <code>render()</code> on our <code>FancyText</code> component, it will use the updated state. <code>componentWillReceiveProps</code> is the only lifecycle method where calling <code>setState</code> does not trigger a re-render.</p>
<p>Neat, huh?</p>
<h3>Step 7.5 - use the (char, id) pairs</h3>
<p>There’s one more thing. We have to update how rendering happens. Invoking the <code>Letter</code> component looks like this now:</p>
<pre lang="javascript">
// FancyText.jsx -> render()

 return (
            <g transform={`translate(${x}, ${y})`}>
                <ReactTransitionGroup component="g">
                    {this.state.textWithIds.map(([l, id], i) =>
                        <Letter letter={l} i={i} key={id} transition={transition} />
                     )}
                </ReactTransitionGroup>
            </g>
        );
</pre>
<p>Instead of iterating over <code>this.props.text</code>, we iterate over <code>this.state.textWithIds</code>. For each iteration, we take the <code>(char, id)</code> pair, destructure it, and use the <code>id</code> for our key prop.</p>
<p>And that’s it, our animated typing example looks like this:</p>
<figure><img src="http://i.imgur.com/11aZVdH.gif" alt="" /></figure>
<p>Wasn’t that fun?</p>
</div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-components-post-js","jsonName":"post-animated-string-diffing-with-react-and-d-3-4a8","path":"/post/animated-string-diffing-with-react-and-d3/"};window.dataPath="162/path---post-animated-string-diffing-with-react-and-d-3-4-a-8-1a9-RHC5t5uGFWrOlXG9wA8jnqR6aw";/*]]>*/</script><script src="/swizecblog/webpack-runtime-bf7869bd5fe0e771eaf7.js" async=""></script><script src="/swizecblog/app-e5d3c6935dd41a7392ed.js" async=""></script><script src="/swizecblog/0-7538a10af02717828d76.js" async=""></script><script src="/swizecblog/component---src-components-post-js-352e8466f0cbd742adc0.js" async=""></script></body></html>