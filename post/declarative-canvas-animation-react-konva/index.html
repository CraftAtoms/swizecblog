<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/swizecblog/component---src-components-post-js.345c7c4f16662f410581.css">@import url(https://fonts.googleapis.com/css?family=Lora);
html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;font-family:Lora,serif}body{background-color:#f6f6f6;margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{-webkit-text-decoration-skip:objects;background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:Lora,serif;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{box-sizing:border-box;font:112.5%/1.45em georgia,serif;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{-moz-font-feature-settings:"kern","liga","clig","calt";-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";color:rgba(0,0,0,.8);font-family:Lora,serif;font-feature-settings:"kern","liga","clig","calt";font-kerning:normal;font-weight:400;word-wrap:break-word}img{margin:0 0 1.45rem;max-width:100%;padding:0}h1{font-size:2.25rem}h1,h2{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{list-style-image:none;list-style-position:outside;margin:0 0 1.45rem 1.45rem;padding:0}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{background:rgba(0,0,0,.04);border-radius:3px;font-size:.85rem;line-height:1.42;margin:0 0 1.45rem;overflow:auto;padding:1.45rem;word-wrap:normal}table{border-collapse:collapse;font-size:1rem;line-height:1.45rem;width:100%}fieldset,table{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{background:rgba(0,0,0,.2);border:none;height:1px;margin:0 0 calc(1.45rem - 1px);padding:0}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-bottom:.725rem;margin-left:1.45rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:Lora,serif;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{content:" ";letter-spacing:-.2em}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}

/*# sourceMappingURL=component---src-components-post-js.345c7c4f16662f410581.css.map*/</style><style data-styled-components="cEsjyT hklXLQ gpHXOM cTUdjA">
/* sc-component-id: sc-bdVaJa */
.cEsjyT{margin:3rem auto;max-width:960px;padding:1.25rem 1rem;} .cEsjyT ul{margin:0 0 0px 0;list-style:none;float:right;}
/* sc-component-id: sc-bwzfXH */
.cTUdjA{-webkit-text-decoration:none;text-decoration:none;text-align:right;margin:0 .5rem 0 .5rem;padding:10px;color:#7c51a1;} .cTUdjA:hover{color:#fff;background-color:#7c51a1;}
/* sc-component-id: sc-htpNat */
.gpHXOM{-webkit-text-decoration:none;text-decoration:none;color:black;} .gpHXOM:hover{-webkit-text-decoration:underline;text-decoration:underline;color:#7c51a1;} .gpHXOM h3{display:inline;font-size:30px;}
/* sc-component-id: sc-bxivhb */
.hklXLQ{margin:0 3rem 4.5rem;}</style><title data-react-helmet="true">Swizec Blog</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><link as="script" rel="preload" href="/swizecblog/component---src-components-post-js-dbedf083f25f7ad1f3b1.js"/><link as="script" rel="preload" href="/swizecblog/0-f215691c134019ee6fa5.js"/><link as="script" rel="preload" href="/swizecblog/app-49ff0b4ea28eff25fc3b.js"/><link as="script" rel="preload" href="/swizecblog/webpack-runtime-4f3a0bd1eef0c4ba11a9.js"/><link rel="preload" href="/swizecblog/static/d/549/path---post-declarative-canvas-animation-react-konva-9-d-0-e13-6LriGHLgsrNyKyPCWNVFUDpOMwU.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div><div class="sc-bdVaJa cEsjyT"><div class="sc-bxivhb hklXLQ"><a class="sc-htpNat gpHXOM" href="/swizecblog/"><h3>Swizec Teller</h3></a><ul><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Business/">Business</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Personal/">Personal</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Technical/">Technical</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Thoughts/">Thoughts</a></ul></div><h1>Declarative `canvas` Animation with React and Konva</h1><div><div style="position:relative;height:0;padding-bottom:56.25%"><iframe src="https://www.youtube.com/embed/oli1qacE-wo?ecver=2" width="640" height="360" frameborder="0" style="position:absolute;width:100%;height:100%;left:0" allowfullscreen></iframe></div>
<p>Today we&#39;re looking at declarative animation that renders on <code>&lt;canvas&gt;</code>:  React for declarativeness, <a href="https://konvajs.github.io/">Konva</a> as a canvas abstraction layer, and <a href="https://github.com/lavrton/react-konva">react-konva</a> to make them work together.</p>
<p>In theory, this combination has better performance than SVG+React but worse performance than raw canvas because of the additional abstraction layers. We have canvas as the rendering layer, then Konva gives us basic shapes and interactions, <code>react-konva</code> turns those into React components, and our own React code makes it work together.</p>
<p>If that sounds complicatedâ€¦ it probably is. I barely know how to use it, and I have no idea how it <em>actually</em> works.</p>
<img class="alignnone size-full wp-image-7442" src="https://swizec.com/blog/wp-content/uploads/2017/02/bouncing-marbles-1.gif" width="1030" height="710" />
<p>We&#39;re building a marble simulation. You can pick up a marble and throw it, and it bounces around until it stops. I wanted to add collision detection as well, but <a href="https://en.wikipedia.org/wiki/N-body_problem">N-body collisions are hard</a>. Next time!</p>
<p>You can see the <a href="https://github.com/Swizec/declarative-canvas-react-konva">code on Github</a> and play with marbles on the <a href="https://swizec.github.io/declarative-canvas-react-konva/">live demo</a>. The live demo looks better than the gif, I promise.</p>
<p>We have two components:</p>
<ul>
<li><code>Marble</code>, which renders each marble and deals with drag events</li>
<li><code>Collisions</code>, which renders all the marbles and deals with the game loop logic</li>
</ul>
<p>Yes, the game loop logic should totally be a Redux or MobX store instead of shoved into a component. This is fine. Small example ?</p>
<h2>Marble</h2>
<p>The <code>Marble</code> component uses <code>react-konva</code> to render a <code>&lt;Circle&gt;</code> and listen for a <code>dragend</code> event. That&#39;s how you &quot;throw&quot;.</p>
<p>You can think of react-konva as a very thin abstraction layer on Konva. I looked at the source code once, and it just uses a bit of magic to translate all of <a href="https://konvajs.github.io/api/Konva.html">Konva&#39;s classes</a> into React components. Props are passed through unchanged as Konva attributes.</p>
<p>That means you don&#39;t have to think about using react-konva. Focus on the Konva docs, it&#39;s all the same.</p>
<pre lang="javascript">
class Marble extends Component {
    onDragEnd() {
        const { x, y } = this.props,
              circle = this.refs.circle;

        this.props.onShoot({
            x: circle.attrs.x,
            y: circle.attrs.y,
            vx: (circle.attrs.x-x)/7,
            vy: (circle.attrs.y-y)/7
        });
    }

    render() {
        const { x, y, sprite, type, draggable } = this.props;

        return (
            <Circle x={x} y={y} radius={MarbleR}
                    fillPatternImage={sprite}
                    fillPatternOffset={Marbles[type]}
                    fillPatternScale={{ x: MarbleR*2/111, y: MarbleR*2/111 }}
                    shadowColor={Marbles[type].c}
                    shadowBlur="15"
                    shadowOpacity="1"
                    draggable={draggable}
                    onDragEnd={this.onDragEnd.bind(this)}
                    ref="circle"
                    />
        );
    }
}
</pre>
<p>We&#39;re rendering a <code>&lt;Circle&gt;</code> element at position <code>(x, y)</code> and giving it a radius of <code>15</code>. Very similar to SVG, right?</p>
<p>Here&#39;s where it gets crazy. To get the marble look, we use <code>fillPattern*</code> props and use a <code>sprite</code> for the background. We reposition and scale it to get the sprite to fit and make marbles look different.</p>
<img class="alignnone size-full wp-image-7441" src="https://swizec.com/blog/wp-content/uploads/2017/02/sprite.png" width="800" height="600" srcset="https://swizec.com/blog/wp-content/uploads/2017/02/sprite.png 800w, https://swizec.com/blog/wp-content/uploads/2017/02/sprite-300x225.png 300w, https://swizec.com/blog/wp-content/uploads/2017/02/sprite-768x576.png 768w" sizes="(max-width: 800px) 100vw, 800px" />
<p>For the shine effect, we use <code>shadow*</code> props. Shadows get a color that matches each marble (I used Photoshop), some blur, and an opacity. This gives each marble a glow that makes the marbles look shiny.</p>
<p>They&#39;re still shadows though, so a bunch of things are wrong. Especially when the marbles get close together, you can see that the shadows look darker when combined. Real shines would look brighter.</p>
<p>To get draggability, we turn it on. Konva handles the rest for us. <code>onDragEnd</code> we call the <code>onShoot</code> callback with the marble&#39;s new position and movement vector. This part is janky. I&#39;ll explain why later.</p>
<h2>Collisions</h2>
<p>The <code>&lt;Collisions&gt;</code> component is called collisions because this was meant to be a simulation of <a href="https://en.wikipedia.org/wiki/Inelastic_collision">inelastic N-body collisions</a>. High school physics stuff.</p>
<p>But that&#39;s hard to do, so you get just the bouncing off of walls.</p>
<p>This component has three major parts:</p>
<ul>
<li>calculating the initial positions to make a triangle</li>
<li>the game loop that drives animation</li>
<li>declaratively rendering the marbles</li>
</ul>
<pre lang="javascript">
class Collisions extends Component {
    constructor(props) {
        // setting up this.state
    }

    get initialPositions() {
        // calculating initial positions
    }

    componentDidMount() {
        // loading sprite
    }

    shoot(newPos, i) {
        // updating a thrown marble
    }

    gameLoop() {
        // moving
    }

    render() {
            // rendering
    }
</pre>
<h3>Initial positions and sprite loading</h3>
<pre lang="javascript">
    componentDidMount() {
        const sprite = new Image();
        sprite.src = MarbleSprite;

        sprite.onload = () => {
            this.setState({
                sprite: sprite
            });

            this.timer = timer(() => this.gameLoop());
        };
    }
</pre>
<p>Konva takes sprites as ES6 <code>Image</code> objects. We load one up, wait for the <code>onload</code> event to fire, add it to state, which triggers a re-render, and start the game loop timer.</p>
<p>If you&#39;re not familiar with the <code>Image</code> object, it&#39;s basically an in-memory representation of the image bytestream. Unless you&#39;re doing something very particular, you don&#39;t need to know the details. It loads an image into memory ðŸ™‚</p>
<pre lang="javascript">
    get initialPositions() {
        const { width, height } = this.props,
              center = width/2;

        let marbles = range(3, 0, -1).map(y => {
            if (y === 3) return [{ x: center, y: 200,
                                   vx: 0, vy: 0}];

            const left = center - y*(MarbleR+5),
                  right = center + y*(MarbleR+5);

            return range(left, right, MarbleR*2+5).map(x => ({
                x: x,
                y: 200-y*(MarbleR*2+5),
                vx: 0,
                vy: 0
            }));
        }).reduce((acc, pos) => acc.concat(pos), []);

        marbles = marbles.concat({
            x: width/2,
            y: height-150,
            vx: 0,
            vy: 0
        });

        return marbles;
    }
</pre>
<p>Thisâ€¦ this took me embarrassingly long to code. It&#39;s one of those interview question things: Render stuff in a triangle. Then you fumble for an hour, and they&#39;re like <em>&quot;LoL you&#39;re an idiot, pass&quot;</em>.</p>
<p>That was going through my mind the entire time. How the hell am I struggling <em>this</em> hard to put marbles in a triangle?</p>
<p>Here&#39;s how it works:</p>
<ul>
<li>loop from 3 to 0 to create the rows</li>
<li>in each row. go from the <code>left</code> edge to the <code>right</code> edge with a step of &quot;marble size&quot;</li>
<li>add position to array</li>
</ul>
<p>You get the left edge is <code>y</code> marble halves to the left, and the right is <code>y</code> marble halves to the right. This nested loop approach returns a nested array so you flatten it with a <code>.reduce</code>.</p>
<p>Oh, and those <code>range()</code> functions are actually <code>d3.range</code>. I got them with <code>import { range } from &#39;d3-array&#39;</code>.</p>
<h3>Game loop</h3>
<p>Our game loop is a function that <code>d3.timer</code> calls on every <code>requestAnimationFrame</code>. It goes through our array of marbles, updates their positions, and triggers a re-render.</p>
<p>Like this:</p>
<pre lang="javascript">
    shoot(newPos, i) {
        let marbles = this.state.marbles;

        marbles[i] = newPos;

        this.setState({
            marbles: marbles
        });
    }

    gameLoop() {
        const { width, height } = this.props;

        const moveMarble = ({x, y, vx, vy}) => ({
            x: x+vx,
            y: y+vy,
            vx: ((x+vx < MarbleR) ? -vx : (x+vx > width-MarbleR) ? -vx : vx)*.99,
            vy: ((y+vy < MarbleR) ? -vy : (y+vy > height-MarbleR) ? -vy : vy)*.99
        });

        this.setState({
            marbles: this.state.marbles.map(moveMarble)
        });
    }
</pre>
<p>See? Loop through marbles and update their positions by adding the speed vector to the position. We invert the speed vector when a marble is about to hit a wall in the next step.</p>
<p>Nested ternary expressions are hard to read. I should refactor that. If <code>x+vx</code> is smaller than left edge, invert <code>vx</code>. Otherwise if <code>x+vx</code> is bigger than right edge, invert <code>vx</code>. Otherwise, leave it alone.</p>
<p>The <code>shoot()</code> function is that dragend callback that <code>&lt;Marble&gt;</code> calls. It updates the particular marble with the new position and the new speed vector.</p>
<h3>Rendering</h3>
<p>After all that logic, rendering is the easy part. We loop through the marbles and declaratively add them to the <code>Stage</code>. Stage is what Konva calls the canvas element. I don&#39;t fully understand why, but I&#39;m sure there&#39;s a reason.</p>
<pre lang="javascript">
    render() {
        const { sprite } = this.state,
              { width, height } = this.props,
              marbleTypes = Object.keys(Marbles);

        if (!sprite) {
            return (<h2>Loading sprites ...</h2>);
        }

        return (
            <Stage width={width} height={height}>
                <Layer>
                    <Group>
                        {this.state.marbles.map(({x: x, y: y}, i) => (
                            <Marble x={x}
                                    y={y}
                                    type={marbleTypes[i%marbleTypes.length]}
                                    sprite={sprite}
                                    draggable="true"
                                    onShoot={(newPos) => this.shoot(newPos, i)}
                                    key={`marble-${i}`} />
                        ))}
                    </Group>
                </Layer>
            </Stage>
        )
    }
</pre>
<p>See? Loop through <code>marbles</code>, put down <code>Marble</code> components. All this inside a <code>Stage</code>, which is the canvas, and <code>Layer</code>, which I think makes more sense when you have more than one, and <code>Group</code> which is the same concept as SVG&#39;s <code>&lt;g&gt;</code> element. It helps you think of groups of shapes as a single thing.</p>
<p>A Stage must always have at least one Layer. So that part is important albeit seemingly useless.</p>
<h2>Why is your demo so janky, Swizec?</h2>
<p>Did you guess it yet? Why am I having so much trouble throwing marbles at <a href="https://youtu.be/oli1qacE-wo?t=14">0:14 in the video</a>?</p>
<p>It&#39;s the game loop and Konva fighting each other. The game loop re-renders all our marbles every 16 milliseconds. Konva isn&#39;t telling React that they&#39;ve moved, so the position is reset.</p>
<p>That means you <em>have to</em> complete your throw within 16ms or it won&#39;t work.</p>
<p>Now, while this looks really bad, it&#39;s not a fundamental limitation of the React-Konva-Canvas stack. Just an extra step to take care of before I tackle the N-body collisions.</p>
<p>Gotta add a <code>dragmove</code> listener to <code>Marble</code> and make sure it updates React state. Should be easy ?</p>
</div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-components-post-js","jsonName":"post-declarative-canvas-animation-react-konva-9d0","path":"/post/declarative-canvas-animation-react-konva/"};window.dataPath="549/path---post-declarative-canvas-animation-react-konva-9-d-0-e13-6LriGHLgsrNyKyPCWNVFUDpOMwU";/*]]>*/</script><script src="/swizecblog/webpack-runtime-4f3a0bd1eef0c4ba11a9.js" async=""></script><script src="/swizecblog/app-49ff0b4ea28eff25fc3b.js" async=""></script><script src="/swizecblog/0-f215691c134019ee6fa5.js" async=""></script><script src="/swizecblog/component---src-components-post-js-dbedf083f25f7ad1f3b1.js" async=""></script></body></html>