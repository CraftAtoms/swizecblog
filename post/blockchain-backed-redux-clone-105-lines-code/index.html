<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/swizecwp/component---src-components-post-js.15d6bfea4d3b992d9691.css">@import url(https://fonts.googleapis.com/css?family=Lora);
html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;font-family:Lora,serif}body{background-color:#f6f6f6;margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{-webkit-text-decoration-skip:objects;background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:Lora,serif;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{box-sizing:border-box;font:112.5%/1.45em georgia,serif;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{-moz-font-feature-settings:"kern","liga","clig","calt";-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";color:rgba(0,0,0,.8);font-family:Lora,serif;font-feature-settings:"kern","liga","clig","calt";-webkit-font-kerning:normal;font-kerning:normal;font-weight:400;word-wrap:break-word}img{margin:0 0 1.45rem;max-width:100%;padding:0}h1{font-size:2.25rem}h1,h2{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{list-style-image:none;list-style-position:outside;margin:0 0 1.45rem 1.45rem;padding:0}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{background:rgba(0,0,0,.04);border-radius:3px;font-size:.85rem;line-height:1.42;margin:0 0 1.45rem;overflow:auto;padding:1.45rem;word-wrap:normal}table{border-collapse:collapse;font-size:1rem;line-height:1.45rem;width:100%}fieldset,table{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{background:rgba(0,0,0,.2);border:none;height:1px;margin:0 0 calc(1.45rem - 1px);padding:0}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-bottom:.725rem;margin-left:1.45rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:Lora,serif;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{content:" ";letter-spacing:-.2em}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}

/*# sourceMappingURL=component---src-components-post-js.15d6bfea4d3b992d9691.css.map*/</style><style data-styled-components="cEsjyT hklXLQ gpHXOM cTUdjA">
/* sc-component-id: sc-bdVaJa */
.cEsjyT{margin:3rem auto;max-width:960px;padding:1.25rem 1rem;} .cEsjyT ul{margin:0 0 0px 0;list-style:none;float:right;}
/* sc-component-id: sc-bwzfXH */
.cTUdjA{-webkit-text-decoration:none;text-decoration:none;text-align:right;margin:0 .5rem 0 .5rem;padding:10px;color:#7c51a1;} .cTUdjA:hover{color:#fff;background-color:#7c51a1;}
/* sc-component-id: sc-htpNat */
.gpHXOM{-webkit-text-decoration:none;text-decoration:none;color:black;} .gpHXOM:hover{-webkit-text-decoration:underline;text-decoration:underline;color:#7c51a1;} .gpHXOM h3{display:inline;font-size:30px;}
/* sc-component-id: sc-bxivhb */
.hklXLQ{margin:0 3rem 4.5rem;}</style><title data-react-helmet="true">Swizec Blog</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><link as="script" rel="preload" href="/swizecwp/component---src-components-post-js-428e04eacc0b402938d5.js"/><link as="script" rel="preload" href="/swizecwp/0-ce760dfe358fb4e73f84.js"/><link as="script" rel="preload" href="/swizecwp/app-affbd460d24d53f1fc4a.js"/><link as="script" rel="preload" href="/swizecwp/webpack-runtime-756ce6cc3c39f3c623f9.js"/><link rel="preload" href="/swizecwp/static/d/353/path---post-blockchain-backed-redux-clone-105-lines-code-ffd-d4b-Aryh87ujDUc9A1Zuamnf3E9M.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div><div class="sc-bdVaJa cEsjyT"><div class="sc-bxivhb hklXLQ"><a class="sc-htpNat gpHXOM" href="/swizecwp/"><h3>Swizec Teller</h3></a><ul><a class="sc-bwzfXH cTUdjA" href="/swizecwp/Business/">Business</a><a class="sc-bwzfXH cTUdjA" href="/swizecwp/Personal/">Personal</a><a class="sc-bwzfXH cTUdjA" href="/swizecwp/Technical/">Technical</a><a class="sc-bwzfXH cTUdjA" href="/swizecwp/Thoughts/">Thoughts</a></ul></div><h1>A blockchain-backed Redux clone in 105 lines of code</h1><div><p><iframe width="580" height="326" src="https://www.youtube.com/embed/kVLrT92US4U?feature=oembed" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></p>
<p><em><strong>Big fat disclaimer: This is Part 1 of an experiment. It is not yet secure, it does not yet share the blockchain between nodes, it still needs a proof-of-work or proof-of-stake algorithm.</strong></em></p>
<p>With that out of the way, let us begin.</p>
<blockquote class="twitter-tweet" data-width="550">
<p lang="en" dir="ltr">Redux is great because it does immutability right?</p>
<p>Now imagjne this: Blockchain backed Redux. Every state change gets recorded to the blockchain. Immutable forever. Pure as dew ðŸ‘Œ</p>
<p>&mdash; Swizec (@Swizec) <a href="https://twitter.com/Swizec/status/938983218975449088?ref_src=twsrc%5Etfw">December 8, 2017</a></p></blockquote>
<p><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
<p>Redux is great because it keeps a chain of immutable data forever. What if we backed that chain with a blockchain? What would happen? ðŸ¤”</p>
<div id="attachment_7979" style="width: 1414px" class="wp-caption alignnone"><img class="alignnone size-full wp-image-7979" src="https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain.png" alt="Blockchain in a nutshell" width="1404" height="1124" srcset="https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain.png 1404w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain-300x240.png 300w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain-768x615.png 768w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-blockchain-1024x820.png 1024w" sizes="(max-width: 1404px) 100vw, 1404px" /><p class="wp-caption-text">Blockchain in a nutshell</p></div>
<p>So I fired up <a href="https://medium.com/@lhartikk/a-blockchain-in-200-lines-of-code-963cc1cc0e54">this amazing Medium post</a> on building a blockchain in 200 lines of code and built a blockchain-backed Redux clone in about 2 hours.</p>
<p>Mine is just 105 lines tho ðŸ˜›</p>
<p>You can see the <a href="https://github.com/Swizec/blockchain-redux">code on Github</a>. It&#8217;s not quite useful yet. The blockchain doesn&#8217;t get shared between nodes, and there&#8217;s no proof-of-stake or proof-of-work algorithm.</p>
<p>That&#8217;s all coming soon. First, I wanted to make sure I understood both <a href="https://en.wikipedia.org/wiki/Blockchain">blockchains</a> and Redux enough to make this work.</p>
<h2>Blockchain</h2>
<p>Turns out blockchains are pretty simple. It&#8217;s just a reversed linked list where every node holds some data, a hash, and points to the previous node.</p>
<img src="https://cdn-images-1.medium.com/max/1600/1*pbyFH4U5sO27UE1EjnImoA.png" alt="Image borrowed from Lauri Hartikka's post" />
<p>We use the hashes to verify our chain. Verification is important when we start sharing chains between nodes.</p>
<p>Our blocks are JavaScript objects.</p>
<pre lang="javascript">
class Block {
    constructor({ previousBlock, data }) {
        this.index = previousBlock.index + 1;
        this.previousHash = previousBlock.hash.toString();
        this.timestamp = new Date().getTime() / 1000;
        this.data = data;

        this.hash = Block.calculateHash(this);
    }

    set data(data) {
        this._data = JSON.stringify(data);
    }

    get data() {
        return JSON.parse(this._data);
    }

    // this is where a Proof-of-Work or Proof-of-Stake algo comes in, I think
    static calculateHash(block) {
        return CryptoJS.SHA256(
            block.index + block.previousHash + block.timestamp + block._data
        ).toString();
    }
}
</pre>
<p>The <code>constructor</code> doubles as our block generator. It takes the <code>previousBlock</code> and some <code>data</code>, adds some metadata, and calculates a <code>hash</code>.</p>
<p>A <code>data</code> setter and getter help us JSONify data transparently. Users can pass simple objects as data, and the blockchain will handle it.</p>
<p>The <code>calculateHash</code> function right now just uses SHA256, but I think this is where a <a href="https://en.wikipedia.org/wiki/Proof-of-work_system">proof of work</a> or a <a href="https://en.wikipedia.org/wiki/Proof-of-stake">proof of stake</a> algorithm would come into play in a real blockchain. Haven&#8217;t figured that part out yet ðŸ™‚</p>
<p>Kind of surprisingly, that&#8217;s all we need to build a blockchain. You could build it like this <code>new Block({ previousBlock: new Block({ previousBlock: genesisBlock, data: {hai: "world"}}), data: {hai2: "world2"}})</code></p>
<p>But that&#8217;s cumbersome, so let&#8217;s add a Redux.</p>
<h2>Redux</h2>
<p>Redux, if you don&#8217;t know, is a state management approach based on the functional concept of a <code>reducer</code>. At each change, we take the current state and a change descriptor, and produce the next state.</p>
<p>A tiny Redux implementation that maintains history would look something like this ðŸ‘‡</p>
<pre lang="javascript">
function createStore(initialState, reducer) {
    let state = [initialState];
 
    function getState() {
        return state[state.length-1];
    }
 
    function dispatch(action) {
        state.push(reducer(getState(), action));
    }
 
    return {
        getState: getState,
        dispatch: dispatch
    }
}
</pre>
<p>ðŸ‘† That&#8217;s Redux in a nutshell. Unlike the real Redux, this one maintains history. We&#8217;ll expand that into a blockchain.</p>
<p><code>getState</code> returns the latest state and <code>dispatch</code> takes an <code>action</code> and calculates the new state using the <code>reducer</code> function.</p>
<p>Using this Redux to implement a counter looks like this ðŸ‘‡</p>
<pre lang="javascript">
const store = createStore({ counter: 0 }, rootReducer);

function rootReducer(state, action) {
    switch (action.type) {
        case "inc":
            return { counter: state.counter + 1 };
        case "dec":
            return { counter: state.counter - 1 };
        default:
            return state;
    }
}
</pre>
<p>We can use this to verify that it works. Using tape in this case because <a href="https://twitter.com/lukeed05">LukeEd05</a> on the livestream suggested it.</p>
<pre lang="javascript">
test("count to 5", t => {
    for (let i = 0; i < 5; i++) {
        store.dispatch({ type: "inc" });
    }

    t.equal(store.getState().counter, 5);
    t.end();
});
</pre>
<p>Works ðŸ‘Œ</p>
<h2>blockchain-redux</h2>
<p>Now, how do we add the blockchain? ðŸ¤”</p>
<p>Well, instead of putting <code>initialState</code> directly into our state, we put a genesis Block with that state. And instead of pushing new state calculations directly, we add blocks.</p>
<pre lang="javascript">
function createStore(initialState, reducer) {
    let blockchain = [
        new Block({ 
            previousBlock: {
                index: 0,
                hash: "0",
                timestamp: new Date().getTime()
            },
            data: initialState
        })
    ];

    function getLastBlock() {
        return blockchain[blockchain.length - 1];
    }

    function dispatch(action) {
        const lastBlock = getLastBlock();
        const nextData = reducer(lastBlock.data, action);

        addBlock(new Block({ previousBlock: lastBlock, data: nextData }));
    }

    function addBlock(newBlock) {
        if (isValidNewBlock(newBlock, getLastBlock())) {
            blockchain.push(newBlock);
        }
    }

    function isValidNewBlock(newBlock, previousBlock) {
        if (previousBlock.index + 1 !== newBlock.index) {
            console.log("invalid index");
            return false;
        } else if (previousBlock.hash !== newBlock.previousHash) {
            console.log("invalid previoushash");
            return false;
        } else if (Block.calculateHash(newBlock) !== newBlock.hash) {
            console.log(
                "invalid hash: ",
                Block.calculateHash(newBlock),
                newBlock.hash
            );
            return false;
        }
        return true;
    }

    function isValidChain(blockchain) {
        for (let i = 0; i < blockchain.length - 1; i++) {
            if (!isValidNewBlock(blockchain[i + 1], blockchain[i])) {
                return false;
            }
        }
        return true;
    }

    function replaceChain(newBlocks) {
        if (isValidChain(newBlocks) &#038;&#038; newBlocks.length > blockchain.length) {
            blockchain = newBlocks;
            // tell others here
        }
    }

    return {
        getState: () => getLastBlock().data,
        getLastBlock: getLastBlock,
        dispatch: dispatch,
        addBlock: addBlock,
        replaceChain: replaceChain, // primarily used when starting up to take latest available blockchain
        _blockchain: blockchain
    };
}
</pre>
<p>Okay that's plenty of code to spring on you. Let's go through it function by function.</p>
<h3>getState</h3>
<pre lang="javascript">
    function getLastBlock() {
        return blockchain[blockchain.length - 1];
    }
</pre>
<p>Takes last block from the blockchain and returns it. That's our current state. We export a helper <code>getState</code> that does <code>getLastBlock().data</code> to avoid changing external APIs.</p>
<h3>Dispatch</h3>
<pre lang="javascript">
    function dispatch(action) {
        const lastBlock = getLastBlock();
        const nextData = reducer(lastBlock.data, action);

        addBlock(new Block({ previousBlock: lastBlock, data: nextData }));
    }
</pre>
<p>Same as <code>dispatch</code> before. Takes current state and builds new state with the <code>reducer</code>. Then it uses <code>addBlock</code> to insert a newly generated block into the chain.</p>
<h3>isValidNewBlock</h3>
<pre lang="javascript">
    function isValidNewBlock(newBlock, previousBlock) {
        if (previousBlock.index + 1 !== newBlock.index) {
            console.log("invalid index");
            return false;
        } else if (previousBlock.hash !== newBlock.previousHash) {
            console.log("invalid previoushash");
            return false;
        } else if (Block.calculateHash(newBlock) !== newBlock.hash) {
            console.log(
                "invalid hash: ",
                Block.calculateHash(newBlock),
                newBlock.hash
            );
            return false;
        }
        return true;
    }
</pre>
<p>Every new block has to be validated. Especially because they can come from other nodes.</p>
<p>This checks that indexes and hashes all match up so we can avoid conflicts.</p>
<h3>isValidChain</h3>
<pre lang="javascript">
   function isValidChain(blockchain) {
        for (let i = 0; i < blockchain.length - 1; i++) {
            if (!isValidNewBlock(blockchain[i + 1], blockchain[i])) {
                return false;
            }
        }
        return true;
    }
</pre>
<p>This will be used later on in conflict resolution. It goes through an entire proposed chain and validates every block.</p>
<h3>replaceChain</h3>
<pre lang="javascript">
    function replaceChain(newBlocks) {
        if (isValidChain(newBlocks) && newBlocks.length > blockchain.length) {
            blockchain = newBlocks;
            // tell others here
        }
    }
</pre>
<p>Another part of conflict resolution and node communication is replacing the whole chain. If a new valid chain comes in that's longer than what we already have, we replace our internal state with the new chain.</p>
<p>This will be particularly useful when we boot up a new client and it needs to get the whole chain.</p>
<h2>Fin</h2>
<p>That's pretty much it. A naive blockchain implementation that gives you a Redux-like API to store and manipulate data.</p>
<p>Next I'm going to add communication between nodes, probably through Firebase, and a proof-of-stake algorithm. Then we can start building something interesting.</p>
<p>And maybe you now understand blockchains a little better ðŸ¤“</p>
</div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-components-post-js","jsonName":"post-blockchain-backed-redux-clone-105-lines-code-ffd","path":"/post/blockchain-backed-redux-clone-105-lines-code/"};window.dataPath="353/path---post-blockchain-backed-redux-clone-105-lines-code-ffd-d4b-Aryh87ujDUc9A1Zuamnf3E9M";/*]]>*/</script><script src="/swizecwp/webpack-runtime-756ce6cc3c39f3c623f9.js" async=""></script><script src="/swizecwp/app-affbd460d24d53f1fc4a.js" async=""></script><script src="/swizecwp/0-ce760dfe358fb4e73f84.js" async=""></script><script src="/swizecwp/component---src-components-post-js-428e04eacc0b402938d5.js" async=""></script></body></html>