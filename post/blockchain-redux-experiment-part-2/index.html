<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/swizecblog/component---src-components-post-js.345c7c4f16662f410581.css">@import url(https://fonts.googleapis.com/css?family=Lora);
html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;font-family:Lora,serif}body{background-color:#f6f6f6;margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{-webkit-text-decoration-skip:objects;background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:Lora,serif;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{box-sizing:border-box;font:112.5%/1.45em georgia,serif;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{-moz-font-feature-settings:"kern","liga","clig","calt";-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";color:rgba(0,0,0,.8);font-family:Lora,serif;font-feature-settings:"kern","liga","clig","calt";font-kerning:normal;font-weight:400;word-wrap:break-word}img{margin:0 0 1.45rem;max-width:100%;padding:0}h1{font-size:2.25rem}h1,h2{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{list-style-image:none;list-style-position:outside;margin:0 0 1.45rem 1.45rem;padding:0}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{background:rgba(0,0,0,.04);border-radius:3px;font-size:.85rem;line-height:1.42;margin:0 0 1.45rem;overflow:auto;padding:1.45rem;word-wrap:normal}table{border-collapse:collapse;font-size:1rem;line-height:1.45rem;width:100%}fieldset,table{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{background:rgba(0,0,0,.2);border:none;height:1px;margin:0 0 calc(1.45rem - 1px);padding:0}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-bottom:.725rem;margin-left:1.45rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:Lora,serif;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{content:" ";letter-spacing:-.2em}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}

/*# sourceMappingURL=component---src-components-post-js.345c7c4f16662f410581.css.map*/</style><style data-styled-components="cEsjyT hklXLQ gpHXOM cTUdjA">
/* sc-component-id: sc-bdVaJa */
.cEsjyT{margin:3rem auto;max-width:960px;padding:1.25rem 1rem;} .cEsjyT ul{margin:0 0 0px 0;list-style:none;float:right;}
/* sc-component-id: sc-bwzfXH */
.cTUdjA{-webkit-text-decoration:none;text-decoration:none;text-align:right;margin:0 .5rem 0 .5rem;padding:10px;color:#7c51a1;} .cTUdjA:hover{color:#fff;background-color:#7c51a1;}
/* sc-component-id: sc-htpNat */
.gpHXOM{-webkit-text-decoration:none;text-decoration:none;color:black;} .gpHXOM:hover{-webkit-text-decoration:underline;text-decoration:underline;color:#7c51a1;} .gpHXOM h3{display:inline;font-size:30px;}
/* sc-component-id: sc-bxivhb */
.hklXLQ{margin:0 3rem 4.5rem;}</style><title data-react-helmet="true">Swizec Blog</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><link as="script" rel="preload" href="/swizecblog/component---src-components-post-js-dbedf083f25f7ad1f3b1.js"/><link as="script" rel="preload" href="/swizecblog/0-f215691c134019ee6fa5.js"/><link as="script" rel="preload" href="/swizecblog/app-49ff0b4ea28eff25fc3b.js"/><link as="script" rel="preload" href="/swizecblog/webpack-runtime-4f3a0bd1eef0c4ba11a9.js"/><link rel="preload" href="/swizecblog/static/d/345/path---post-blockchain-redux-experiment-part-2-9-b-9-c24-sJNzTScDEoBeSDoje1sBvttLPoY.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div><div class="sc-bdVaJa cEsjyT"><div class="sc-bxivhb hklXLQ"><a class="sc-htpNat gpHXOM" href="/swizecblog/"><h3>Swizec Teller</h3></a><ul><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Business/">Business</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Personal/">Personal</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Technical/">Technical</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Thoughts/">Thoughts</a></ul></div><h1>Blockchain Redux experiment, part 2</h1><div><p>The <a href="https://github.com/Swizec/blockchain-redux">blockchain-redux</a> experiment continues. State is now shared and preserved.</p>
<p><iframe width="580" height="326" src="https://www.youtube.com/embed/CREqFkX_r1o?feature=oembed" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></p>
<p><iframe width="580" height="326" src="https://www.youtube.com/embed/EW8uJ8Z2pYA?feature=oembed" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></p>
<p>When I last wrote about this <a href="https://swizec.com/blog/blockchain-backed-redux-clone-105-lines-code/swizec/7980">blockchain-backed Redux clone in 105 lines of code</a>, it could:</p>
<ul>
<li>build a local blockchain</li>
<li>add blocks on every action <code>dispatch</code></li>
<li>verify the chain is valid</li>
<li>replace the chain with a longer chain</li>
</ul>
<p>All the basic building blocks. But it didn&#8217;t quite have feature parity with <a href="https://github.com/reactjs/redux">the real redux</a>, and it lacked some way to share the blockchain between nodes. You started a new chain with every call to <code>createStore()</code>.</p>
<p>That has now been fixed.</p>
<h2>Feature parity with Redux</h2>
<div id="attachment_8053" style="width: 1516px" class="wp-caption alignnone"><img class="alignnone size-full wp-image-8053" src="https://swizec.com/blog/wp-content/uploads/2018/01/carbon-feature-parity.png" alt="Basically this is it, this is Redux" width="1506" height="1462" srcset="https://swizec.com/blog/wp-content/uploads/2018/01/carbon-feature-parity.png 1506w, https://swizec.com/blog/wp-content/uploads/2018/01/carbon-feature-parity-300x291.png 300w, https://swizec.com/blog/wp-content/uploads/2018/01/carbon-feature-parity-768x746.png 768w, https://swizec.com/blog/wp-content/uploads/2018/01/carbon-feature-parity-1024x994.png 1024w" sizes="(max-width: 1506px) 100vw, 1506px" /><p class="wp-caption-text">Basically this is it, this is Redux</p></div>
<p>We <a href="https://www.youtube.com/watch?v=CREqFkX%5C_r1o">reached Redux feature parity</a>… I think. We added the ability to subscribe to changes and to use middleware.</p>
<p><a href="https://github.com/Swizec/blockchain-redux">blockchain-redux</a> looks and feels the same as real Redux when you&#8217;re using it, and I think that means it&#8217;s got feature parity. In theory, you should be able to drop-in any redux plugin or middleware and it&#8217;s gonna work.</p>
<h3>Subscribing to changes</h3>
<p>The concept here is simple:</p>
<ol>
<li>A method adds functions to an array of <code>listeners</code></li>
<li>Dispatch calls all of them</li>
</ol>
<img src="https://media.giphy.com/media/krhB8ydCQiYZq/giphy.gif" />
<pre lang="javascript">
    let listeners = [];

    function subscribe(listener) {
        listeners.push(listener);

        return function unsubscribe() {
            listeners.splice(listeners.indexOf(listener), 1);
        };
    }
</pre>
<p>We keep a <code>listeners</code> array. It starts as empty. Calling <code>subscribe</code>, which is exposed as an API, adds your listener to the list. In <code>return</code> you get a function that lets you unsubscribe.</p>
<p>Using <code>listeners.splice</code> to remove functions like that comes <a href="https://github.com/reactjs/redux/blob/master/src/createStore.js#L136">straight from Redux source</a>. It&#8217;s probably faster than building a new list using <code>.filter</code>.</p>
<h3>Middleware support</h3>
<p>Adding middleware support was trickier.</p>
<p>Middleware, in essence, wraps the Redux store and changes how its functions work. You can think of it like a higher-order-component or a function decorator. Whichever makes more sense to you.</p>
<p>Redux itself makes this easier with an <code>applyMiddleware</code> function, but I didn&#8217;t want to build that just yet. I don&#8217;t think it&#8217;s strictly necessary, but maybe that breaks feature parity. 🤔</p>
<p>First part is to add a 3rd argument to <code>createStore</code> –&nbsp;the <code>enhancer</code>.</p>
<pre lang="javascript">
function createStore(reducer, preloadedState, enhancer) {
    if (
        typeof preloadedState === "function" &&
        typeof enhancer === "undefined"
    ) {
        enhancer = preloadedState;
        preloadedState = undefined;
    }

    if (typeof enhancer === "function") {
        return enhancer(createStore)(reducer, preloadedState);
    }
</pre>
<p>If <code>enhancer</code> is a function, we pass the <code>createstore</code> function to it and say, <em>&#8220;Ok, you do this.”</em></p>
<p>The enhancer, a middleware, then takes care of instantiating the store and changing its behavior. A simple middleware that prints out every call to <code>dispatch</code> would look like this.</p>
<pre lang="javascript">
// a logging middleweare
export default function() {
    return createStore => (...args) => {
        const store = createStore(...args);
        const _dispatch = store.dispatch;

        function dispatch(action) {
            _dispatch(action);

            console.log("ACTION", action);
        }
        
        return Object.assign(store, {
            dispatch
        });
    }
};
</pre>
<p>We&#8217;re using some functional concepts here to do our thing. Currying for the most part.</p>
<p>Our logging middleware returns a function that takes <code>createStore</code> as its argument. This in turn returns a function that takes arguments, usually <code>reducer</code> and <code>preloadedState</code>.</p>
<p>It immediately calls <code>createState</code> to build the store. This time without passing a middleware.</p>
<p>Then our redux middleware overwrites the <code>dispatch</code> function with its own function that prints actions as well as calls the original dispatch.</p>
<p>In the end, we return the augmented store.</p>
<p>I borrowed this approach from Redux&#8217;s applyMiddleware function, and it works great. Where I think my approach might suffer is applying multiple middlewares.</p>
<p>But we can solve that problem when we get to it 😇</p>
<h2>Sharing the chain between nodes</h2>
<p>We went to all that trouble of supporting middleware so that we can build different strategies for sharing our blockchain. blockchain-redux itself should focus on building the blockchain, dispatching actions, and keeping state.</p>
<p>How that gets shared between nodes lives in a separate layer.</p>
<p>For now, that layer is Firebase. This gives us an easy backend to work against and make sure nodes are communicating. Great way to iron out kinks, but it makes our blockchain centralized.</p>
<p>We&#8217;ll solve the centralization problem next.</p>
<p>Here&#8217;s how the Firebase middleware works 👇</p>
<div id="attachment_8054" style="width: 1616px" class="wp-caption alignnone"><img class="alignnone size-full wp-image-8054" src="https://swizec.com/blog/wp-content/uploads/2018/01/carbon-firebase-blockchain-sharing.png" alt="Sharing the chain between nodes using Firebase" width="1606" height="2326" srcset="https://swizec.com/blog/wp-content/uploads/2018/01/carbon-firebase-blockchain-sharing.png 1606w, https://swizec.com/blog/wp-content/uploads/2018/01/carbon-firebase-blockchain-sharing-207x300.png 207w, https://swizec.com/blog/wp-content/uploads/2018/01/carbon-firebase-blockchain-sharing-768x1112.png 768w, https://swizec.com/blog/wp-content/uploads/2018/01/carbon-firebase-blockchain-sharing-707x1024.png 707w" sizes="(max-width: 1606px) 100vw, 1606px" /><p class="wp-caption-text">Sharing the chain between nodes using Firebase</p></div>
<p>Our middleware exports a function that takes an initialized FirebaseApp as its argument. This made it easier to have multiple instances of the store sharing the same Firebase when testing.</p>
<p>Just like before, the only function it augments is <code>dispatch</code>. It now tries to save new blocks to Firebase.</p>
<pre lang="javascript">
        function dispatch(action) {
            _dispatch(action);

            const newBlock = store.getLastBlock();
            return saveBlock(newBlock);
        }
</pre>
<p>Dispatch the action, get latest block from the store, save block to firebase. 👌</p>
<p>Saving that block is fraught with some difficulty, however.</p>
<pre lang="javascript">
        function saveBlock(block) {
            block._data = block._data || {};

            return db
                .ref(`blockchain/${block.index}`)
                .once("value")
                .then(snapshot => {
                    if (!snapshot.exists()) {
                        db.ref(`blockchain/${block.index}`).set(block);
                        return true;
                    } else {
                        // collision resolution?
                        return false;
                    }
                });
        }
</pre>
<p>We save blocks at <code>blockchain/&lt;index&gt;</code>. On every save, we check if the blocks already exists. If it doesn’t, we save the block and everyone is happy.</p>
<p>However, if somebody else already created the same block successfully, we&#8217;re in trouble. Right now, the middleware silently drops the save, and that&#8217;s bad.</p>
<p>I think the easiest solution will be to sync with the Firebase blockchain before dispatching an action and making a new block. Or we could dispatch the action and run a save-dispatch-save cycle until it succeeds.</p>
<p>Neither of those approaches is very optimal from a network utilization perspective. Not sure yet what to do here.</p>
<h3>Initing the store from blockchain</h3>
<p>Another interesting problem was initializing our store from the blockchain. How do you ensure you have the whole chain before building new blocks?</p>
<p>One approach I found was to read the whole thing from Firebase and replacing the local stub chain with the big one.</p>
<pre lang="javascript">
function initFromFirebase() {
            return db
                .ref("blockchain")
                .orderByKey()
                .once("value")
                .then(snapshot => snapshot.val())
                .then(blockchain => {
                    blockchain = Object.values(blockchain).map(block => {
                        block.data = block._data ? JSON.parse(block._data) : {};
                        return block;
                    });

                    store.replaceChain(blockchain);

                    return Object.assign(store, {
                        dispatch
                    });
                });
        }

        return Promise.all(store._blockchain.map(saveBlock)).then(
            initFromFirebase
        );
</pre>
<p><code>initFromFirebase</code> reads our central blockchain from Firebase, goes through the blocks and makes sure <code>data</code> is in the right format, then runs <code>replaceChain</code>.</p>
<p>You&#8217;ll notice this is now where we return the Redux store. That means <code>createStore</code> is asynchronous and wreaks havoc on just about everything we hold dear about using Redux.</p>
<p>But I&#8217;m not sure how to fix that. We need to have the chain before dispatching our first function. Maybe a waiting mechanism in dispatch 🤔</p>
<p>Oh, and that last part? That&#8217;s so we create the blockchain stub on Firebase in case it doesn&#8217;t exist yet. Goes through blocks in the default chain and makes sure they exist on Firebase.</p>
<h2>What next</h2>
<p>This is still a rough experiment. The blockchain implementation works, it communicates through Firebase so it&#8217;s distributed, but it has trouble with conflict resolution, has a centralized source of truth, and is very network and memory inefficient.</p>
<p>All of that is bad.</p>
<p>I want to move towards using Firebase as just a communication protocol between nodes so instead of saving the whole blockchain there, we just announce new blocks and other nodes pick them up. That would be more efficient.</p>
<p>I also want to figure out how to avoid saving the whole blockchain locally. But maybe that&#8217;s fundamentally not possible 🤔</p>
<p>Got suggestions? Yell <a href="https://twitter.com/swizec">at me on Twitter</a>.</p>
</div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-components-post-js","jsonName":"post-blockchain-redux-experiment-part-2-9b9","path":"/post/blockchain-redux-experiment-part-2/"};window.dataPath="345/path---post-blockchain-redux-experiment-part-2-9-b-9-c24-sJNzTScDEoBeSDoje1sBvttLPoY";/*]]>*/</script><script src="/swizecblog/webpack-runtime-4f3a0bd1eef0c4ba11a9.js" async=""></script><script src="/swizecblog/app-49ff0b4ea28eff25fc3b.js" async=""></script><script src="/swizecblog/0-f215691c134019ee6fa5.js" async=""></script><script src="/swizecblog/component---src-components-post-js-dbedf083f25f7ad1f3b1.js" async=""></script></body></html>