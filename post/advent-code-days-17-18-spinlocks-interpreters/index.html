<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/swizecblog/component---src-components-post-js.15d6bfea4d3b992d9691.css">@import url(https://fonts.googleapis.com/css?family=Lora);
html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;font-family:Lora,serif}body{background-color:#f6f6f6;margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{-webkit-text-decoration-skip:objects;background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:Lora,serif;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{box-sizing:border-box;font:112.5%/1.45em georgia,serif;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{-moz-font-feature-settings:"kern","liga","clig","calt";-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";color:rgba(0,0,0,.8);font-family:Lora,serif;font-feature-settings:"kern","liga","clig","calt";-webkit-font-kerning:normal;font-kerning:normal;font-weight:400;word-wrap:break-word}img{margin:0 0 1.45rem;max-width:100%;padding:0}h1{font-size:2.25rem}h1,h2{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{color:inherit;font-family:Lora,serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0;text-rendering:optimizeLegibility}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{list-style-image:none;list-style-position:outside;margin:0 0 1.45rem 1.45rem;padding:0}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{background:rgba(0,0,0,.04);border-radius:3px;font-size:.85rem;line-height:1.42;margin:0 0 1.45rem;overflow:auto;padding:1.45rem;word-wrap:normal}table{border-collapse:collapse;font-size:1rem;line-height:1.45rem;width:100%}fieldset,table{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{background:rgba(0,0,0,.2);border:none;height:1px;margin:0 0 calc(1.45rem - 1px);padding:0}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-bottom:.725rem;margin-left:1.45rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:Lora,serif;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{content:" ";letter-spacing:-.2em}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}

/*# sourceMappingURL=component---src-components-post-js.15d6bfea4d3b992d9691.css.map*/</style><style data-styled-components="cEsjyT hklXLQ gpHXOM cTUdjA">
/* sc-component-id: sc-bdVaJa */
.cEsjyT{margin:3rem auto;max-width:960px;padding:1.25rem 1rem;} .cEsjyT ul{margin:0 0 0px 0;list-style:none;float:right;}
/* sc-component-id: sc-bwzfXH */
.cTUdjA{-webkit-text-decoration:none;text-decoration:none;text-align:right;margin:0 .5rem 0 .5rem;padding:10px;color:#7c51a1;} .cTUdjA:hover{color:#fff;background-color:#7c51a1;}
/* sc-component-id: sc-htpNat */
.gpHXOM{-webkit-text-decoration:none;text-decoration:none;color:black;} .gpHXOM:hover{-webkit-text-decoration:underline;text-decoration:underline;color:#7c51a1;} .gpHXOM h3{display:inline;font-size:30px;}
/* sc-component-id: sc-bxivhb */
.hklXLQ{margin:0 3rem 4.5rem;}</style><title data-react-helmet="true">Swizec Blog</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><link as="script" rel="preload" href="/swizecblog/component---src-components-post-js-428e04eacc0b402938d5.js"/><link as="script" rel="preload" href="/swizecblog/0-20c56a8bf68923b243f7.js"/><link as="script" rel="preload" href="/swizecblog/app-f4c654d11b4415967aef.js"/><link as="script" rel="preload" href="/swizecblog/webpack-runtime-559e9e27cf35c66d2ba0.js"/><link rel="preload" href="/swizecblog/static/d/440/path---post-advent-code-days-17-18-spinlocks-interpreters-1-d-6-0b7-NXaCzK2RVas9G7FHfB1eJKnqM0.json" as="fetch" crossOrigin="use-credentials"/></head><body><div id="___gatsby"><div><div class="sc-bdVaJa cEsjyT"><div class="sc-bxivhb hklXLQ"><a class="sc-htpNat gpHXOM" href="/swizecblog/"><h3>Swizec Teller</h3></a><ul><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Business/">Business</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Personal/">Personal</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Technical/">Technical</a><a class="sc-bwzfXH cTUdjA" href="/swizecblog/Thoughts/">Thoughts</a></ul></div><h1>Advent of Code Days 17 &#038; 18 â€“ Spinlocks and Interpreters</h1><div><p><iframe width="580" height="326" src="https://www.youtube.com/embed/3Eee0va5t0A?feature=oembed" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></p>
<p>Days 17 and 18 both defeated me. Star 1 was easy, Star 2 was not. Both were pretty quick to solve for the first star, though, so let&#8217;s look at that.</p>
<h2>Day 17 â€“ Spinlock</h2>
<p>For Advent of Code Day 17, we had to implement a <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a>. Spinlocks are a way to implement busy waiting ðŸ‘‡</p>
<blockquote><p>
In software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop (&#8220;spin&#8221;) while repeatedly checking if the lock is available. Since the thread remains active but is not performing a useful task, the use of such a lock is a kind of busy waiting.
</p></blockquote>
<div id="attachment_7975" style="width: 1538px" class="wp-caption alignnone"><img class="alignnone size-full wp-image-7975" src="https://swizec.com/blog/wp-content/uploads/2017/12/carbon-spinlock.png" alt="A naive spinlock implementation in Haskell" width="1528" height="512" srcset="https://swizec.com/blog/wp-content/uploads/2017/12/carbon-spinlock.png 1528w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-spinlock-300x101.png 300w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-spinlock-768x257.png 768w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-spinlock-1024x343.png 1024w" sizes="(max-width: 1528px) 100vw, 1528px" /><p class="wp-caption-text">A naive spinlock implementation in Haskell</p></div>
<p>There&#8217;s no video for Day 17 because I was doing it in bed and yes, I did fall asleep while waiting for Star 2 to finish computing. It never did; my algorithm was too slow.</p>
<p>Unlike a real spinlock, the puzzle spinlock is trying to eat up infinite memory as well as infinite time.</p>
<blockquote><p>
For example, if the spinlock were to step 3 times per insert, the circular buffer would begin to evolve like this (using parentheses to mark the current position after each iteration of the algorithm):
</p></blockquote>
<blockquote><p>
(0), the initial state before any insertions.</p>
<p>0 (1): the spinlock steps forward three times (0, 0, 0), and then inserts the first value, 1, after it. 1 becomes the current position.</p>
<p>0 (2) 1: the spinlock steps forward three times (0, 1, 0), and then inserts the second value, 2, after it. 2 becomes the current position.</p>
<p>0  2 (3) 1: the spinlock steps forward three times (1, 0, 2), and then inserts the third value, 3, after it. 3 becomes the current position.
</p></blockquote>
<p>The question was <em>&#8220;What is the value right after 2017 gets inserted into the buffer?&#8221;</em>.</p>
<p>To find out, I built a recursive implementation of the spinlock algorithm above in Haskell. Because Haskell is fun.</p>
<pre lang="haskell">
spinlock::[Int] -> Int -> Int -> Int -> Int -> (Int, [Int])
spinlock buffer steps pos i iterations
    | i < iterations = spinlock (left ++ [i] ++ right) steps nextPos (i+1) iterations
    | otherwise = (nextPos, buffer)
    where spinPos = mod (pos+steps) (length buffer)
          (left, right) = splitAt (spinPos+1) buffer
          nextPos = spinPos+1
</pre>
<p>The <code>spinlock</code> method takes 5 arguments, which I'm sure is sacrilege in Haskell, and returns a tuple: An integer and a list of integers.</p>
<p>Arguments look like this:</p>
<ul>
<li><code>buffer</code> is the current state of our circular buffer</li>
<li><code>steps</code> tells us how many steps we do on each spin</li>
<li><code>pos</code> gives us the current position in our buffer</li>
<li><code>i</code> says how many times we've iterated</li>
<li><code>iterations</code> tells us how many times to iterate in total</li>
</ul>
<p>The algorithm itself was simple to implement, but fraught with <a href="https://en.wikipedia.org/wiki/Off-by-one_error">off-by-one errors</a>.</p>
<p>If we have to keep going â€“&nbsp;<code>i &lt; iterations</code> â€“&nbsp;then recurse with an edited buffer, updated position and <code>i+1</code>. Otherwise, return the result. A tuple with the next position and final buffer.</p>
<p>We get the position after spinning, <code>spinPos</code>, as a remainder between current position <code>pos</code> and <code>steps</code>, and the buffer length. Split the buffer into <code>left</code> and <code>right</code> at position after the spin, and say the next position is going to be there too.</p>
<p>This worked great for the <code>2017</code> iterations from Star 1.</p>
<pre lang="haskell">
star1::Int -> Int
star1 steps = buffer!!pos
    where (pos, buffer) = spinlock [0] steps 0 1 2017
</pre>
<p>A little slow maybe, but it worked.</p>
<p>For Star 2, they wanted us to find the value after <code>0</code> when 50,000,000 iterations are performed. This did not go so well.</p>
<pre lang="haskell">
star2::Int -> Int
star2 steps = buffer!!(zeroAt+1)
    where (pos, buffer) = spinlock [0] steps 0 1 50000000
          zeroAt = Data.Maybe.fromJust $ elemIndex 0 buffer 
</pre>
<p>The idea is simple: Iterate 50 million times, look for the <code>0</code>, return the value after it.</p>
<p>But the spinlock never finishes. Haskell's <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a> gets in the way, and I couldn't figure out how to make it stop.</p>
<p>With lazy evaluation, we keep all iterations of the spinlock in memory until we print the final result. That's a problem.</p>
<p><em>shrug</em></p>
<h2>Day 18 â€“&nbsp;A programming language interpreter</h2>
<div id="attachment_7976" style="width: 1366px" class="wp-caption alignnone"><img class="alignnone size-full wp-image-7976" src="https://swizec.com/blog/wp-content/uploads/2017/12/carbon-interpreter.png" alt="The gist of a simple interpreter built in JavaScript" width="1356" height="920" srcset="https://swizec.com/blog/wp-content/uploads/2017/12/carbon-interpreter.png 1356w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-interpreter-300x204.png 300w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-interpreter-768x521.png 768w, https://swizec.com/blog/wp-content/uploads/2017/12/carbon-interpreter-1024x695.png 1024w" sizes="(max-width: 1356px) 100vw, 1356px" /><p class="wp-caption-text">The gist of a simple interpreter built in JavaScript</p></div>
<p>On Day 18 of our Advent of Code, we had to build an interpreter for a simple programming language. There are 7 commands that take 1 or 2 arguments. Arguments can be registers or values.</p>
<blockquote><p>
<code>snd X</code> plays a sound with a frequency equal to the value of X.</p>
<p><code>set X Y</code> sets register X to the value of Y.</p>
<p><code>add X Y</code> increases register X by the value of Y.</p>
<p><code>mul X Y</code> sets register X to the result of multiplying the value contained in register X by the value of Y.</p>
<p><code>mod X Y</code> sets register X to the remainder of dividing the value contained in register X by the value of Y (that is, it sets X to the result of X modulo Y).</p>
<p><code>rcv X</code> recovers the frequency of the last sound played, but only when the value of X is not zero. (If it is zero, the command does nothing.)</p>
<p><code>jgz X Y</code> jumps with an offset of the value of Y, but only if the value of X is greater than zero. (An offset of 2 skips the next instruction, an offset of -1 jumps to the previous instruction, and so on.)
</p></blockquote>
<p>Our goal is to find the first non-zero value that <code>rcv</code> finds.</p>
<p>I built this one in JavaScript because why not. ðŸ˜‡</p>
<p>We start with a bunch of <code>registers</code>, which are a JavaScript <code>Map</code>.</p>
<pre lang="javascript">
function initRegisters() {
    const registers = new Map(
        "abcdefghijklmnopqrstuvwxyz".split("").map(l => [l, 0])
    );
    registers.set("sound", null);
    registers.set("pointer", 0);

    return registers;
}
</pre>
<p>This creates a register for each letter of the alphabet plus a <code>sound</code> register and a <code>pointer</code>. <code>sound</code> will be where <code>snd</code> puts its values and <code>rcv</code> reads them from, <code>pointer</code> is going to point to the current line of code we're executing.</p>
<p>The interpreter itself comes as just 39 lines of code. It's a simple language after all. Although I do think it's got enough instructions to be <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a>, but it lacks the memory. 25 registers won't cut it for Turing completeness.</p>
<p>You could, of course, expand it to have infinite registers ðŸ¤”</p>
<p>Anyway, the interpreter ðŸ‘‡</p>
<pre lang="javascript">
function execute(registers, command) {
    const [com, val1, val2] = command.trim().split(" ");

    function getVal(val) {
        if (registers.has(val)) {
            return registers.get(val);
        } else {
            return Number(val);
        }
    }

    let jumped = false,
        kill = false;

    const commands = {
        snd: a => registers.set("sound", getVal(a)),
        set: (a, b) => registers.set(a, getVal(b)),
        add: (a, b) => registers.set(a, getVal(a) + getVal(b)),
        mul: (a, b) => registers.set(a, getVal(a) * getVal(b)),
        mod: (a, b) => registers.set(a, getVal(a) % getVal(b)),
        rcv: a => (
            console.log("SOUND:", getVal("sound")),
            (kill = true),
            registers.set(a, getVal("sound"))
        ),
        jgz: (a, b) =>
            getVal(a) > 0
                ? ((jumped = true),
                  registers.set("pointer", getVal("pointer") + getVal(b)))
                : null
    };

    commands[com](val1, val2);

    if (!jumped) {
        registers.set("pointer", getVal("pointer") + 1);
    }

    return [kill, registers];
}
</pre>
<p>We split the line of code into a <code>command</code> and two values, <code>val1</code> and <code>val2</code>.</p>
<p>Then we define a function for reading values, <code>getVal</code>. If the value given is a known register, we read from it; otherwise, we return the value itself.</p>
<p>After that, we need two flags: <code>jump</code> tells us if we executed a jump command, and <code>kill</code> tells us if we have to stop executing.</p>
<p>A dictionary mapping all possible commands to a function that executes them helps us run the commands. Each function manipulates the <code>registers</code> and potentially flips the <code>jump</code> and <code>kill</code> flags.</p>
<p>When the current line of code is executed, we advance our <code>pointer</code> by <code>+1</code> if we didn't jump. The interpreter returns the <code>kill</code> flag and the new <code>registers</code>.</p>
<p>The registers are actually changed in place, and there's no need to return, but I think this approach makes our implementation clearer.</p>
<p>With the interpreter in hand, we then have to add some looping to find the answer to AoC 18 Star 1.</p>
<pre lang="javascript">
function star1() {
    let registers = initRegisters(),
        kill = false;
    const program = input.split("\n").filter(command => command.length > 0);

    // find sound value at first non-zero rcv
    while (
        registers.get("pointer") >= 0 &&
        registers.get("pointer") < program.length &#038;&#038;
        !kill
    ) {
        [kill, registers] = execute(
            registers,
            program[registers.get("pointer")]
        );
    }
}
</pre>
<p>Create registers, split program into lines, <code>execute</code> until a <code>while</code> condition is met. Either we jumped out of the program, or a line set the <code>kill</code> flag.</p>
<p>Works like a charm ðŸ‘Œ</p>
<p><strong>Star 2</strong> is where it gets tricky. Those <code>snd</code> and <code>rcv</code> commands weren't actually about sound; they were <code>send</code> and <code>receive</code> commands, and you're meant to run two copies of this code in parallel.</p>
<p>They communicate with <code>snd</code> and <code>rcv</code>.</p>
<p>We have to expand our <code>sound</code> register into a message queue and add some logic for how it's shared between the two programs. Additionally, the puzzle wants us to pause execution of each program while it waits for the queue to get values.</p>
<img src="https://media.giphy.com/media/3oEdvc4JCV2HJa7UQ0/giphy.gif" />
<p>Sounds hard. So I went to bed.</p>
</div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.page={"componentChunkName":"component---src-components-post-js","jsonName":"post-advent-code-days-17-18-spinlocks-interpreters-1d6","path":"/post/advent-code-days-17-18-spinlocks-interpreters/"};window.dataPath="440/path---post-advent-code-days-17-18-spinlocks-interpreters-1-d-6-0b7-NXaCzK2RVas9G7FHfB1eJKnqM0";/*]]>*/</script><script src="/swizecblog/webpack-runtime-559e9e27cf35c66d2ba0.js" async=""></script><script src="/swizecblog/app-f4c654d11b4415967aef.js" async=""></script><script src="/swizecblog/0-20c56a8bf68923b243f7.js" async=""></script><script src="/swizecblog/component---src-components-post-js-428e04eacc0b402938d5.js" async=""></script></body></html>